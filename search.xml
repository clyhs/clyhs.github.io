<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GO编程学习一:GO基础</title>
    <url>/2017/07/19/GO%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%80-GO%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="你好，Go"><a href="/2017/07/19/GO编程学习一-GO基础/#你好，Go" class="headerlink" title="你好，Go"></a>你好，Go</h2><h3 id="程序"><a href="/2017/07/19/GO编程学习一-GO基础/#程序" class="headerlink" title="程序"></a>程序</h3><p>这就像一个传统，在学习大部分语言之前，你先学会如何编写一个可以输出hello world的程序。<br>准备好了吗？Let’s Go!<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Hello, world \n"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Hello, world</span><br></pre></td></tr></table></figure></p>
<h3 id="详解"><a href="/2017/07/19/GO编程学习一-GO基础/#详解" class="headerlink" title="详解"></a>详解</h3><p>首先我们要了解一个概念，Go程序是通过package来组织的<br>package <pkgname>（在我们的例子中是package main）这一行告诉我们当前文件属于哪个包，而包名main则<br>告诉我们它是一个可独立运行的包，它在编译后会产生可执行文件。除了main包之外，其它的包最后都会生成*.a文<br>件（也就是包文件）并放置在$GOPATH/pkg/$GOOS_$GOARCH中（以Mac为例就是<br>$GOPATH/pkg/darwin_amd64）。<br>每一个可独立运行的Go程序，必定包含一个package main，在这个main包中必定包含一个入口函数main，而这<br>个函数既没有参数，也没有返回值。<br>为了打印Hello, world…，我们调用了一个函数Printf，这个函数来自于fmt包，所以我们在第三行中导入了<br>系统级别的fmt包：import “fmt”。</pkgname></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO编程学习七-表单处理</title>
    <url>/2017/07/22/GO%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%83-%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="处理表单的输入"><a href="/2017/07/22/GO编程学习七-表单处理/#处理表单的输入" class="headerlink" title="处理表单的输入"></a>处理表单的输入</h3><p>先来看一个表单递交的例子，我们有如下的表单内容，命名成文件login.gtpl(放入当前新建项目的目录里面)<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://127.0.0.1:9090/login"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登陆"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面递交表单到服务器的/login，当用户输入信息点击登陆之后，会跳转到服务器的路由login里面，我们首先要<br>判断这个是什么方式传递过来，POST还是GET呢？<br>http包里面有一个很简单的方式就可以获取，我们在前面web的例子的基础上来看看怎么处理login页面的form数据</p>
<p>http包里面有一个很简单的方式就可以获取，我们在前面web的例子的基础上来看看怎么处理login页面的form数据<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"html/template"</span></span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    <span class="string">"net/http"</span></span><br><span class="line">    <span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayhelloName</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    r.ParseForm() <span class="comment">//解析url传递的参数，对于POST则解析响应包的主体（request body）</span></span><br><span class="line">    <span class="comment">//注意:如果没有调用ParseForm方法，下面无法获取表单的数据</span></span><br><span class="line">    fmt.Println(r.Form) <span class="comment">//这些信息是输出到服务器端的打印信息</span></span><br><span class="line">    fmt.Println(<span class="string">"path"</span>, r.URL.Path)</span><br><span class="line">    fmt.Println(<span class="string">"scheme"</span>, r.URL.Scheme)</span><br><span class="line">        fmt.Println(r.Form[<span class="string">"url_long"</span>])</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> r.Form &#123;</span><br><span class="line">        fmt.Println(<span class="string">"key:"</span>, k)</span><br><span class="line">        fmt.Println(<span class="string">"val:"</span>, strings.Join(v, <span class="string">""</span>))</span><br><span class="line">    &#125;</span><br><span class="line">        fmt.Fprintf(w, <span class="string">"Hello astaxie!"</span>) <span class="comment">//这个写入到w的是输出到客户端的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">login</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"method:"</span>, r.Method) <span class="comment">//获取请求的方法</span></span><br><span class="line">    <span class="keyword">if</span> r.Method == <span class="string">"GET"</span> &#123;</span><br><span class="line">        t, _ := template.ParseFiles(<span class="string">"login.gtpl"</span>)</span><br><span class="line">        t.Execute(w, <span class="literal">nil</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//请求的是登陆数据，那么执行登陆的逻辑判断</span></span><br><span class="line">        r.ParseForm()</span><br><span class="line">        fmt.Println(<span class="string">"username:"</span>, r.Form[<span class="string">"username"</span>])</span><br><span class="line">        fmt.Println(<span class="string">"password:"</span>, r.Form[<span class="string">"password"</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">"/"</span>, sayhelloName) <span class="comment">//设置访问的路由</span></span><br><span class="line">    http.HandleFunc(<span class="string">"/login"</span>, login) <span class="comment">//设置访问的路由</span></span><br><span class="line">    err := http.ListenAndServe(<span class="string">":9090"</span>, <span class="literal">nil</span>) <span class="comment">//设置监听的端口</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">"ListenAndServe: "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码我们可以看出获取请求方法是通过r.Method来完成的，这是个字符串类型的变量，返回GET, POST,<br>PUT等method信息。<br>login函数中我们根据r.Method来判断是显示登录界面还是处理登录逻辑。当GET方式请求时显示登录界面，其他方<br>式请求时则处理登录逻辑，如查询数据库、验证登录信息等。<br>当我们在浏览器里面打开<a href="http://127.0.0.1:9090/login的时候，出现如下界面" target="_blank" rel="noopener">http://127.0.0.1:9090/login的时候，出现如下界面</a><br><img src="https://clyhs.github.io/images/go/go_03.png" alt="img"><br>我们输入用户名和密码之后发现在服务器端是不会打印出来任何输出的，为什么呢？默认情况下，Handler里面是不<br>会自动解析form的，必须显式的调用r.ParseForm()后，你才能对这个表单数据进行操作。我们修改一下代码，在<br>fmt.Println(“username:”, r.Form[“username”])之前加一行r.ParseForm(),重新编译，再次测试输入<br>递交，现在是不是在服务器端有输出你的输入的用户名和密码了。<br>r.Form里面包含了所有请求的参数，比如URL中query-string、POST的数据、PUT的数据，所有当你在URL的querystring<br>字段和POST冲突时，会保存成一个slice，里面存储了多个值，Go官方文档中说在接下来的版本里面将会把<br>POST、GET这些数据分离开来。</p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO编程学习三-Struct类型</title>
    <url>/2017/07/19/GO%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B8%89-Struct%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="struct"><a href="/2017/07/19/GO编程学习三-Struct类型/#struct" class="headerlink" title="struct"></a>struct</h2><p>Go语言中，也和C或者其他语言一样，我们可以声明新的类型，作为其它类型的属性或字段的容器。例如，我们可以<br>创建一个自定义类型person代表一个人的实体。这个实体拥有属性：姓名和年龄。这样的类型我们称之struct。如<br>下代码所示:<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> P person <span class="comment">// P现在就是person类型的变量了</span></span><br><span class="line"></span><br><span class="line">P.name = <span class="string">"Astaxie"</span> <span class="comment">// 赋值"Astaxie"给P的name属性.</span></span><br><span class="line">P.age = <span class="number">25</span> <span class="comment">// 赋值"25"给变量P的age属性</span></span><br><span class="line">fmt.Printf(<span class="string">"The person's name is %s"</span>, P.name) <span class="comment">// 访问P的name属性.</span></span><br></pre></td></tr></table></figure></p>
<p>除了上面这种P的声明使用之外，还有两种声明使用方式</p>
<ul>
<li>1.按照顺序提供初始化值<br>P := person{“Tom”, 25}</li>
<li>2.通过field:value的方式初始化，这样可以任意顺序<br>P := person{age:24, name:”Tom”}</li>
</ul>
<p>下面我们看一个完整的使用struct的例子<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 声明一个新的类型</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 比较两个人的年龄，返回年龄大的那个人，并且返回年龄差</span></span><br><span class="line"><span class="comment">// struct也是传值的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Older</span><span class="params">(p1, p2 person)</span> <span class="params">(person, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p1.age&gt;p2.age &#123; <span class="comment">// 比较p1和p2这两个人的年龄</span></span><br><span class="line">        <span class="keyword">return</span> p1, p1.age-p2.age</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2, p2.age-p1.age</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tom person</span><br><span class="line">    <span class="comment">// 赋值初始化</span></span><br><span class="line">    tom.name, tom.age = <span class="string">"Tom"</span>, <span class="number">18</span></span><br><span class="line">    <span class="comment">// 两个字段都写清楚的初始化</span></span><br><span class="line">    bob := person&#123;age:<span class="number">25</span>, name:<span class="string">"Bob"</span>&#125;</span><br><span class="line">    <span class="comment">// 按照struct定义顺序初始化值</span></span><br><span class="line">    paul := person&#123;<span class="string">"Paul"</span>, <span class="number">43</span>&#125;</span><br><span class="line">    tb_Older, tb_diff := Older(tom, bob)</span><br><span class="line">    tp_Older, tp_diff := Older(tom, paul)</span><br><span class="line">    bp_Older, bp_diff := Older(bob, paul)</span><br><span class="line">    fmt.Printf(<span class="string">"Of %s and %s, %s is older by %d years\n"</span>,</span><br><span class="line">    tom.name, bob.name, tb_Older.name, tb_diff)</span><br><span class="line">    fmt.Printf(<span class="string">"Of %s and %s, %s is older by %d years\n"</span>,</span><br><span class="line">    tom.name, paul.name, tp_Older.name, tp_diff)</span><br><span class="line">    fmt.Printf(<span class="string">"Of %s and %s, %s is older by %d years\n"</span>,</span><br><span class="line">    bob.name, paul.name, bp_Older.name, bp_diff)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="struct的匿名字段"><a href="/2017/07/19/GO编程学习三-Struct类型/#struct的匿名字段" class="headerlink" title="struct的匿名字段"></a>struct的匿名字段</h4><p>我们上面介绍了如何定义一个struct，定义的时候是字段名与其类型一一对应，实际上Go支持只提供类型，而不写字<br>段名的方式，也就是匿名字段，也称为嵌入字段。<br>当匿名字段是一个struct的时候，那么这个struct所拥有的全部字段都被隐式地引入了当前定义的这个struct。<br>让我们来看一个例子，让上面说的这些更具体化<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    weight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">// 匿名字段，那么默认Student就包含了Human的所有字段</span></span><br><span class="line">    speciality <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 我们初始化一个学生</span></span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">"Mark"</span>, <span class="number">25</span>, <span class="number">120</span>&#125;, <span class="string">"Computer Science"</span>&#125;</span><br><span class="line">    <span class="comment">// 我们访问相应的字段</span></span><br><span class="line">    fmt.Println(<span class="string">"His name is "</span>, mark.name)</span><br><span class="line">    fmt.Println(<span class="string">"His age is "</span>, mark.age)</span><br><span class="line">    fmt.Println(<span class="string">"His weight is "</span>, mark.weight)</span><br><span class="line">    fmt.Println(<span class="string">"His speciality is "</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改对应的备注信息</span></span><br><span class="line">    mark.speciality = <span class="string">"AI"</span></span><br><span class="line">    fmt.Println(<span class="string">"Mark changed his speciality"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"His speciality is "</span>, mark.speciality)</span><br><span class="line">    <span class="comment">// 修改他的年龄信息</span></span><br><span class="line">    fmt.Println(<span class="string">"Mark become old"</span>)</span><br><span class="line">    mark.age = <span class="number">46</span></span><br><span class="line">    fmt.Println(<span class="string">"His age is"</span>, mark.age)</span><br><span class="line">    <span class="comment">// 修改他的体重信息</span></span><br><span class="line">    fmt.Println(<span class="string">"Mark is not an athlet anymore"</span>)</span><br><span class="line">    mark.weight += <span class="number">60</span></span><br><span class="line">    fmt.Println(<span class="string">"His weight is"</span>, mark.weight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO编程学习二:流程与函数</title>
    <url>/2017/07/19/GO%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%BA%8C-%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="流程和函数"><a href="/2017/07/19/GO编程学习二-流程与函数/#流程和函数" class="headerlink" title="流程和函数"></a>流程和函数</h2><h3 id="流程控制"><a href="/2017/07/19/GO编程学习二-流程与函数/#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if"><a href="/2017/07/19/GO编程学习二-流程与函数/#if" class="headerlink" title="if"></a>if</h4><p>Go里面if条件判断语句中不需要括号，如下代码所示<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"x is greater than 10"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"x is less than 10"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Go的if允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其<br>他地方就不起作用了，如下所示<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算获取值x,然后根据x返回的大小，判断是否大于10。</span></span><br><span class="line"><span class="keyword">if</span> x := computedValue(); x &gt; <span class="number">10</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"x is greater than 10"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"x is less than 10"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//这个地方如果这样调用就编译出错了，因为x是条件里面的变量<br>fmt.Println(x)</p>
<h4 id="goto"><a href="/2017/07/19/GO编程学习二-流程与函数/#goto" class="headerlink" title="goto"></a>goto</h4><p>Go有goto语句——请明智地使用它。用goto跳转到必须在当前函数内定义的标签。例如假设这样一个循环：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">Here: <span class="comment">//这行的第一个词，以冒号结束作为标签</span></span><br><span class="line">    <span class="built_in">println</span>(i)</span><br><span class="line">    i++</span><br><span class="line">    <span class="keyword">goto</span> Here <span class="comment">//跳转到Here去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>标签名是大小写敏感的</p>
<h4 id="for"><a href="/2017/07/19/GO编程学习二-流程与函数/#for" class="headerlink" title="for"></a>for</h4><p>Go的语法如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> expression1; expression2; expression3 &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看看下面的例子吧：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sum := <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> index:=<span class="number">0</span>; index &lt; <span class="number">10</span> ; index++ &#123;</span><br><span class="line">        sum += index</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"sum is equal to "</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：sum is equal to 45</span></span><br></pre></td></tr></table></figure></p>
<p>有些时候忽略expression1和expression3：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ; sum &lt; <span class="number">1000</span>; &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其中;也可以省略</span><br><span class="line"></span><br><span class="line">sum := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">1000</span> &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在循环里面有两个关键操作break和continue ,break操作是跳出当前循环，continue是跳过本次循环。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>配合<span class="keyword">range</span>可以用于读取slice和<span class="keyword">map</span>的数据：</span><br><span class="line"><span class="keyword">for</span> k,v:=<span class="keyword">range</span> <span class="keyword">map</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"map's key:"</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">"map's val:"</span>,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于 Go 支持 “多值返回”, 而对于“声明而未被调用”的变量, 编译器会报错, 在这种情况下, 可以使用”_”来丢弃<br>不需要的返回值 例如<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> <span class="keyword">map</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"map's val:"</span>, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="switch"><a href="/2017/07/19/GO编程学习二-流程与函数/#switch" class="headerlink" title="switch"></a>switch</h4><p>有些时候你需要写很多的if-else来实现一些逻辑处理，这个时候代码看上去就很丑很冗长，而且也不易于以后的维<br>护，这个时候switch就能很好的解决这个问题。它的语法如下<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> sExpr &#123;</span><br><span class="line"><span class="keyword">case</span> expr1:</span><br><span class="line">    some instructions</span><br><span class="line"><span class="keyword">case</span> expr2:</span><br><span class="line">    some other instructions</span><br><span class="line"><span class="keyword">case</span> expr3:</span><br><span class="line">    some other instructions</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sExpr和expr1、expr2、expr3的类型必须一致。Go的switch非常灵活，表达式不必是常量或整数，执行的过程</p>
<h3 id="函数"><a href="/2017/07/19/GO编程学习二-流程与函数/#函数" class="headerlink" title="函数"></a>函数</h3><p>函数是Go里面的核心设计，它通过关键字func来声明，它的格式如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(input1 type1, input2 type2)</span> <span class="params">(output1 type1, output2 type2)</span></span> &#123;</span><br><span class="line"><span class="comment">//这里是处理逻辑代码</span></span><br><span class="line"><span class="comment">//返回多个值</span></span><br><span class="line">    <span class="keyword">return</span> value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码我们看出<br>关键字func用来声明一个函数funcName<br>函数可以有一个或者多个参数，每个参数后面带有类型，通过,分隔<br>函数可以返回多个值<br>上面返回值声明了两个变量output1和output2，如果你不想声明也可以，直接就两个类型<br>如果只有一个返回值且不声明返回值变量，那么你可以省略 包括返回值 的括号<br>如果没有返回值，那么就直接省略最后的返回信息<br>如果有返回值， 那么必须在函数的外层添加return语句<br>下面我们来看一个实际应用函数的例子（用来计算Max值）<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">// 返回a、b中最大值.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    z := <span class="number">5</span></span><br><span class="line">    max_xy := max(x, y) <span class="comment">//调用函数max(x, y)</span></span><br><span class="line">    max_xz := max(x, z) <span class="comment">//调用函数max(x, z)</span></span><br><span class="line">    fmt.Printf(<span class="string">"max(%d, %d) = %d\n"</span>, x, y, max_xy)</span><br><span class="line">    fmt.Printf(<span class="string">"max(%d, %d) = %d\n"</span>, x, z, max_xz)</span><br><span class="line">    fmt.Printf(<span class="string">"max(%d, %d) = %d\n"</span>, y, z, max(y,z)) <span class="comment">// 也可在这直接调用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个里面我们可以看到max函数有两个参数，它们的类型都是int，那么第一个变量的类型可以省略（即 a,b<br>int,而非 a int, b int)，默认为离它最近的类型，同理多于2个同类型的变量或者返回值。同时我们注意到它的返<br>回值就是一个类型，这个就是省略写法。</p>
<h4 id="多个返回值"><a href="/2017/07/19/GO编程学习二-流程与函数/#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h4><p>我们直接上代码看例子<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//返回 A+B 和 A*B</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> A+B, A*B</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">3</span></span><br><span class="line">    y := <span class="number">4</span></span><br><span class="line">    xPLUSy, xTIMESy := SumAndProduct(x, y)</span><br><span class="line">    fmt.Printf(<span class="string">"%d + %d = %d\n"</span>, x, y, xPLUSy)</span><br><span class="line">    fmt.Printf(<span class="string">"%d * %d = %d\n"</span>, x, y, xTIMESy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子我们可以看到直接返回了两个参数，当然我们也可以命名返回参数的变量，这个例子里面只是用了两个类<br>型，我们也可以改成如下这样的定义，然后返回的时候不用带上变量名，因为直接在函数里面初始化了。但如果你的<br>函数是导出的(首字母大写)，官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造<br>成生成的文档可读性差。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="keyword">int</span>)</span> <span class="params">(add <span class="keyword">int</span>, Multiplied <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   add = A+B</span><br><span class="line">   Multiplied = A*B</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO编程学习九-反射</title>
    <url>/2017/08/10/GO%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%B9%9D-%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h3 id="value-go中的函数"><a href="/2017/08/10/GO编程学习九-反射/#value-go中的函数" class="headerlink" title="value.go中的函数"></a>value.go中的函数</h3><p>func Append(s Value, x …Value) Value<br>func AppendSlice(s, t Value) Value<br>func Indirect(v Value) Value<br>func MakeChan(typ Type, buffer int) Value<br>func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value<br>func MakeMap(typ Type) Value<br>func MakeSlice(typ Type, len, cap int) Value<br>func New(typ Type) Value<br>func NewAt(typ Type, p unsafe.Pointer) Value<br>func ValueOf(i interface{}) Value<br>func Zero(typ Type) Value</p>
<h3 id="value结构的方法"><a href="/2017/08/10/GO编程学习九-反射/#value结构的方法" class="headerlink" title="value结构的方法"></a>value结构的方法</h3><p><strong>Addr() Value</strong><br>    通常用于获取一个指向结构体字段或slice元素为了调用一个方法,需要一个指针接收机。<br><strong>Bool() bool</strong><br>    返回底层的值,如果v的kind不是bool则会产生恐慌<br><strong>Bytes() []byte</strong><br>    返回底层的值,如果v的底层值不是一个字节切片,则会产生恐慌<br><strong>CanAddr() bool</strong><br>    检查v是否是可寻址的<br><strong>CanSet() bool</strong><br>    检查值是否可被设置,只有可寻址的才能被设置<br><strong>Call(in []Value) []Value</strong><br>    反射函数的值.并调用<br><strong>CallSlice(in []Value) []Value</strong><br>    同上<br><strong>Close()</strong><br>    关闭channel,如果不是chan则产生恐慌<br><strong>Complex() complex128</strong><br>    返回底层的值,如果值不是一个复数,则产生一个恐慌<br><strong>Elem() Value</strong><br>    返回v包含的值,多被用于设置值时的寻址操作<br><strong>Field(i int) Value</strong><br>    返回结构中索引字段的Value<br><strong>FieldByIndex(index []int) Value</strong><br>    同上不过.提供的是一个切片<br><strong>FieldByName(name string) Value</strong><br>    通过字段名查找<br><strong>FieldByNameFunc(match func(string) bool) Value</strong><br>    通过函数名查找<br><strong>Float() float64</strong><br>    返回底层的值,如果值不是一个float,则产生一个恐慌<br><strong>Index(i int) Value</strong><br>    如果kind不是array或者sliece则差生恐慌,将其中的元素返回为Value<br><strong>Int() int64</strong><br>    返回底层的值,如果值不是一个int,则产生一个恐慌<br><strong>CanInterface() bool</strong><br>    如果接口能被使用,则返回true<br><strong>Interface() (i interface{})</strong><br>    返回V作为interface{}的当前值<br><strong>InterfaceData() [2]uintptr</strong><br>    如果kind不是一个接口则会产生恐慌<br><strong>IsNil() bool</strong><br>    如果v是一个nil,则返回true<br><strong>IsValid() bool</strong><br>    如果v代表一个值,则返回true<br><strong>Kind() Kind</strong><br>    返回v的种类<br><strong>Len() int**</strong><br>    返回v的长度<br><strong>MapIndex(key Value) Value</strong><br>    如果是一个map,根据key反射其键值的Value<br><strong>MapKeys() []Value</strong><br>    返回map的所有key<br><strong>Method(i int) Value</strong><br>    按索引反射结构某个方法的值<br><strong>NumMethod() int</strong><br>    统计结构方法数量<br><strong>MethodByName(name string) Value</strong><br>    反射方法的值根据方法名<br><strong>NumField() int</strong><br>    反射一个结构的字段数<br><strong>OverflowComplex(x complex128) bool</strong><br>    覆盖复数<br><strong>OverflowFloat(x float64) bool**</strong><br>    覆盖浮点数<br><strong>overflowFloat32(x float64) bool</strong><br><strong>OverflowInt(x int64) bool</strong><br><strong>OverflowUint(x uint64) bool**</strong><br><strong>Pointer() uintptr</strong><br>    反射一个指针的值.返回一个指针的整型值<br><strong>Recv() (x Value, ok bool)</strong><br>    用于channel<br><strong>Send(x Value)</strong><br>    用于channel<br><strong>Set(x Value)</strong><br>    如果v可设置,则设置一个v的值<br><strong>SetBool(x bool)</strong><br>    如果v可设置,且是bool,则设置一个v的值<br><strong>SetBytes(x []byte)</strong><br><strong>SetComplex(x complex128)</strong><br><strong>SetFloat(x float64)</strong><br><strong>SetInt(x int64)</strong><br><strong>SetLen(n int)</strong><br><strong>SetMapIndex(key, val Value)</strong><br><strong>SetUint(x uint64)</strong><br><strong>SetPointer(x unsafe.Pointer)</strong><br><strong>SetString(x string)</strong><br><strong>Slice(beg, end int) Value</strong><br>    如果底层是slice.则返回值.<br><strong>String() string</strong><br>    如果狄成是字符窜.则返回字符窜<br><strong>TryRecv() (x Value, ok bool)</strong><br>    用于channel,接受<br><strong>TrySend(x Value) bool</strong><br>    用于channel,发送<br><strong>Type() Type</strong><br>    返回type<br><strong>Uint() uint64</strong><br>    如果狄成是Uint.则返回uint<br><strong>UnsafeAddr() uintptr</strong></p>
<h3 id="例子"><a href="/2017/08/10/GO编程学习九-反射/#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> MyStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MyStruct)</span> <span class="title">GetName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> this.name</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> IStruct <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetName() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// TypeOf</span></span><br><span class="line">    s := <span class="string">"this is string"</span></span><br><span class="line">    fmt.Println(reflect.TypeOf(s)) <span class="comment">// output: "string"</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// object TypeOf</span></span><br><span class="line">    a := <span class="built_in">new</span>(MyStruct)</span><br><span class="line">    a.name = <span class="string">"yejianfeng"</span></span><br><span class="line">    typ := reflect.TypeOf(a)</span><br><span class="line">    fmt.Println(typ)        <span class="comment">// output: "*main.MyStruct"</span></span><br><span class="line">    fmt.Println(typ.Elem()) <span class="comment">// output: "main.MyStruct"</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// reflect.Type Base struct</span></span><br><span class="line">    fmt.Println(typ.NumMethod())                   <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(typ.Method(<span class="number">0</span>))                     <span class="comment">// &#123;GetName  func(*main.MyStruct) string &lt;func(*main.MyStruct) string Value&gt; 0&#125;</span></span><br><span class="line">    fmt.Println(typ.Name())                        <span class="comment">// ""</span></span><br><span class="line">    fmt.Println(typ.PkgPath())                     <span class="comment">// ""</span></span><br><span class="line">    fmt.Println(typ.Size())                        <span class="comment">// 8</span></span><br><span class="line">    fmt.Println(typ.String())                      <span class="comment">// *main.MyStruct</span></span><br><span class="line">    fmt.Println(typ.Elem().String())               <span class="comment">// main.MyStruct</span></span><br><span class="line">    fmt.Println(typ.Elem().FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;)) <span class="comment">// &#123;name main string  0 [0] false&#125;</span></span><br><span class="line">    fmt.Println(typ.Elem().FieldByName(<span class="string">"name"</span>))    <span class="comment">// &#123;name main string  0 [0] false&#125; true</span></span><br><span class="line"> </span><br><span class="line">    fmt.Println(typ.Kind() == reflect.Ptr)                              <span class="comment">// true</span></span><br><span class="line">    fmt.Println(typ.Elem().Kind() == reflect.Struct)                    <span class="comment">// true</span></span><br><span class="line">    fmt.Println(typ.Implements(reflect.TypeOf((*IStruct)(<span class="literal">nil</span>)).Elem())) <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line">    fmt.Println(reflect.TypeOf(<span class="number">12.12</span>).Bits()) <span class="comment">// 64, 因为是float64</span></span><br><span class="line"> </span><br><span class="line">    cha := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    fmt.Println(reflect.TypeOf(cha).ChanDir()) <span class="comment">// chan</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> fun <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>, y ...<span class="keyword">float64</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function">    <span class="title">var</span> <span class="title">fun2</span> <span class="title">func</span><span class="params">(x <span class="keyword">int</span>, y <span class="keyword">float64</span>)</span> <span class="title">string</span></span></span><br><span class="line"><span class="function">    <span class="title">fmt</span>.<span class="title">Println</span><span class="params">(reflect.TypeOf(fun)</span>.<span class="title">IsVariadic</span><span class="params">()</span>)  // <span class="title">true</span></span></span><br><span class="line"><span class="function">    <span class="title">fmt</span>.<span class="title">Println</span><span class="params">(reflect.TypeOf(fun2)</span>.<span class="title">IsVariadic</span><span class="params">()</span>) // <span class="title">false</span></span></span><br><span class="line"><span class="function">    <span class="title">fmt</span>.<span class="title">Println</span><span class="params">(reflect.TypeOf(fun)</span>.<span class="title">In</span><span class="params">(0)</span>)         // <span class="title">int</span></span></span><br><span class="line"><span class="function">    <span class="title">fmt</span>.<span class="title">Println</span><span class="params">(reflect.TypeOf(fun)</span>.<span class="title">In</span><span class="params">(1)</span>)         // []<span class="title">float64</span></span></span><br><span class="line"><span class="function">    <span class="title">fmt</span>.<span class="title">Println</span><span class="params">(reflect.TypeOf(fun)</span>.<span class="title">NumIn</span><span class="params">()</span>)       // 2</span></span><br><span class="line"><span class="function">    <span class="title">fmt</span>.<span class="title">Println</span><span class="params">(reflect.TypeOf(fun)</span>.<span class="title">NumOut</span><span class="params">()</span>)      // 1</span></span><br><span class="line"><span class="function">    <span class="title">fmt</span>.<span class="title">Println</span><span class="params">(reflect.TypeOf(fun)</span>.<span class="title">Out</span><span class="params">(0)</span>)        // <span class="title">string</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    <span class="title">mp</span> := <span class="title">make</span><span class="params">(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    <span class="title">mp</span>["<span class="title">test1</span>"] = 1</span></span><br><span class="line"><span class="function">    <span class="title">fmt</span>.<span class="title">Println</span><span class="params">(reflect.TypeOf(mp)</span>.<span class="title">Key</span><span class="params">()</span>) //<span class="title">string</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    <span class="title">arr</span> := [1]<span class="title">string</span></span>&#123;<span class="string">"test"</span>&#125;</span><br><span class="line">    fmt.Println(reflect.TypeOf(arr).Len()) <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line">    fmt.Println(typ.Elem().NumField()) <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// MethodByName, Call</span></span><br><span class="line">    b := reflect.ValueOf(a).MethodByName(<span class="string">"GetName"</span>).Call([]reflect.Value&#123;&#125;)</span><br><span class="line">    fmt.Println(b[<span class="number">0</span>]) <span class="comment">// output: "yejianfeng"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   b := <span class="number">555</span></span><br><span class="line">   p:=reflect.ValueOf(&amp;b)</span><br><span class="line">v := p.Elem()  <span class="comment">//反射对象 p并不是可寻址的，但是并不希望设置p，（实际上）是 *p。为了获得 p 指向的内容，调用值上的 Elem 方法，从指针间接指向，然后保存反射值的结果叫做 v</span></span><br><span class="line">v.SetInt(<span class="number">666</span>)</span><br><span class="line">fmt.Println(b)</span><br><span class="line">   ------------------------------------</span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(a <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="string">"sssssss"</span></span><br><span class="line">	args := []reflect.Value&#123;reflect.ValueOf(a)&#125;</span><br><span class="line">	c := reflect.ValueOf(test).Call(args)</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line">   ------------------------------------</span><br><span class="line">   <span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">	a <span class="keyword">int</span></span><br><span class="line">	b <span class="keyword">byte</span></span><br><span class="line">	c <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := A&#123;&#125;</span><br><span class="line">	fmt.Println(reflect.ValueOf(a).Field(<span class="number">0</span>).Int())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> a <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this a)</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"test ok."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *a)</span> <span class="title">Get</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"get ok."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *a)</span> <span class="title">Print</span><span class="params">(id <span class="keyword">int</span>, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"id is "</span>, id)</span><br><span class="line">	fmt.Println(<span class="string">"name is "</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"func test is ok."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d := &amp;a&#123;Name: <span class="string">"aaa"</span>, Age: <span class="string">"bbb"</span>&#125;</span><br><span class="line">	v := reflect.ValueOf(d)</span><br><span class="line">	ele := v.Elem()</span><br><span class="line">	t := ele.Type()</span><br><span class="line">	fmt.Println(<span class="string">"\n读取对象的所有属性"</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">		fmt.Println(t.Field(i).Name, ele.Field(i).Interface())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"\n读取对象的所有方法"</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumMethod(); i++ &#123;</span><br><span class="line">		fmt.Println(t.Method(i).Name)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//反射调用方法</span></span><br><span class="line">	fmt.Println(<span class="string">"\n测试函数调用，看来还是e保险一些，不会出错"</span>)</span><br><span class="line">	v.MethodByName(<span class="string">"Get"</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">	v.MethodByName(<span class="string">"Test"</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">//使用ele.MethodByName("GET").Call(nil)会抛出异常</span></span><br><span class="line">	<span class="comment">//但是使用ele.MethodByName("Test").Call(nil)却是正常？因为Test没有用指针</span></span><br><span class="line">	ele.MethodByName(<span class="string">"Test"</span>).Call(<span class="literal">nil</span>)</span><br><span class="line">	<span class="comment">//调用有参数的反射</span></span><br><span class="line">	fmt.Println(<span class="string">"\n测试传值调用函数"</span>)</span><br><span class="line">	vId := reflect.ValueOf(<span class="number">88</span>)</span><br><span class="line">	vName := reflect.ValueOf(<span class="string">"小汪"</span>)</span><br><span class="line">	v.MethodByName(<span class="string">"Print"</span>).Call([]reflect.Value&#123;vId, vName&#125;)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"\n测试参数赋值，必须要用ele"</span>)</span><br><span class="line">	ele.FieldByName(<span class="string">"Name"</span>).SetString(<span class="string">"哈哈"</span>)</span><br><span class="line">	fmt.Println(d)</span><br><span class="line"></span><br><span class="line">	c := <span class="number">123</span></span><br><span class="line">	tc := reflect.ValueOf(&amp;c).Elem()</span><br><span class="line">	tc.SetInt(<span class="number">333</span>)</span><br><span class="line">	fmt.Println(tc, reflect.TypeOf(&amp;c).Elem().Name())</span><br><span class="line">	fmt.Println(c)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO编程学习五-interface</title>
    <url>/2017/07/19/GO%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E4%BA%94-interface/</url>
    <content><![CDATA[<h2 id="什么是interface"><a href="/2017/07/19/GO编程学习五-interface/#什么是interface" class="headerlink" title="什么是interface"></a>什么是interface</h2><p>简单的说，interface是一组method的组合，我们通过interface来定义对象的一组行为。<br>我们前面一章最后一个例子中Student和Employee都能Sayhi，虽然他们的内部实现不一样，但是那不重要，重要的是<br>他们都能say hi</p>
<h3 id="interface类型"><a href="/2017/07/19/GO编程学习五-interface/#interface类型" class="headerlink" title="interface类型"></a>interface类型</h3><p>interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口。详细的语法<br>参考下面这个例子<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    school <span class="keyword">string</span></span><br><span class="line">    loan <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段Human</span></span><br><span class="line">    company <span class="keyword">string</span></span><br><span class="line">    money <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human对象实现Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Human对象实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">Sing</span><span class="params">(lyrics <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"La la, la la la, la la la la la..."</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human对象实现Guzzle方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">Guzzle</span><span class="params">(beerStein <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Guzzle Guzzle Guzzle..."</span>, beerStein)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Employee重载Human的Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s, I work at %s. Call me on %s\n"</span>, e.name,e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student实现BorrowMoney方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Student)</span> <span class="title">BorrowMoney</span><span class="params">(amount <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">    s.loan += amount <span class="comment">// (again and again and...)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee实现SpendSalary方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SpendSalary</span><span class="params">(amount <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">    e.money -= amount <span class="comment">// More vodka please!!! Get me through the day!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义interface</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="keyword">string</span>)</span><br><span class="line">    Guzzle(beerStein <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> YoungChap <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="keyword">string</span>)</span><br><span class="line">    BorrowMoney(amount <span class="keyword">float32</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ElderlyGent <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(song <span class="keyword">string</span>)</span><br><span class="line">    SpendSalary(amount <span class="keyword">float32</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码我们可以知道，interface可以被任意的对象实现。我们看到上面的Men interface被Human、Student<br>和Employee实现。同理，一个对象可以实现任意多个interface，例如上面的Student实现了Men和YonggChap两个<br>interface。</p>
<h3 id="interface值"><a href="/2017/07/19/GO编程学习五-interface/#interface值" class="headerlink" title="interface值"></a>interface值</h3><p>那么interface里面到底能存什么值呢？如果我们定义了一个interface的变量，那么这个变量里面可以存实现这个<br>interface的任意类型的对象。例如上面例子中，我们定义了一个Men interface类型的变量m，那么m里面可以存<br>Human、Student或者Employee值。<br>因为m能够持有这三种类型的对象，所以我们可以定义一个包含Men类型元素的slice，这个slice可以被赋予实现了<br>Men接口的任意结构的对象，这个和我们传统意义上面的slice有所不同。<br>让我们来看一下下面这个例子<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="keyword">string</span></span><br><span class="line">    loan <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="keyword">string</span></span><br><span class="line">    money <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human实现Sayhi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human实现Sing方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span> <span class="title">Sing</span><span class="params">(lyrics <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"La la la la..."</span>, lyrics)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee重载Human的SayHi方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s, I work at %s. Call me on %s\n"</span>, e.name,e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Interface Men被Human,Student和Employee实现</span></span><br><span class="line"><span class="comment">// 因为这三个类型都实现了这两个方法</span></span><br><span class="line"><span class="keyword">type</span> Men <span class="keyword">interface</span> &#123;</span><br><span class="line">    SayHi()</span><br><span class="line">    Sing(lyrics <span class="keyword">string</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mike := Student&#123;Human&#123;<span class="string">"Mike"</span>, <span class="number">25</span>, <span class="string">"222-222-XXX"</span>&#125;, <span class="string">"MIT"</span>, <span class="number">0.00</span>&#125;</span><br><span class="line">    paul := Student&#123;Human&#123;<span class="string">"Paul"</span>, <span class="number">26</span>, <span class="string">"111-222-XXX"</span>&#125;, <span class="string">"Harvard"</span>, <span class="number">100</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">"Sam"</span>, <span class="number">36</span>, <span class="string">"444-222-XXX"</span>&#125;, <span class="string">"Golang Inc."</span>, <span class="number">1000</span>&#125;</span><br><span class="line">    Tom := Employee&#123;Human&#123;<span class="string">"Sam"</span>, <span class="number">36</span>, <span class="string">"444-222-XXX"</span>&#125;, <span class="string">"Things Ltd."</span>, <span class="number">5000</span>&#125;</span><br><span class="line"><span class="comment">//定义Men类型的变量i</span></span><br><span class="line">    <span class="keyword">var</span> i Men</span><br><span class="line"><span class="comment">//i能存储Student</span></span><br><span class="line">    i = mike</span><br><span class="line">    fmt.Println(<span class="string">"This is Mike, a Student:"</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">"November rain"</span>)</span><br><span class="line"><span class="comment">//i也能存储Employee</span></span><br><span class="line">    i = Tom</span><br><span class="line">    fmt.Println(<span class="string">"This is Tom, an Employee:"</span>)</span><br><span class="line">    i.SayHi()</span><br><span class="line">    i.Sing(<span class="string">"Born to be wild"</span>)</span><br><span class="line"><span class="comment">//定义了slice Men</span></span><br><span class="line">    fmt.Println(<span class="string">"Let's use a slice of Men and see what happens"</span>)</span><br><span class="line">    x := <span class="built_in">make</span>([]Men, <span class="number">3</span>)</span><br><span class="line"><span class="comment">//T这三个都是不同类型的元素，但是他们实现了interface同一个接口</span></span><br><span class="line">    x[<span class="number">0</span>], x[<span class="number">1</span>], x[<span class="number">2</span>] = paul, sam, mike</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> x&#123;</span><br><span class="line">    value.SayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码，你会发现interface就是一组抽象方法的集合，它必须由其他非interface类型实现，而不能自我实<br>现， go 通过interface实现了duck-typing:即”当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那<br>么这只鸟就可以被称为鸭子”。</p>
<h3 id="空interface"><a href="/2017/07/19/GO编程学习五-interface/#空interface" class="headerlink" title="空interface"></a>空interface</h3><p>空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于<br>描述起不到任何的作用(因为它不包含任何的method），但是空interface在我们需要存储任意类型的数值的时候相当<br>有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。<br>// 定义a为空接口<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">s := <span class="string">"Hello world"</span></span><br><span class="line"><span class="comment">// a可以存储任意类型的数值</span></span><br><span class="line">a = i</span><br><span class="line">a = s</span><br></pre></td></tr></table></figure></p>
<p>一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也<br>就可以返回任意类型的值。是不是很有用啊！</p>
<h3 id="interface函数参数"><a href="/2017/07/19/GO编程学习五-interface/#interface函数参数" class="headerlink" title="interface函数参数"></a>interface函数参数</h3><p>interface的变量可以持有任意实现该interface类型的对象，这给我们编写函数(包括method)提供了一些额外的思<br>考，我们是不是可以通过定义interface参数，让函数接受各种类型的参数。<br>74<br>举个例子：fmt.Println是我们常用的一个函数，但是你是否注意到它可以接受任意类型的数据。打开fmt的源码文<br>件，你会看到这样一个定义:<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">    String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">也就是说，任何实现了String方法的类型都能作为参数被fmt.Println调用,让我们来试一试</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过这个方法 Human 实现了 fmt.Stringer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Human)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"􀀀"</span>+h.name+<span class="string">" - "</span>+strconv.Itoa(h.age)+<span class="string">" years - ✆ "</span> +h.phone+<span class="string">"􀀀"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Bob := Human&#123;<span class="string">"Bob"</span>, <span class="number">39</span>, <span class="string">"000-7777-XXX"</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"This Human is : "</span>, Bob)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在我们再回顾一下前面的Box示例，你会发现Color结构也定义了一个method：String。其实这也是实现了<br>fmt.Stringer这个interface，即如果需要某个类型能被fmt包以特殊的格式输出，你就必须实现Stringer这个接口。<br>如果没有实现这个接口，fmt将以默认的方式输出。<br>//实现同样的功能<br>fmt.Println(“The biggest one is”, boxes.BiggestsColor().String())<br>fmt.Println(“The biggest one is”, boxes.BiggestsColor())<br>注：实现了error接口的对象（即实现了Error() string的对象），使用fmt输出时，会调用Error()方法，因此不必<br>再定义String()方法了。</p>
<h3 id="嵌入interface"><a href="/2017/07/19/GO编程学习五-interface/#嵌入interface" class="headerlink" title="嵌入interface"></a>嵌入interface</h3><p>Go里面真正吸引人的是他内置的逻辑语法，就像我们在学习Struct时学习的匿名字段，多么的优雅啊，那么相同的逻<br>辑引入到interface里面，那不是更加完美了。如果一个interface1作为interface2的一个嵌入字段，那么<br>interface2隐式的包含了interface1里面的method。<br>我们可以看到源码包container/heap里面有这样的一个定义<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface <span class="comment">//嵌入字段sort.Interface</span></span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">//a Push method to push elements into the heap</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125; <span class="comment">//a Pop elements that pops elements from the heap</span></span><br><span class="line">&#125;</span><br><span class="line">我们看到sort.Interface其实就是嵌入字段，把sort.Interface的所有method给隐式的包含进来了。也就是下面三个</span><br><span class="line">方法</span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">    Len() <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// Less returns whether the element with index i should sort</span></span><br><span class="line">    <span class="comment">// before the element with index j.</span></span><br><span class="line">    Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">    Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br><span class="line">另一个例子就是io包下面的 io.ReadWriter ，他包含了io包下面的Reader和Writer两个<span class="keyword">interface</span>。</span><br><span class="line"><span class="comment">// io.ReadWriter</span></span><br><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO编程学习八-使用MySQL数据库</title>
    <url>/2017/07/23/GO%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E5%85%AB-%E4%BD%BF%E7%94%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h2 id="使用MySQL数据库"><a href="/2017/07/23/GO编程学习八-使用MySQL数据库/#使用MySQL数据库" class="headerlink" title="使用MySQL数据库"></a>使用MySQL数据库</h2><p>目前Internet上流行的网站构架方式是LAMP，其中的M即MySQL, 作为数据库，MySQL以免费、开源、使用方便为优势<br>成为了很多Web开发的后端数据库存储引擎。</p>
<h3 id="MySQL驱动"><a href="/2017/07/23/GO编程学习八-使用MySQL数据库/#MySQL驱动" class="headerlink" title="MySQL驱动"></a>MySQL驱动</h3><p>Go中支持MySQL的驱动目前比较多，有如下几种，有些是支持database/sql标准，而有些是采用了自己的实现接口,常<br>用的有如下几种:<br><a href="https://github.com/Go-SQL-Driver/MySQL" target="_blank" rel="noopener">https://github.com/Go-SQL-Driver/MySQL</a> 支持database/sql，全部采用go写。<br><a href="https://github.com/ziutek/mymysql" target="_blank" rel="noopener">https://github.com/ziutek/mymysql</a> 支持database/sql，也支持自定义的接口，全部采用go写。<br><a href="https://github.com/Philio/GoMySQL" target="_blank" rel="noopener">https://github.com/Philio/GoMySQL</a> 不支持database/sql，自定义接口，全部采用go写。<br>接下来的例子我主要以第一个驱动为例(我目前项目中也是采用它来驱动)，也推荐大家采用它，主要理由：<br>这个驱动比较新，维护的比较好<br>完全支持database/sql接口<br>支持keepalive，保持长连接,虽然星星fork的mymysql也支持keepalive，但不是线程安全的，这个从底层就<br>支持了keepalive。<br>示例代码<br>接下来的几个小节里面我们都将采用同一个数据库表结构：数据库test，用户表userinfo，关联用户信息表<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">userdetail。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`userinfo`</span> (</span><br><span class="line"><span class="string">`uid`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line"><span class="string">`username`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`departname`</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`created`</span> <span class="built_in">DATE</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`uid`</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`userdetail`</span> (</span><br><span class="line"><span class="string">`uid`</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span>,</span><br><span class="line"><span class="string">`intro`</span> <span class="built_in">TEXT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`profile`</span> <span class="built_in">TEXT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="string">`uid`</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>如下示例将示范如何使用database/sql接口对数据库表进行增删改查操作<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    _ <span class="string">"github.com/Go-SQL-Driver/MySQL"</span></span><br><span class="line">        <span class="string">"database/sql"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//"time"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    db, err := sql.Open(<span class="string">"mysql"</span>, <span class="string">"astaxie:astaxie@/test?charset=utf8"</span>)</span><br><span class="line">    checkErr(err)</span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">    stmt, err := db.Prepare(<span class="string">"INSERT userinfo SET                     username=?,departname=?,created=?"</span>)</span><br><span class="line">    checkErr(err)</span><br><span class="line">    res, err := stmt.Exec(<span class="string">"astaxie"</span>, <span class="string">"研发部门"</span>, <span class="string">"2012-12-09"</span>)</span><br><span class="line">    checkErr(err)</span><br><span class="line">    id, err := res.LastInsertId()</span><br><span class="line">    checkErr(err)</span><br><span class="line">    fmt.Println(id)</span><br><span class="line">    <span class="comment">//更新数据</span></span><br><span class="line">    stmt, err = db.Prepare(<span class="string">"update userinfo set username=? where uid=?"</span>)</span><br><span class="line"></span><br><span class="line">    checkErr(err)</span><br><span class="line">    res, err = stmt.Exec(<span class="string">"astaxieupdate"</span>, id)</span><br><span class="line">    checkErr(err)</span><br><span class="line">    affect, err := res.RowsAffected()</span><br><span class="line">    checkErr(err)</span><br><span class="line">    fmt.Println(affect)</span><br><span class="line">    <span class="comment">//查询数据</span></span><br><span class="line">    rows, err := db.Query(<span class="string">"SELECT * FROM userinfo"</span>)</span><br><span class="line">    checkErr(err)</span><br><span class="line">    <span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        <span class="keyword">var</span> uid <span class="keyword">int</span></span><br><span class="line">        <span class="keyword">var</span> username <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">var</span> department <span class="keyword">string</span></span><br><span class="line">        <span class="keyword">var</span> created <span class="keyword">string</span></span><br><span class="line">        err = rows.Scan(&amp;uid, &amp;username, &amp;department, &amp;created)</span><br><span class="line">        checkErr(err)</span><br><span class="line">        fmt.Println(uid)</span><br><span class="line">        fmt.Println(username)</span><br><span class="line">        fmt.Println(department)</span><br><span class="line">        fmt.Println(created)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除数据</span></span><br><span class="line">    stmt, err = db.Prepare(<span class="string">"delete from userinfo where uid=?"</span>)</span><br><span class="line">    checkErr(err)</span><br><span class="line">    res, err = stmt.Exec(id)</span><br><span class="line">    checkErr(err)</span><br><span class="line">    affect, err = res.RowsAffected()</span><br><span class="line">    checkErr(err)</span><br><span class="line">    fmt.Println(affect)</span><br><span class="line">    db.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkErr</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过上面的代码我们可以看出，Go操作Mysql数据库是很方便的。<br>关键的几个函数我解释一下：<br>sql.Open()函数用来打开一个注册过的数据库驱动，Go-MySQL-Driver中注册了mysql这个数据库驱动，第二个参数是<br>DNS(Data Source Name)，它是Go-MySQL-Driver定义的一些数据库链接和配置信息。它支持如下格式：<br>user@unix(/path/to/socket)/dbname?charset=utf8<br>user:password@tcp(localhost:5555)/dbname?charset=utf8<br>user:password@/dbname<br>user:password@tcp([de:ad:be:ef::ca:fe]:80)/dbname</p>
<ul>
<li>db.Prepare()函数用来返回准备要执行的sql操作，然后返回准备完毕的执行状态。</li>
<li>db.Query()函数用来直接执行Sql返回Rows结果。</li>
<li>stmt.Exec()函数用来执行stmt准备好的SQL语句</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>GO编程学习六-并发</title>
    <url>/2017/07/22/GO%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E5%85%AD-%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h2 id="并发"><a href="/2017/07/22/GO编程学习六-并发/#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="goroutine"><a href="/2017/07/22/GO编程学习六-并发/#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>goroutine是Go并行设计的核心。goroutine说到底其实就是线程，但是他比线程更小，十几个goroutine可能体现在<br>底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大<br>概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更<br>易用、更高效、更轻便。<br>goroutine是通过Go的runtime管理的一个线程管理器。goroutine通过go关键字实现了，其实就是一个普通的函数。<br>go hello(a, b, c)<br>通过关键字go就启动了一个goroutine。我们来看一个例子<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">say</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        runtime.Gosched()</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> say(<span class="string">"world"</span>) <span class="comment">//开一个新的Goroutines执行</span></span><br><span class="line">    say(<span class="string">"hello"</span>) <span class="comment">//当前Goroutines执行</span></span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到go关键字很方便的就实现了并发编程。 上面的多个goroutine运行在同一个进程里面，共享内存数据，<br>不过设计上我们要遵循：不要通过共享来通信，而要通过通信来共享。</p>
<ul>
<li>runtime.Gosched()表示让CPU把时间片让给别人,下次某个时候继续恢复执行该goroutine。</li>
</ul>
<p>默认情况下，调度器仅使用单线程，也就是说只实现了并发。想要发挥多核处理器的并行，需要在我们的程序中显<br>示的调用 runtime.GOMAXPROCS(n) 告诉调度器同时使用多个线程。GOMAXPROCS 设置了同时运行逻辑代码的系统线<br>程的最大数量，并返回之前的设置。如果n &lt; 1，不会改变当前设置</p>
<h3 id="channels"><a href="/2017/07/22/GO编程学习六-并发/#channels" class="headerlink" title="channels"></a>channels</h3><p>goroutine运行在相同的地址空间，因此访问共享内存必须做好同步。那么goroutine之间如何进行数据的通信呢，Go<br>提供了一个很好的通信机制channel。channel可以与Unix shell 中的双向管道做类比：可以通过它发送或者接收<br>值。这些值只能是特定的类型：channel类型。定义一个channel时，也需要定义发送到channel的值的类型。注意，<br>必须使用make 创建channel：<br>ci := make(chan int)<br>cs := make(chan string)<br>79<br>cf := make(chan interface{})<br>channel通过操作符&lt;-来接收和发送数据<br>ch &lt;- v // 发送v到channel ch.<br>v := &lt;-ch // 从ch中接收数据，并赋值给v<br>我们把这些应用到我们的例子中来：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a []<span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123;</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    c &lt;- sum <span class="comment">// send sum to c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">4</span>, <span class="number">0</span>&#125;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sum(a[:<span class="built_in">len</span>(a)/<span class="number">2</span>], c)</span><br><span class="line">    <span class="keyword">go</span> sum(a[<span class="built_in">len</span>(a)/<span class="number">2</span>:], c)</span><br><span class="line">    x, y := &lt;-c, &lt;-c <span class="comment">// receive from c</span></span><br><span class="line">    fmt.Println(x, y, x + y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，channel接收和发送数据都是阻塞的，除非另一端已经准备好，这样就使得Goroutines同步变的更加的<br>简单，而不需要显式的lock。所谓阻塞，也就是如果读取（value := &lt;-ch）它将会被阻塞，直到有数据接收。其<br>次，任何发送（ch&lt;-5）将会被阻塞，直到数据被读出。无缓冲channel是在多个goroutine之间同步很棒的工具。</p>
<h3 id="Buffered-Channels"><a href="/2017/07/22/GO编程学习六-并发/#Buffered-Channels" class="headerlink" title="Buffered Channels"></a>Buffered Channels</h3><p>上面我们介绍了默认的非缓存类型的channel，不过Go也允许指定channel的缓冲大小，很简单，就是channel可以存<br>储多少元素。ch:= make(chan bool, 4)，创建了可以存储4个元素的bool 型channel。在这个channel 中，前4个元<br>素可以无阻塞的写入。当写入第5个元素时，代码将会阻塞，直到其他goroutine从channel 中读取一些元素，腾出空<br>间。<br>ch := make(chan type, value)<br>value == 0 ! 无缓冲（阻塞）<br>value &gt; 0 ! 缓冲（非阻塞，直到value 个元素）<br>我们看一下下面这个例子，你可以在自己本机测试一下，修改相应的value值<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)<span class="comment">//修改2为1就报错，修改2为3可以正常运行</span></span><br><span class="line">    c &lt;- <span class="number">1</span></span><br><span class="line">    c &lt;- <span class="number">2</span></span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">    fmt.Println(&lt;-c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Range和Close"><a href="/2017/07/22/GO编程学习六-并发/#Range和Close" class="headerlink" title="Range和Close"></a>Range和Close</h3><p>上面这个例子中，我们需要读取两次c，这样不是很方便，Go考虑到了这一点，所以也可以通过range，像操作slice<br>或者map一样操作缓存类型的channel，请看下面的例子<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        c &lt;- x</span><br><span class="line">        x, y = y, x + y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>for i := range c能够不断的读取channel里面的数据，直到该channel被显式的关闭。上面代码我们看到可以显<br>式的关闭channel，生产者通过关键字close函数关闭channel。关闭channel之后就无法再发送任何数据了，在消费<br>方可以通过语法v, ok := &lt;-ch测试channel是否被关闭。如果ok返回false，那么说明channel已经没有任何数据<br>并且已经被关闭。<br>记住应该在生产者的地方关闭channel，而不是消费的地方去关闭它，这样容易引起panic<br>另外记住一点的就是channel不像文件之类的，不需要经常去关闭，只有当你确实没有任何发送数据了，或者你想显<br>式的结束range循环之类的</p>
<h3 id="Select"><a href="/2017/07/22/GO编程学习六-并发/#Select" class="headerlink" title="Select"></a>Select</h3><p>我们上面介绍的都是只有一个channel的情况，那么如果存在多个channel的时候，我们该如何操作呢，Go里面提供了<br>一个关键字select，通过select可以监听channel上的数据流动。<br>select默认是阻塞的，只有当监听的channel中有发送或接收可以进行时才会运行，当多个channel都准备好的时<br>候，select是随机的选择一个执行的。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">                x, y = y, x + y</span><br><span class="line">            <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">                fmt.Println(<span class="string">"quit"</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            fmt.Println(&lt;-c)</span><br><span class="line">        &#125;</span><br><span class="line">        quit &lt;- <span class="number">0</span></span><br><span class="line">    &#125;()</span><br><span class="line">    fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在select里面还有default语法，select其实就是类似switch的功能，default就是当监听的channel都没有准备好<br>的时候，默认执行的（select不再阻塞等待channel）。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> i := &lt;-c:</span><br><span class="line">        <span class="comment">// use i</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 当c阻塞的时候执行这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="超时"><a href="/2017/07/22/GO编程学习六-并发/#超时" class="headerlink" title="超时"></a>超时</h3><p>有时候会出现goroutine阻塞的情况，那么我们如何避免整个的程序进入阻塞的情况呢？我们可以利用select来设置<br>超时，通过如下的方式实现：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    o := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> v := &lt;- c:</span><br><span class="line">                <span class="built_in">println</span>(v)</span><br><span class="line">            <span class="keyword">case</span> &lt;- time.After(<span class="number">5</span> * time.Second):</span><br><span class="line">                <span class="built_in">println</span>(<span class="string">"timeout"</span>)</span><br><span class="line">                o &lt;- <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;- o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="runtime-goroutine"><a href="/2017/07/22/GO编程学习六-并发/#runtime-goroutine" class="headerlink" title="runtime goroutine"></a>runtime goroutine</h3><p>runtime包中有几个处理goroutine的函数：</p>
<ul>
<li>Goexit<br>退出当前执行的goroutine，但是defer函数还会继续调用</li>
<li>Gosched<br>让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行。</li>
<li>NumCPU<br>返回 CPU 核数量</li>
<li>NumGoroutine<br>返回正在执..行和排队的任务总数</li>
<li>GOMAXPROCS<br>用来设置可以运行的CPU核数</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase建表例子</title>
    <url>/2018/03/27/Hbase%E5%BB%BA%E8%A1%A8%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<p>HBase 是一个NoSQL数据库，用于处理海量数据，可以支持10亿行百万列的大表，下面就了解一下数据是如何存放在HBase表中的</p>
<h3 id="关系型数据库的表结构"><a href="/2018/03/27/Hbase建表例子/#关系型数据库的表结构" class="headerlink" title="关系型数据库的表结构"></a>关系型数据库的表结构</h3><p>为了更好的理解HBase表的思路，先回顾一下关系数据库中表的处理方式</p>
<p>例如有一个用户表user_info，有字段：id、name、tel，表名和字段需要在建表时指定<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table user_info (</span><br><span class="line"></span><br><span class="line">  id 类型,</span><br><span class="line"></span><br><span class="line">  name 类型,</span><br><span class="line"></span><br><span class="line">  tel 类型</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>然后插入两条数据</p>
<p>insert into user_info values(…)</p>
<p>表结构</p>
<table class="c2" border="0" cellspacing="0" cellpadding="0"><thead><tr><td><p class="c1"><strong>id</strong></p></td><td><p class="c1"><strong>name</strong></p></td><td><p class="c1"><strong>tel</strong></p></td></tr></thead><tbody><tr><td><p class="c1">1</p></td><td><p class="c1">小明</p></td><td><p class="c1">123</p></td></tr><tr><td><p class="c1">2</p></td><td><p class="c1">小王</p></td><td><p class="c1">456</p></td></tr></tbody></table>

<p>后来字段不够用了，新用户需要记录地址，就要新增一个字段</p>
<table class="c2" border="0" cellspacing="0" cellpadding="0"><thead><tr><td><p class="c1"><strong>id</strong></p></td><td><p class="c1"><strong>name</strong></p></td><td><p class="c1"><strong>tel</strong></p></td><td><p class="c1"><strong>addr</strong></p></td></tr></thead><tbody><tr><td><p class="c1">1</p></td><td><p class="c1">小明</p></td><td><p class="c1">123</p></td><td>&nbsp;</td></tr><tr><td><p class="c1">2</p></td><td><p class="c1">小王</p></td><td><p class="c1">456</p></td><td>&nbsp;</td></tr></tbody></table>

<p>以后再增加需求时，就继续新增字段，或者添加一个扩展表</p>
<p>上面的内容主要说明的是：</p>
<ul>
<li>建表的方式，需提前指定表名和字段</li>
<li>插入记录的方式，指定表名和各字段的值</li>
<li>数据表是二维结构，行和列</li>
<li>添加字段不灵活</li>
</ul>
<p>下面看一下HBase的处理方式</p>
<h3 id="HBase的表结构"><a href="/2018/03/27/Hbase建表例子/#HBase的表结构" class="headerlink" title="HBase的表结构"></a>HBase的表结构</h3><p>建表时要指定的是：表名、列族</p>
<p>建表语句</p>
<p>create ‘user_info’, ‘base_info’, ‘ext_info’</p>
<p>意思是新建一个表，名称是user_info，包含两个列族base_info和ext_info</p>
<p>列族 是列的集合，一个列族中包含多个列</p>
<p>这时的表结构：</p>
<table class="c2" border="0" cellspacing="0" cellpadding="0"><thead><tr><td><p class="c1"><strong>row key</strong></p></td><td><p class="c1"><strong>base_info</strong></p></td><td><p class="c1"><strong>ext_info</strong></p></td></tr></thead><tbody><tr><td><p class="c1">…</p></td><td><p class="c1">…</p></td><td><p class="c1">…</p></td></tr></tbody></table>

<p><strong>row key</strong> 是行键，每一行的ID，这个字段是自动创建的，建表时不需要指定</p>
<p>插入一条用户数据：name为‘a’，tel为‘123’</p>
<p>插入语句</p>
<p>put ‘user_info’, ‘row1’, ‘base_info:name’, ‘a’</p>
<p>put ‘user_info’, ‘row1’, ‘base_info:tel’, ‘123’</p>
<p>意思是向user_info表中行健为row1的base_info列族中添加一项数据 name:a，接着又添加一项数据tel:123</p>
<p>name和tel就是具体字段，属于base_info这个列族</p>
<p>这时的表结构：</p>
<table class="c2" border="0" cellspacing="0" cellpadding="0"><thead><tr><td><p class="c1"><strong>row key</strong></p></td><td><p class="c1"><strong>base_info</strong></p></td><td><p class="c1"><strong>ext_info</strong></p></td></tr></thead><tbody><tr><td><p class="c1">row1</p></td><td><p class="c1">name:a, tel:123</p></td><td>&nbsp;</td></tr></tbody></table>

<p>再插入一条数据：name为‘b’，addr为‘beijing’</p>
<p>put ‘user_info’, ‘row2’, ‘base_info:name’, ‘b’</p>
<p>put ‘user_info’, ‘row2’, ‘ext_info:addr’, ‘bj’</p>
<p>这时的表结构：</p>
<table class="c2" border="0" cellspacing="0" cellpadding="0"><thead><tr><td><p class="c1"><strong>row key</strong></p></td><td><p class="c1"><strong>base_info</strong></p></td><td><p class="c1"><strong>ext_info</strong></p></td></tr></thead><tbody><tr><td><p class="c1">row1</p></td><td><p class="c1">name:a, tel:123</p></td><td>&nbsp;</td></tr><tr><td><p class="c1">row2</p></td><td><p class="c1">name:b</p></td><td><p class="c1">addr:bj</p></td></tr></tbody></table>

<p>HBase表中还有一个重要概念：版本，每个字段的值都有版本信息（通过时间戳指定）</p>
<p>例如 base_info:name，每次修改时都会保留之前的值，就是说可以取到他的旧值</p>
<table class="c2" border="0" cellspacing="0" cellpadding="0"><thead><tr><td><p class="c1"><strong>row key</strong></p></td><td><p class="c1"><strong>base_info</strong></p></td><td><p class="c1"><strong>ext_info</strong></p></td></tr></thead><tbody><tr><td><p class="c1">row1</p></td><td><p class="c1">name:a, tel:123</p></td><td>&nbsp;</td></tr><tr><td><p class="c1">row2</p></td><td><p class="c1">name:c(v2)[name:b(v1)]</p></td><td><p class="c1">addr:bj</p></td></tr></tbody></table>

<p><strong>小结</strong></p>
<p>从上面建表、插入数据的过程可以看出 HBase 存储数据的特点了</p>
<ul>
<li>和关系数据库一样，也是使用行和列的结构</li>
<li>建表时，定义的是表名和列族（字段的集合），而不是具体字段</li>
<li>列族中可以包含任意个字段，字段名不需要预定义，每一行中同一列族中的字段也可以不一致</li>
<li>多维结构，关系数据库的表是二维的，通过指行、列定位一个数据，HBase中需要通过 行健、列族名、字段名、版本号才能定位到具体数据</li>
<li>插入数据时，一次插入一个字段的数据，不是像关系数据库那样一次插入多个字段</li>
</ul>
]]></content>
      <categories>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>GO编程学习四-面向对象</title>
    <url>/2017/07/19/GO%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E5%9B%9B-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="method"><a href="/2017/07/19/GO编程学习四-面向对象/#method" class="headerlink" title="method"></a>method</h2><p>现在假设有这么一个场景，你定义了一个struct叫做长方形，你现在想要计算他的面积，那么按照我们一般的思路应<br>该会用下面的方式来实现<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    width, height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">    radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.width*r.height</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> c.radius * c.radius * math.Pi</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r1 := Rectangle&#123;<span class="number">12</span>, <span class="number">2</span>&#125;</span><br><span class="line">    r2 := Rectangle&#123;<span class="number">9</span>, <span class="number">4</span>&#125;</span><br><span class="line">    c1 := Circle&#123;<span class="number">10</span>&#125;</span><br><span class="line">    c2 := Circle&#123;<span class="number">25</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"Area of r1 is: "</span>, r1.area())</span><br><span class="line">    fmt.Println(<span class="string">"Area of r2 is: "</span>, r2.area())</span><br><span class="line">    fmt.Println(<span class="string">"Area of c1 is: "</span>, c1.area())</span><br><span class="line">    fmt.Println(<span class="string">"Area of c2 is: "</span>, c2.area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="method继承"><a href="/2017/07/19/GO编程学习四-面向对象/#method继承" class="headerlink" title="method继承"></a>method继承</h2><p>前面一章我们学习了字段的继承，那么你也会发现Go的一个神奇之处，method也是可以继承的。如果匿名字段实现了<br>一个method，那么包含这个匿名字段的struct也能调用该method。让我们来看下面这个例子<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在human上面定义了一个method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">"Mark"</span>, <span class="number">25</span>, <span class="string">"222-222-YYYY"</span>&#125;, <span class="string">"MIT"</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">"Sam"</span>, <span class="number">45</span>, <span class="string">"111-888-XXXX"</span>&#125;, <span class="string">"Golang Inc"</span>&#125;</span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="method重写"><a href="/2017/07/19/GO编程学习四-面向对象/#method重写" class="headerlink" title="method重写"></a>method重写</h2><p>上面定义一个method，重写了匿名字段的方法。请看下面的例子<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    phone <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    school <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human <span class="comment">//匿名字段</span></span><br><span class="line">    company <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Human定义method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *Human)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s you can call me on %s\n"</span>, h.name, h.phone)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Employee的method重写Human的method</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">SayHi</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Hi, I am %s, I work at %s. Call me on %s\n"</span>, e.name,e.company, e.phone) <span class="comment">//Yes you can split into 2 lines here.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mark := Student&#123;Human&#123;<span class="string">"Mark"</span>, <span class="number">25</span>, <span class="string">"222-222-YYYY"</span>&#125;, <span class="string">"MIT"</span>&#125;</span><br><span class="line">    sam := Employee&#123;Human&#123;<span class="string">"Sam"</span>, <span class="number">45</span>, <span class="string">"111-888-XXXX"</span>&#125;, <span class="string">"Golang Inc"</span>&#125;</span><br><span class="line">    mark.SayHi()</span><br><span class="line">    sam.SayHi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>Hbase概念及表格设计</title>
    <url>/2018/03/27/Hbase%E6%A6%82%E5%BF%B5%E5%8F%8A%E8%A1%A8%E6%A0%BC%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="1、概述"><a href="/2018/03/27/Hbase概念及表格设计/#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><ul>
<li>第一次看HBase, 可能看到以下描述会懵。“基于列存储”、“稀疏MAP”、“RowKey”、“ColumnFamily”。</li>
<li><p>其实没那么高深，我们需要分两步来理解HBase, 就能够理解为什么HBase能够“快速地”“分布式地”处理“大量数据”了。</p>
<ul>
<li>1.内存结构</li>
<li>2.文件存储结构</li>
</ul>
</li>
</ul>
<h3 id="2、名词概念以及内存结构"><a href="/2018/03/27/Hbase概念及表格设计/#2、名词概念以及内存结构" class="headerlink" title="2、名词概念以及内存结构"></a>2、名词概念以及内存结构</h3><p>假设我们有一张表（其中只有一条数据）：</p>
<table border="1" cellspacing="0" cellpadding="0" align="left"><tbody><tr><td rowspan="2" valign="top" width="86"><p class="c2"><span class="c1">RowKey</span></p></td><td colspan="2" valign="top" width="164"><p class="c2"><span class="c1">ColumnFamily : CF1</span></p></td><td colspan="2" valign="top" width="191"><p class="c2"><span class="c1">ColumnFamily : CF2</span></p></td><td rowspan="2" valign="top" width="87"><p class="c2"><span class="c1">TimeStamp</span></p></td></tr><tr><td valign="top" width="82"><p class="c2"><span class="c1">Column: C11</span></p></td><td valign="top" width="82"><p class="c2"><span class="c1">Column: C12</span></p></td><td valign="top" width="92"><p class="c2"><span class="c1">Column: C21</span></p></td><td valign="top" width="99"><p class="c2"><span class="c1">Column: C22</span></p></td></tr><tr><td valign="top" width="86"><p>“com.google”</p></td><td valign="top" width="82"><p>“C11 good”</p></td><td valign="top" width="82"><p>“C12 good”</p></td><td valign="top" width="92"><p>“C12 bad”</p></td><td valign="top" width="99"><p>“C12 bad”</p></td><td valign="top" width="87"><p>T1</p></td></tr></tbody></table>

<p><br></p>
<ul>
<li>1) RowKey: 行键，可理解成MySQL中的主键列。</li>
<li>2) Column: 列，可理解成MySQL列。</li>
<li>3) ColumnFamily: 列族, HBase引入的概念：</li>
</ul>
<p>将多个列聚合成一个列族。<br>可以理解成MySQL的垂直分区（将一张宽表，切分成几张不那么宽的表）。<br>此机制引入的原因，是因为HBase相信，查询可能并不需要将一整行的所有列数据全部返回。（就像我们往往在写SQL时不太会写select all一样）<br>对应到文件存储结构（不同的ColumnFamily会写入不同的文件）。</p>
<ul>
<li>4) TimeStamp：在每次跟新数据时，用以标识一行数据的不同版本（事实上，TimeStamp是与列绑定的。）<br>那我们为何会得到HBase的读写高性能呢？其实所有数据库操作如何得到高性能，答案几乎都是一致的，就是做索引。</li>
</ul>
<p>HBase的设计抛弃了传统RDBMS的行式数据模型，把索引和数据模型原生的集成在了一起。</p>
<p>以上图的表为例，表数据在HBase内部用Map实现，我们把它写成JSon的Object表述，即：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;com.google&quot;: &#123;</span><br><span class="line">    CF1: &#123;</span><br><span class="line">      C11:&#123;</span><br><span class="line">      T1: good</span><br><span class="line">      &#125;</span><br><span class="line">      C12:&#123;</span><br><span class="line">      T1: good</span><br><span class="line">      &#125;</span><br><span class="line">    CF2: &#123;</span><br><span class="line">      C21:&#123;</span><br><span class="line">      T1: bad</span><br><span class="line">      &#125;</span><br><span class="line">      C22:&#123;</span><br><span class="line">      T1: bad</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于Map本身可以通过B+树来实现，所以随机访问的速度大大加快（我们需要想象一下，表中有很多行的情况）。</p>
<p>现在我们在原来的表上修改一下（将Column: C22改为”good”）：</p>
<table border="1" cellspacing="0" cellpadding="0" align="left"><tbody><tr><td rowspan="2" valign="top" width="86"><p class="c2"><span class="c1">RowKey</span></p></td><td colspan="2" valign="top" width="164"><p class="c2"><span class="c1">ColumnFamily : CF1</span></p></td><td colspan="2" valign="top" width="191"><p class="c2"><span class="c1">ColumnFamily : CF2</span></p></td><td rowspan="2" valign="top" width="87"><p class="c2"><span class="c1">TimeStamp</span></p></td></tr><tr><td valign="top" width="82"><p class="c2"><span class="c1">Column: C11</span></p></td><td valign="top" width="82"><p class="c2"><span class="c1">Column: C12</span></p></td><td valign="top" width="92"><p class="c2"><span class="c1">Column: C21</span></p></td><td valign="top" width="99"><p class="c2"><span class="c1">Column: C22</span></p></td></tr><tr><td valign="top" width="86"><p>“com.google”</p></td><td valign="top" width="82"><p>“C11 good”</p></td><td valign="top" width="82"><p>“C12 good”</p></td><td valign="top" width="92"><p>“C12 bad”</p></td><td valign="top" width="99"><p>“C12 bad”</p></td><td valign="top" width="87"><p>T1</p></td></tr><tr><td valign="top" width="86"><p>“com.google”</p></td><td valign="top" width="82"><p>“C11 good”</p></td><td valign="top" width="82"><p>“C12 good”</p></td><td valign="top" width="92"><p>“C12 bad”</p></td><td valign="top" width="99"><p>“C12 good”</p></td><td valign="top" width="87"><p>T2</p></td></tr></tbody></table>

<p>于是MAP变为了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;com.google&quot;: &#123;</span><br><span class="line">    CF1: &#123;</span><br><span class="line">      C11:&#123;</span><br><span class="line">      T1: good</span><br><span class="line">      &#125;</span><br><span class="line">      C12:&#123;</span><br><span class="line">      T1: good</span><br><span class="line">      &#125;</span><br><span class="line">    CF2: &#123;</span><br><span class="line">      C21:&#123;</span><br><span class="line">      T1: bad</span><br><span class="line">      &#125;</span><br><span class="line">      C22:&#123;</span><br><span class="line">      T1: bad</span><br><span class="line">           T2:good</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>事实上，我们只需要在C22的object再加一个属性即可。如果我们把这个MAP翻译成表形状，也可以表示为：</p>
<table border="1" cellspacing="0" cellpadding="0" align="left"><tbody><tr><td rowspan="2" valign="top" width="86"><p class="c2"><span class="c1">RowKey</span></p></td><td colspan="2" valign="top" width="164"><p class="c2"><span class="c1">ColumnFamily : CF1</span></p></td><td colspan="2" valign="top" width="191"><p class="c2"><span class="c1">ColumnFamily : CF2</span></p></td><td rowspan="2" valign="top" width="87"><p class="c2"><span class="c1">TimeStamp</span></p></td></tr><tr><td valign="top" width="82"><p class="c2"><span class="c1">Column: C11</span></p></td><td valign="top" width="82"><p class="c2"><span class="c1">Column: C12</span></p></td><td valign="top" width="92"><p class="c2"><span class="c1">Column: C21</span></p></td><td valign="top" width="99"><p class="c2"><span class="c1">Column: C22</span></p></td></tr><tr><td valign="top" width="86"><p>“com.google”</p></td><td valign="top" width="82"><p>“C11 good”</p></td><td valign="top" width="82"><p>“C12 good”</p></td><td valign="top" width="92"><p>“C12 bad”</p></td><td valign="top" width="99"><p>“C12 bad”</p></td><td valign="top" width="87"><p>T1</p></td></tr><tr><td valign="top" width="86"><p>&nbsp;</p></td><td valign="top" width="82"><p>&nbsp;</p></td><td valign="top" width="82"><p>&nbsp;</p></td><td valign="top" width="92"><p>&nbsp;</p></td><td valign="top" width="99"><p>“C12 good”</p></td><td valign="top" width="87"><p>T2</p></td></tr></tbody></table>

<p>我们发现，这个表里很多列是没有value的。想象一下，如果再加入一行RowKey不同的数据，其中Column:C11内容为空，就可以在Json中省略该属性了。说明HBase是“稀疏的高阶MAP”。</p>
<p>为了查询效率，HBase内部对RowKey做了排序，以保证类似的或者相同的RowKey都集中在一起，于是HBase就变成了一张“稀疏的，有序的，高阶的MAP”。</p>
<h3 id="3-文件存储结构与进程模型"><a href="/2018/03/27/Hbase概念及表格设计/#3-文件存储结构与进程模型" class="headerlink" title="3.文件存储结构与进程模型"></a>3.文件存储结构与进程模型</h3><p>如上所述，HBase是一张“稀疏的，有序的，高阶的MAP”。</p>
<p>通常来说，MAP可以用B+树来实现。B+树对查询性能而言表现良好，但是对插入数据有些力不从心，尤其对于插入的数据需要持久化到磁盘的情况而言。</p>
<p>我们对RowKey做了排序，为了保证查询效率，我们希望将连续RowKey的数值保存在连续的磁道上，以避免大量的磁盘随机寻道。所以在插入数据时，对于B+树而言，就面临着大量的文件搬移工作。</p>
<p>HBase使用了LSM树实现了MAP，简单说来，就是将插入/修改操作缓存在内存中，当内存中积累足够的数据后，再以块的形式刷入到磁盘上。</p>
<p><img src="https://clyhs.github.io/images/hbase/hbase01.jpg" alt="img"></p>
<p>Region: 基于RowKey的分区，可理解成MySQL的水平切分。</p>
<p>每个Region Server就是Hadoop集群中一台机器上的一个进程。</p>
<p>比如我们的有1-300号的RowKey, 那么1-100号RowKey的行被分配到Region Server 1上，同样，101-200号分配到Region Server 2上， 201-300号分配到Region Server 3上。</p>
<p>在内存模型中，我们说RowKey保证了相邻RowKey的记录被连续地写入了磁盘。在这里，我们发现，RowKey决定了行操作（增，删，改，查）会被交与哪台Region Server操作。</p>
<p>让我们假设一下，如果我们的RowKey以记录的TimeStamp起始，从内存模型上说，这很合理，因为我们可能面临大量的用户流水记录查询，查询的条件会设置一个时间片段，我们希望一次性从磁盘中读取这些流水记录，从而避免频繁的磁盘寻道操作。</p>
<p>但是再另一方面，用户的流水记录查询会很频繁的出现“截至到至今”的查询条件，依照我们上面的进程模型，Region Server 3一定会被分配到（因为最近的记录排在最后），这样就可能造成Region Server 3的“过热”，而Region Server 1“过冷”的情况。</p>
<p>文件存储模型：<br><img src="https://clyhs.github.io/images/hbase/hbase02.jpg" alt="img"></p>
<p>在HDFS中，每张表对应一个目录，在表目录下，每个Region对应一个目录，在Region目录下，每个Store对应一个目录（一个Store对应一个ColumFamily）。结构如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HBase</span><br><span class="line">  |</span><br><span class="line">  ---Table</span><br><span class="line">       |</span><br><span class="line">       ---XXXX(Region的hash)</span><br><span class="line">       |    |</span><br><span class="line">       |    ----ColumnFamily</span><br><span class="line">       |              |</span><br><span class="line">       |              ---文件</span><br><span class="line">       |</span><br><span class="line">       ---YYYYY(另一个Region的hash)</span><br></pre></td></tr></table></figure></p>
<p>我们的新发现是，不同的ColumnFamily对应不同的Store, 并且被写入了不同的目录, 这意味着：</p>
<ol>
<li><p>通过将一张表分解成了不同的ColumnFamily，HBase可以从磁盘一次读取更少的内容（IO操作往往是计算机系统中最慢的一环）。</p>
</li>
<li><p>我们不应该将需要一次查询出的列，分解在不同的ColumnFamily中，否则以为着HBase不得不读取两个文件来满足查询要求。</p>
</li>
</ol>
<p>另外，一个ColumnFamily中的每一列是连续存储的。即如果一个ColumnFamily中存在C1,C2两列，一段具有100行记录的存储格式是：</p>
<p>C1(1),C2(1),C1(2),C2(2),C1(3),C2(3)………….C1(100),C2(100)</p>
<p>与其说HBase是基于列的数据库，更不如说HBase是基于“列族”的数据库。</p>
<h3 id="4-理解"><a href="/2018/03/27/Hbase概念及表格设计/#4-理解" class="headerlink" title="4 理解:"></a>4 理解:</h3><p>基于以上的模型，大致的理解是：</p>
<ol>
<li><p>RowKey决定了行操作任务进入RegionServer的数量，我们应该尽量的让一次操作调用更多的Region Server，已达到分布式的目的。</p>
</li>
<li><p>RowKey决定了查询读取连续磁盘块的数量，最理想的情况是一次查询，在每个Region Server上，只读取一个磁盘块。</p>
</li>
<li><p>ColumnFamily决定了一次查询需要读取的文件数（不同的文件不仅意味着分散的磁盘块，还意味着多次的文件打开关闭操作）。我们应尽量将希望查询的结果集合并到一个ColumnFamily中。同时尽量去除该ColumnFamily中不需要的列。</p>
</li>
<li><p>HBase官方建议尽量的减少ColumnFamily的数量。</p>
</li>
</ol>
<p>再瞎总结一下：</p>
<ol>
<li><p>RowKey由查询条件决定。</p>
</li>
<li><p>ColumnFamily由查询结果决定。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>GO编程学习十-并发模型管道和取消</title>
    <url>/2017/08/22/GO%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E5%8D%81-%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E7%AE%A1%E9%81%93%E5%92%8C%E5%8F%96%E6%B6%88/</url>
    <content><![CDATA[<h2 id="简介"><a href="/2017/08/22/GO编程学习十-并发模型管道和取消/#简介" class="headerlink" title="简介"></a>简介</h2><p>Golang的原子并发特性使得它很容易构造流数据管道，这使得Golang可有效的使用I/O和多CPU特性。本文提出一些关于管道的示例，在这个过程中突出了操作失败的微妙之处和介绍处理失败的具体技术。</p>
<h3 id="什么是管道"><a href="/2017/08/22/GO编程学习十-并发模型管道和取消/#什么是管道" class="headerlink" title="什么是管道"></a>什么是管道</h3><p>在Golang对于管道没有明确的定义；它只是许多种并发程序中的一种。管道是通道连接的一系列阶段， 每个阶段是一组goroutine运行相同的功能。在每个阶段，goroutine运行步骤为：</p>
<ul>
<li><p>从上游经过入境通道接受值</p>
</li>
<li><p>对数据执行一些功能操作，通常会产生新的值</p>
</li>
<li><p>从下游经过出境通道发送值</p>
</li>
</ul>
<p>除了开始和最后阶段只有一个入境通道或者一个出境通道外，其他每个阶段有任意数量的入境通道和出境通道，。开始阶段有时又称为源或者生产者；最后一个阶段又称为sink或者消费者。</p>
<h3 id="平方数"><a href="/2017/08/22/GO编程学习十-并发模型管道和取消/#平方数" class="headerlink" title="平方数"></a>平方数</h3><p>一个通道有三个阶段。</p>
<p>第一阶段：gen，以从列表读出整数的方式转换整数列表到一个通道。gen函数开始goroutine后， 在通道上发送整数并且在在所有的值被发送完后将通道关闭：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            out &lt;- n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二阶段：sq，从通道接受整数，然后将接受到的每个整数值的平方后返回到一个通道 。在入境通道关闭和发送所有下行值的阶段结束后，关闭出口通道：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</span><br><span class="line">            out &lt;- n * n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main函数建立了通道并运行最后一个阶段：它接受来自第二阶段的值并打印出每个值，直到通道关闭：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Set up the pipeline.</span></span><br><span class="line">    c := gen(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">    out := sq(c)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Consume the output.</span></span><br><span class="line">    fmt.Println(&lt;-out) <span class="comment">// 4</span></span><br><span class="line">    fmt.Println(&lt;-out) <span class="comment">// 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于sq有相同类型的入境和出境通道，我们可以写任意次。我们也可以重写main函数，像其他阶段一样做一系列循环 ：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Set up the pipeline and consume the output.</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> sq(sq(gen(<span class="number">2</span>, <span class="number">3</span>))) &#123;</span><br><span class="line">        fmt.Println(n) <span class="comment">// 16 then 81</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扇出，扇入"><a href="/2017/08/22/GO编程学习十-并发模型管道和取消/#扇出，扇入" class="headerlink" title="扇出，扇入"></a>扇出，扇入</h3><ul>
<li><p>扇出（fan-out）：多个函数能从相同的通道中读数据，直到通道关闭；这提供了一种在一组“人员”中分发任务的方式，使得CPU和I/O的并行处理.</p>
</li>
<li><p>扇入（fan-in）：一个函数能从多个输入中读取并处理数据，而这多个输入通道映射到一个单通道，该单通道随着所有输入的结束而关闭。</p>
</li>
</ul>
<p>我们可以改变通道去运行两个sq实例，每个实例从相同的输入通道读取数据。我们引入了一个新函数merge去扇入结果：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    in := gen(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Distribute the sq work across two goroutines that both read from in.</span></span><br><span class="line">    c1 := sq(in)</span><br><span class="line">    c2 := sq(in)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Consume the merged output from c1 and c2.</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> merge(c1, c2) &#123;</span><br><span class="line">        fmt.Println(n) <span class="comment">// 4 then 9, or 9 then 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>merge函数通过为每一个入境通道开启一个goroutine去复制数值到唯一的出境通道，从而实现了转换通道列表到一个单通道 。一旦所有的output goroutine启动，所有在通道上的发送完成后merge函数开启一个以上的goroutine用于关闭出境通道。</p>
<p>在一个关闭的通道上发送没有意义，所以在关闭之前确保所有的发送完成是重要的。sync.WaitGroup类型提供了一个简单的方法去组织同步：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(cs ...&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start an output goroutine for each input channel in cs.  output</span></span><br><span class="line">    <span class="comment">// copies values from c to out until c is closed, then calls wg.Done.</span></span><br><span class="line">    output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line">            out &lt;- n</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Add(<span class="built_in">len</span>(cs))</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cs &#123;</span><br><span class="line">        <span class="keyword">go</span> output(c)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a goroutine to close out once all the output goroutines are</span></span><br><span class="line">    <span class="comment">// done.  This must start after the wg.Add call.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="短暂停止"><a href="/2017/08/22/GO编程学习十-并发模型管道和取消/#短暂停止" class="headerlink" title="短暂停止"></a>短暂停止</h3><p>管道函数模型：</p>
<ul>
<li><p>当所有的发送操作结束后， 阶段关闭他们的出境通道。</p>
</li>
<li><p>阶段持续接收来自入境通道的值，直到那些通道关闭。</p>
</li>
</ul>
<p>这个模型允许每一个接收阶段通过range循环的写数据，确保一旦所有向下游发送的值发送成功，所有的goroutine退出。 </p>
<p>但在一个真实的管道上，阶段并不总是接收所有的入境值。有时设计是这样的：接收者可能只需要一个子集值就能取得进展。更多时候是一个阶段早早的退出，因为一个入境值代表一个早期阶段的错误。 在这两种情况下接收者不应该等待剩余的值到达，我们想要早期阶段停止产生后续阶段不需要的值。</p>
<p>在我们的示例中，如果一个阶段不能处理所有的入境值，那么试图发送这些值得goroutine将无限期的阻塞：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Consume the first value from output.</span></span><br><span class="line">    out := merge(c1, c2)</span><br><span class="line">    fmt.Println(&lt;-out) <span class="comment">// 4 or 9</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// Since we didn't receive the second value from out,</span></span><br><span class="line">    <span class="comment">// one of the output goroutines is hung attempting to send it.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个资源锁：goroutine消耗内存和运行资源，并且在goroutine栈中的堆引用防止数据被回收。Goroutine不能垃圾回收；它们必须自己退出。</p>
<p>当下游阶段在接收所有的入境值失败后，我们需要安排管道的上游阶段退出。一种实现方法是将出境通道改为一个缓冲区。该缓冲区能保存固定数量的值；如果缓冲区有空闲就立即发送操作完成信号：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>) <span class="comment">// buffer size 2</span></span><br><span class="line">c &lt;- <span class="number">1</span>  <span class="comment">// succeeds immediately</span></span><br><span class="line">c &lt;- <span class="number">2</span>  <span class="comment">// succeeds immediately</span></span><br><span class="line">c &lt;- <span class="number">3</span>  <span class="comment">// blocks until another goroutine does &lt;-c and receives 1</span></span><br></pre></td></tr></table></figure></p>
<p>当在通道创建就预先知道待发送的数值个数时，通过使用缓冲区可以简化代码。例如，我们可以重写  gen 来将整数列表复制到带有缓冲区的通道中，也可以避免创建一个新的 goroutine：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        out &lt;- n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>回到管道中处于阻塞状态的 goroutine，我们可以考虑为 merge 返回的出境通道增加一个缓冲区：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(cs ...&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// enough space for the unread inputs</span></span><br><span class="line">    <span class="comment">// ... the rest is unchanged ...</span></span><br></pre></td></tr></table></figure></p>
<p>尽管它修正了程序中 goroutine 的阻塞问题，但却不能称为好代码。在这里，缓冲区大小选取为 1，取决于预知 merge 将会接收的数值个数及下游各阶段将会消费的数值个数。这很脆弱：如果我们给 gen 多传了一个数值，或者下游阶段少读了一些数值，goroute 的阻塞问题会再次出现。</p>
<p>作为代替，我们需要为下游各阶段提供一种手段，来向发送方表明指明它们将停止接收数据的输入。</p>
<h3 id="显式取消"><a href="/2017/08/22/GO编程学习十-并发模型管道和取消/#显式取消" class="headerlink" title="显式取消"></a>显式取消</h3><p>当main没有接受完out所有的值就决定退出时，它必须告知上游状态(upstream stage)的goroutines，让它丢弃正在发送中的数据。通过在一个叫做done的channel上发送数据，即可实现。例子里有两个受阻的发送方，所以发送的值有两组：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    in := gen(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Distribute the sq work across two goroutines that both read from in.</span></span><br><span class="line">    c1 := sq(in)</span><br><span class="line">    c2 := sq(in)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Consume the first value from output.</span></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">2</span>)</span><br><span class="line">    out := merge(done, c1, c2)</span><br><span class="line">    fmt.Println(&lt;-out) <span class="comment">// 4 or 9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the remaining senders we're leaving.</span></span><br><span class="line">    done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用select语句，让发送中的goroutines取代了发送操作。这条语句既可以处理在发送out的情形，也可以处理从done中接受一个值的情况。done的值类型是空结构，因为它的数值并不重要:它是一个接受事件，表明out的发送应该被丢弃。output goroutines继续在channel c内循环运行,而不会阻塞上游状态(upstream stage)：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, cs ...&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start an output goroutine for each input channel in cs.  output</span></span><br><span class="line">    <span class="comment">// copies values from c to out until c is closed or it receives a value</span></span><br><span class="line">    <span class="comment">// from done, then output calls wg.Done.</span></span><br><span class="line">    output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> out &lt;- n:</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... the rest is unchanged ...</span></span><br></pre></td></tr></table></figure></p>
<p>但是这种方法有个问题：下游的接收者需要知道潜在会被阻塞的上游发送者的数量。追踪这些数量不仅枯燥，还容易出错。</p>
<p>我们要有一个方法告知一个未知的、无限数量的go程序向下游发送它们的值。在GO里面我们通过关闭一个通道来实现，因为一个在已关闭通道上的接收操作总能立即执行，并返回该元素类型的零值。</p>
<p>这意味着main函数只需关闭“done”通道就能开启所有发送者。close实际上是传给发送者的一个广播信号。我们扩展每一个管道函数接收“done”参数并通过一个“defer”语句触发“close”，这样所有来自main的返回路径都会以信号通知管道退出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Set up a done channel that's shared by the whole pipeline,</span></span><br><span class="line">    <span class="comment">// and close that channel when this pipeline exits, as a signal</span></span><br><span class="line">    <span class="comment">// for all the goroutines we started to exit.</span></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line">    in := gen(done, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Distribute the sq work across two goroutines that both read from in.</span></span><br><span class="line">    c1 := sq(done, in)</span><br><span class="line">    c2 := sq(done, in)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Consume the first value from output.</span></span><br><span class="line">    out := merge(done, c1, c2)</span><br><span class="line">    fmt.Println(&lt;-out) <span class="comment">// 4 or 9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// done will be closed by the deferred call.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>管道里的每个状态现在都可以随意的提早退出了：sq可以在它的循环中退出，因为我们知道如果done已经被关闭了，也会关闭上游的gen状态。sq通过defer语句，保证不管从哪个返回路径，它的outchannel 都会被关闭。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> out &lt;- n * n:</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://studygolang.com/articles/1143" target="_blank" rel="noopener">http://studygolang.com/articles/1143</a></p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7防火墙指定ip访问某端口</title>
    <url>/2019/06/25/centos7%E9%98%B2%E7%81%AB%E5%A2%99%E6%8C%87%E5%AE%9Aip%E8%AE%BF%E9%97%AE%E6%9F%90%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>docker 启动的服务想用防火墙来限制ip访问，怎么做？</p>
<h3 id="防火墙命令"><a href="/2019/06/25/centos7防火墙指定ip访问某端口/#防火墙命令" class="headerlink" title="防火墙命令"></a>防火墙命令</h3><p>systemctl enable firewalld 允许防火墙</p>
<p>systemctl disable firewalld 禁止防火墙</p>
<p>systemctl start firewalld 开启防火墙</p>
<p>systemctl stop firewalld 停止防火墙</p>
<h4 id="先开启防火墙"><a href="/2019/06/25/centos7防火墙指定ip访问某端口/#先开启防火墙" class="headerlink" title="先开启防火墙"></a>先开启防火墙</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable firewalld</span><br><span class="line">systemctl start firewalld</span><br></pre></td></tr></table></figure>
<p>查看防火墙规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -L</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">INPUT_direct  all  --  anywhere             anywhere            </span><br><span class="line">INPUT_ZONES_SOURCE  all  --  anywhere             anywhere            </span><br><span class="line">INPUT_ZONES  all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere             ctstate INVALID</span><br><span class="line">REJECT     all  --  anywhere             anywhere             reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED</span><br><span class="line">ACCEPT     all  --  anywhere             anywhere            </span><br><span class="line">FORWARD_direct  all  --  anywhere             anywhere            </span><br><span class="line">FORWARD_IN_ZONES_SOURCE  all  --  anywhere             anywhere            </span><br><span class="line">FORWARD_IN_ZONES  all  --  anywhere             anywhere            </span><br><span class="line">FORWARD_OUT_ZONES_SOURCE  all  --  anywhere             anywhere            </span><br><span class="line">FORWARD_OUT_ZONES  all  --  anywhere             anywhere            </span><br><span class="line">DROP       all  --  anywhere             anywhere             ctstate INVALID</span><br><span class="line">REJECT     all  --  anywhere             anywhere             reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">OUTPUT_direct  all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain FORWARD_IN_ZONES (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">FWDI_public  all  --  anywhere             anywhere            [goto] </span><br><span class="line">FWDI_public  all  --  anywhere             anywhere            [goto] </span><br><span class="line"></span><br><span class="line">Chain FORWARD_IN_ZONES_SOURCE (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD_OUT_ZONES (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">FWDO_public  all  --  anywhere             anywhere            [goto] </span><br><span class="line">FWDO_public  all  --  anywhere             anywhere            [goto] </span><br><span class="line"></span><br><span class="line">Chain FORWARD_OUT_ZONES_SOURCE (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD_direct (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDI_public (2 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">FWDI_public_log  all  --  anywhere             anywhere            </span><br><span class="line">FWDI_public_deny  all  --  anywhere             anywhere            </span><br><span class="line">FWDI_public_allow  all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     icmp --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain FWDI_public_allow (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDI_public_deny (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDI_public_log (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDO_public (2 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">FWDO_public_log  all  --  anywhere             anywhere            </span><br><span class="line">FWDO_public_deny  all  --  anywhere             anywhere            </span><br><span class="line">FWDO_public_allow  all  --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain FWDO_public_allow (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDO_public_deny (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FWDO_public_log (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain INPUT_ZONES (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">IN_public  all  --  anywhere             anywhere            [goto] </span><br><span class="line">IN_public  all  --  anywhere             anywhere            [goto] </span><br><span class="line"></span><br><span class="line">Chain INPUT_ZONES_SOURCE (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain INPUT_direct (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain IN_public (2 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">IN_public_log  all  --  anywhere             anywhere            </span><br><span class="line">IN_public_deny  all  --  anywhere             anywhere            </span><br><span class="line">IN_public_allow  all  --  anywhere             anywhere            </span><br><span class="line">ACCEPT     icmp --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain IN_public_allow (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh ctstate NEW</span><br><span class="line"></span><br><span class="line">Chain IN_public_deny (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain IN_public_log (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT_direct (1 references)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>
<h4 id="重启docker"><a href="/2019/06/25/centos7防火墙指定ip访问某端口/#重启docker" class="headerlink" title="重启docker"></a>重启docker</h4><p>如果应用部署在docker中，那么启动防火墙，必须重启docker，<strong>docker会自动</strong>把端口写入防火墙</p>
<p>再次查看防火墙，<em>iptables -L</em>，可以看到多了一条记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">Chain DOCKER (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     tcp  --  anywhere             172.17.0.2           tcp dpt:2375</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>因为docker 启动后，会自己启动时面已经加载的shipyard-proxy的容器，端口为2375，而anywhere表示任何机器都可以访问。</p>
<h4 id="对外开放端口"><a href="/2019/06/25/centos7防火墙指定ip访问某端口/#对外开放端口" class="headerlink" title="对外开放端口"></a>对外开放端口</h4><h5 id="对所有IP都开放端口-不限制ip"><a href="/2019/06/25/centos7防火墙指定ip访问某端口/#对所有IP都开放端口-不限制ip" class="headerlink" title="对所有IP都开放端口,不限制ip"></a>对所有IP都开放端口,不限制ip</h5><p>如tomcat:8870</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=8870/tcp --permanent   //添加端口</span><br><span class="line"><span class="meta">#</span>如果想加入其它端口8080可以为：</span><br><span class="line"><span class="meta">#</span>firewall-cmd --zone=public --add-port=8080/tcp --permanent  </span><br><span class="line"></span><br><span class="line">firewall-cmd --reload                                        //必须重加载，才生效</span><br></pre></td></tr></table></figure>
<p>再次查看<em>iptables -L</em>，多了一条记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">Chain IN_public_allow (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh ctstate NEW</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:8870 ctstate NEW</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>这样你就可以在浏览器访问8870</p>
<h5 id="指定ip访问redis的6300端口"><a href="/2019/06/25/centos7防火墙指定ip访问某端口/#指定ip访问redis的6300端口" class="headerlink" title="指定ip访问redis的6300端口"></a>指定ip访问redis的6300端口</h5><p>一般启动docker的redis服务，docker写入防火墙是不限制ip，比如通过docker启动mysql，zookeeper等</p>
<p>通过<em>iptables -L</em>自动添加了如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line">Chain DOCKER (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     tcp  --  anywhere             172.17.0.2           tcp dpt:2375</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.17.0.3           tcp dpt:9066</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.17.0.3           tcp dpt:8066</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.17.0.4           tcp dpt:mysql</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.17.0.5           tcp dpt:sun-as-jmxrmi</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.17.0.5           tcp dpt:eforward</span><br><span class="line">ACCEPT     tcp  --  anywhere             172.17.0.6           tcp dpt:61616</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>但是你发现，<strong>哨兵的端口</strong>没有在里面，因为哨兵是在DOCKER容器里面启动的，不在这里，需要手动添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=26000/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> iptables -L查看</span><br><span class="line">Chain IN_public_allow (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:ssh ctstate NEW</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:26000 ctstate NEW</span><br><span class="line">ACCEPT     tcp  --  anywhere             anywhere             tcp dpt:8870 ctstate NEW</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>通过telnet可以访问26000</span><br></pre></td></tr></table></figure>
<p>再查看一下，里面没有redis的端口规则，因为redis只能指定Ip访问，所以添加如下：</p>
<p><strong>指定192.168.0.60能访问6300</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source address="192.168.0.60" port protocol="tcp" port="6300" accept"</span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>iptables -L</span><br><span class="line">Chain IN_public_allow (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     tcp  --  192.168.0.60         anywhere             tcp dpt:bmc-grx ctstate NEW</span><br></pre></td></tr></table></figure>
<p>通过其它机器的telnet验证</p>
<p>在192.168.0.60</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# telnet 192.168.0.54 6300</span><br><span class="line">Trying 192.168.0.54...</span><br><span class="line">Connected to 192.168.0.54.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br></pre></td></tr></table></figure>
<p>表示成功</p>
<p>在192.168.0.16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@appserver1 ~]#  telnet 192.168.0.54 6300</span><br><span class="line">Trying 192.168.0.54...</span><br><span class="line">telnet: connect to address 192.168.0.54: No route to host</span><br></pre></td></tr></table></figure>
<p>表示失败.</p>
<p>这样就成功了。</p>
<p><strong>如果我也想把192.168.0.16加入访问192.168.0.54的6300</strong></p>
<p>同样如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-rich-rule="rule family="ipv4" source address="192.168.0.16" port protocol="tcp" port="6300" accept"</span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>iptables -L 查看</span><br><span class="line">Chain IN_public_allow (1 references)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">ACCEPT     tcp  --  192.168.0.16         anywhere             tcp dpt:bmc-grx ctstate NEW</span><br><span class="line">ACCEPT     tcp  --  192.168.0.60         anywhere             tcp dpt:bmc-grx ctstate NEW</span><br></pre></td></tr></table></figure>
<p>在192.168.0.16</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@appserver1 ~]# telnet 192.168.0.54 6300</span><br><span class="line">Trying 192.168.0.54...</span><br><span class="line">Connected to 192.168.0.54.</span><br><span class="line">Escape character is '^]'.</span><br></pre></td></tr></table></figure>
<p>这样就可以成功了。</p>
<p><strong>如果上面无效、需要增加下面操作</strong></p>
<p>docker 会在iptables上加上自己的转发规则，如果直接在input链上限制端口是没有效果的。</p>
<p>这就需要限制docker的转发链上的DOCKER表。</p>
<p>查询DOCKER表并显示规则编号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -L DOCKER -n --line-number</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chain DOCKER (1 references)</span><br><span class="line">num  target     prot opt source               destination         </span><br><span class="line">1    ACCEPT     tcp  --  0.0.0.0/0         0.0.0.0/0            tcp dpt:6300</span><br><span class="line">2    ACCEPT     tcp  --  0.0.0.0/0            172.17.0.3        tcp dpt:8080</span><br></pre></td></tr></table></figure>
<p> 修改对应编号的iptables 规则，这里添加了允许访问ip的限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -R DOCKER 1 -p tcp -m tcp -s 192.168.0.54 --dport 6300 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>再执行iptables -L DOCKER -n –line-number</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Chain DOCKER (1 references)</span><br><span class="line">num  target     prot opt source               destination         </span><br><span class="line">1    ACCEPT     tcp  --  192.168.0.54         0.0.0.0/0            tcp dpt:6300</span><br><span class="line">2    ACCEPT     tcp  --  0.0.0.0/0            172.17.0.3           tcp dpt:8080</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iptables</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>centos7</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7防火墙设置</title>
    <url>/2019/01/21/centos7%E9%98%B2%E7%81%AB%E5%A2%99%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="centos7防火墙设置"><a href="/2019/01/21/centos7防火墙设置/#centos7防火墙设置" class="headerlink" title="centos7防火墙设置"></a>centos7防火墙设置</h3><p>1、firewalld的基本使用<br>启动： systemctl start firewalld<br>关闭： systemctl stop firewalld<br>查看状态： systemctl status firewalld<br>开机禁用  ： systemctl disable firewalld<br>开机启用  ： systemctl enable firewalld</p>
<p>2、配置firewalld-cmd</p>
<p>查看版本： firewall-cmd –version<br>查看帮助： firewall-cmd –help<br>显示状态： firewall-cmd –state<br>查看所有打开的端口： firewall-cmd –zone=public –list-ports<br>更新防火墙规则： firewall-cmd –reload<br>查看区域信息:  firewall-cmd –get-active-zones<br>查看指定接口所属区域： firewall-cmd –get-zone-of-interface=eth0<br>拒绝所有包：firewall-cmd –panic-on<br>取消拒绝状态： firewall-cmd –panic-off<br>查看是否拒绝： firewall-cmd –query-panic</p>
<p>3、开启一个端口<br>添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent    （--permanent永久生效，没有此参数重启后失效）</span><br></pre></td></tr></table></figure></p>
<p>重新载入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></p>
<p>查看<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone= public --query-port=80/tcp</span><br></pre></td></tr></table></figure></p>
<p>删除<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --zone= public --remove-port=80/tcp --permanent</span><br></pre></td></tr></table></figure></p>
<p>4、指定IP与端口<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;10.40.107.11&quot; port protocol=&quot;tcp&quot; port=&quot;2375&quot; accept&quot;</span><br></pre></td></tr></table></figure></p>
<p>5、删除规则<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --remove-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;10.40.107.11&quot; port protocol=&quot;tcp&quot; port=&quot;2375&quot; accept&quot;</span><br></pre></td></tr></table></figure></p>
<p>6、然后对指定的IP开放指定的端口段<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;10.40.107.11&quot; port protocol=&quot;tcp&quot; port=&quot;30000-31000&quot; accept&quot;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>firewall</category>
      </categories>
      <tags>
        <tag>centos7</tag>
        <tag>firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>bower前端包管理器入门</title>
    <url>/2017/04/15/bower%E5%89%8D%E7%AB%AF%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="什么是bower"><a href="/2017/04/15/bower前端包管理器入门/#什么是bower" class="headerlink" title="什么是bower"></a>什么是bower</h1><p>Bower是一个客户端技术的软件包管理器，它可用于搜索、安装和卸载如JavaScript、HTML、CSS之类的网络资源。其他一些建立在Bower基础之上的开发工具</p>
<h2 id="准备工作"><a href="/2017/04/15/bower前端包管理器入门/#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol>
<li>安装npm</li>
<li>安装nod.js</li>
<li>安装bower</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># npm install -g bower</span><br></pre></td></tr></table></figure>
<h3 id="bower初始化"><a href="/2017/04/15/bower前端包管理器入门/#bower初始化" class="headerlink" title="bower初始化"></a>bower初始化</h3><p>进入web项目静态目录如<code>static</code>或者<code>template</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bower init</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>在WINDOWS下如题用git窗口执行可以会报如下错误<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bower init</span><br><span class="line">bower ENOINT        Register requires an interactive shell</span><br><span class="line"></span><br><span class="line">Additional error details:</span><br><span class="line">Note that you can manually force an interactive shell with --config.interactive</span><br></pre></td></tr></table></figure></p>
<p>记得切换到win的<code>CMD</code>命令下执行<code>bower init</code><br><img src="https://clyhs.github.io/images/js/bower01.png" alt="img"><br>些时目录下生成<code>bower.json</code><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;helloweb&quot;,</span><br><span class="line">  &quot;homepage&quot;: &quot;index.html&quot;,</span><br><span class="line">  &quot;authors&quot;: [</span><br><span class="line">    &quot;xxx &lt;xxx@126.com&gt;&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;description&quot;: &quot;web&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.html&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;ignore&quot;: [</span><br><span class="line">    &quot;**/.*&quot;,</span><br><span class="line">    &quot;node_modules&quot;,</span><br><span class="line">    &quot;bower_components&quot;,</span><br><span class="line">    &quot;test&quot;,</span><br><span class="line">    &quot;tests&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="安装第三方JS如jquery"><a href="/2017/04/15/bower前端包管理器入门/#安装第三方JS如jquery" class="headerlink" title="安装第三方JS如jquery"></a>安装第三方JS如<code>jquery</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bower install jquery --save</span><br></pre></td></tr></table></figure>
<p>.<br>├── static<br>│   ├── bower_components<br>│   │     ├── jquery<br>│   └── bower.json<br>│   └──index.html<br>在<code>index.html</code>引用<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;bower_components/jquery/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>bower</category>
      </categories>
      <tags>
        <tag>bower</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>linux db2安装</title>
    <url>/2022/08/10/db2%E5%AE%9E%E4%BE%8B%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="linux-db2安装"><a href="/2022/08/10/db2实例安装/#linux-db2安装" class="headerlink" title="linux db2安装"></a>linux db2安装</h1><h2 id="1-db2安装"><a href="/2022/08/10/db2实例安装/#1-db2安装" class="headerlink" title="1 db2安装"></a>1 db2安装</h2><p>解压db2安装包,进入server目录下，执行安装检查<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf v9.7_linuxx64_server.tar.gz</span><br><span class="line">cd server</span><br><span class="line">./db2prereqcheck</span><br></pre></td></tr></table></figure></p>
<p>运行安装程序<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@server]./db2_install</span><br></pre></td></tr></table></figure></p>
<p>创建DB2运行所需要的用户组和用户<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd -g 901 db2iadm1</span><br><span class="line">groupadd -g 902 db2fadm1</span><br><span class="line">groupadd -g 903 dasadm1</span><br><span class="line">useradd -g db2iadm1 -u 801 -d /home/db2inst1 -m  db2inst1</span><br><span class="line">useradd -g db2fadm1 -u 802 -d /home/db2fenc1 -m  db2fenc1</span><br><span class="line">useradd -g dasadm1 -u 803 -d /home/dasadm1 -m  dasusr1</span><br></pre></td></tr></table></figure></p>
<p>为db2inst1创建密码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd db2inst1</span><br><span class="line">passwd db2fenc1</span><br><span class="line">passwd dasusr1</span><br></pre></td></tr></table></figure></p>
<p>进入/opt/ibm/db2/V9.7/instance目录<br>创建实例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@server]#cd /opt/ibm/db2/V9.7/instance</span><br><span class="line"></span><br><span class="line">[root@instance]#./dascrt -u dasusr1</span><br><span class="line"></span><br><span class="line">SQL4406W  The DB2 Administration Server was started successfully.</span><br><span class="line"></span><br><span class="line">DBI1070I  Program dascrt completed successfully.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@instance]#./db2icrt -u db2inst1 db2inst1</span><br><span class="line"></span><br><span class="line">DBI1070I  Program db2icrt completed successfully.</span><br></pre></td></tr></table></figure></p>
<p>启动db2实例<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@instance]#su - dasusr1</span><br><span class="line">[dasusr1@db2]$db2admin start</span><br><span class="line"></span><br><span class="line">[dasusr1@db2]$su - db2inst1</span><br><span class="line">[db2inst1@db2]$db2start</span><br></pre></td></tr></table></figure></p>
<p>关闭、启动数据库<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[db2inst1@db2]$db2stop</span><br><span class="line"></span><br><span class="line">[db2inst1@db2]$db2 force applications all</span><br><span class="line"></span><br><span class="line">[db2inst1@db2]$db2start</span><br></pre></td></tr></table></figure></p>
<p>创建样本库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[db2inst1@db2]$cd /opt/ibm/db2/V9.7/bin</span><br><span class="line"></span><br><span class="line">[db2inst1@db2]$./db2sampl</span><br></pre></td></tr></table></figure>
<p>设置DB2自启动<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@db2]#cd /opt/ibm/db2/V9.7/instance</span><br><span class="line"></span><br><span class="line">[root@instance]#./db2iauto -on db2inst1</span><br></pre></td></tr></table></figure></p>
<p>配置TCPIP<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@instance]#su - db2inst1</span><br><span class="line"></span><br><span class="line">[db2inst1@db2]$db2set DB2COMM=TCPIP</span><br></pre></td></tr></table></figure></p>
<p>创建数据库实例<br>db2 “create db cpaasm using codeset UTF-8 territory CN pagesize 8192 catalog tablespace managed by database using (file ‘/home/db2inst1/cpaasmts’ 131072 ) user tablespace managed by database using (file ‘/home/db2inst1/cpaasuserspace’ 131072 ) temporary tablespace managed by system using (‘/home/db2inst1/cpaasmtempspace’)”</p>
<p>创建额外BufferPool及表空间<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db2 =&gt; connect to cpaasm</span><br><span class="line"></span><br><span class="line">   Database Connection Information</span><br><span class="line"></span><br><span class="line"> Database server        = DB2/LINUXX8664 9.7.7</span><br><span class="line"> SQL authorization ID   = DB2IFFCS</span><br><span class="line"> Local database alias   = cpaasm</span><br><span class="line"></span><br><span class="line">db2 =&gt; create bufferpool buffer_assp8k size 25600 pagesize 8k</span><br><span class="line">DB20000I  The SQL command completed successfully.</span><br><span class="line">db2 =&gt; create bufferpool buffer_idx8k size 25600 pagesize 8k</span><br><span class="line">DB20000I  The SQL command completed successfully.</span><br><span class="line">db2 =&gt;  create bufferpool buffer_clob32k size 6400 pagesize 32k</span><br><span class="line">DB20000I  The SQL command completed successfully.</span><br><span class="line">db2 =&gt; create tablespace assp pagesize 8192 managed by database using (file &apos;/home/db2inst1/asspspace_c1&apos; 131072) bufferpool buffer_assp8k autoresize no </span><br><span class="line">DB20000I  The SQL command completed successfully.</span><br><span class="line">db2 =&gt; create tablespace assp_index pagesize 8192 managed by database using (file &apos;/home/db2inst1/idxspace_c1&apos; 131072) bufferpool buffer_idx8k autoresize no</span><br><span class="line">DB20000I  The SQL command completed successfully.</span><br><span class="line">db2 =&gt; create tablespace assp_clob pagesize 32768 managed by database using (file &apos;/home/db2inst1/clobspace_c1&apos; 32768) bufferpool buffer_clob32k</span><br><span class="line">DB20000I  The SQL command completed successfully.</span><br></pre></td></tr></table></figure></p>
<p>为数据库应用用户授权<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db2 =&gt; grant connect on database to user cpaasdb</span><br><span class="line">grant bindadd on database to user cpaasdb</span><br><span class="line">grant createtab on database to user cpaasdb</span><br><span class="line">DB20000I  The SQL command completed successfully.</span><br><span class="line">db2 =&gt; DB20000I  The SQL command completed successfully.</span><br><span class="line">db2 =&gt; DB20000I  The SQL command completed successfully.</span><br><span class="line">db2 =&gt; grant implicit_schema on database to user cpaasdb</span><br><span class="line">DB20000I  The SQL command completed successfully.</span><br><span class="line">db2 =&gt; grant load on database to user cpaasdb</span><br><span class="line">DB20000I  The SQL command completed successfully.</span><br><span class="line">db2 =&gt; grant use of tablespace assp to user cpaasdb</span><br><span class="line">DB20000I  The SQL command completed successfully.</span><br><span class="line">db2 =&gt; grant use of tablespace assp_index to user cpaasdb</span><br><span class="line">DB20000I  The SQL command completed successfully.</span><br><span class="line">db2 =&gt; grant use of tablespace assp_clob to user cpaasdb</span><br><span class="line">DB20000I  The SQL command completed successfully.</span><br></pre></td></tr></table></figure></p>
<p>#<br><a href="https://blog.csdn.net/zhlh_xt/article/details/40344709" target="_blank" rel="noopener">https://blog.csdn.net/zhlh_xt/article/details/40344709</a><br>删除数据库<br>db2 drop database cpaasm</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>db2</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装postgresql</title>
    <url>/2022/05/01/docker%20install%20postgresql/</url>
    <content><![CDATA[<h1 id="docker-install-postgresql"><a href="/2022/05/01/docker install postgresql/#docker-install-postgresql" class="headerlink" title="docker install postgresql"></a>docker install postgresql</h1><h2 id="image"><a href="/2022/05/01/docker install postgresql/#image" class="headerlink" title="image"></a>image</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull postgres</span><br></pre></td></tr></table></figure>
<h2 id="build-container"><a href="/2022/05/01/docker install postgresql/#build-container" class="headerlink" title="build container"></a>build container</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --name postgres --restart always -e POSTGRES_PASSWORD=&apos;123456&apos; -e ALLOW_IP_RANGE=0.0.0.0/0 -v /home/postgres/data:/var/lib/postgresql -p 5432:5432 -d postgres</span><br></pre></td></tr></table></figure>
<h2 id="enter-container"><a href="/2022/05/01/docker install postgresql/#enter-container" class="headerlink" title="enter container"></a>enter container</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it postgres bash</span><br></pre></td></tr></table></figure>
<h2 id="login-postgres"><a href="/2022/05/01/docker install postgresql/#login-postgres" class="headerlink" title="login postgres"></a>login postgres</h2><p>change postgres</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su postgres</span><br><span class="line">psql -U postgres -W</span><br><span class="line">password:</span><br><span class="line">psql (12.2....)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line">postgres=#</span><br></pre></td></tr></table></figure>
<h2 id="setting-remote-access"><a href="/2022/05/01/docker install postgresql/#setting-remote-access" class="headerlink" title="setting remote access"></a>setting remote access</h2><p>change file: pg_hba.conf   postgresql.conf</p>
<h3 id="1、change-pg-hba-conf"><a href="/2022/05/01/docker install postgresql/#1、change-pg-hba-conf" class="headerlink" title="1、change pg_hba.conf"></a>1、change pg_hba.conf</h3><p>copy pg_hba.conf to /home</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp postgres:/var/lib/postgresql/data/pg_hba.conf /home</span><br></pre></td></tr></table></figure>
<p>example</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local all all         trust</span><br><span class="line">host all all 127.0.0.1/32 trust</span><br><span class="line">*host all all 0.0.0.1/0 md5*</span><br><span class="line">host all all ::1/128 trust</span><br></pre></td></tr></table></figure>
<p>next copy to container change</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp /home/pg_hba.conf postgres:/var/lib/postgresql/data</span><br></pre></td></tr></table></figure>
<h3 id="2、change-postgresql-conf"><a href="/2022/05/01/docker install postgresql/#2、change-postgresql-conf" class="headerlink" title="2、change postgresql.conf"></a>2、change postgresql.conf</h3><p>change listen_addresses</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">listen_addresses=&apos;*&apos;</span><br></pre></td></tr></table></figure>
<p>exit container</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
<h2 id="shutdown-firewalld"><a href="/2022/05/01/docker install postgresql/#shutdown-firewalld" class="headerlink" title="shutdown firewalld"></a>shutdown firewalld</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status firewalld</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>
<h2 id="download-pgAdmin-client"><a href="/2022/05/01/docker install postgresql/#download-pgAdmin-client" class="headerlink" title="download pgAdmin client"></a>download pgAdmin client</h2><p> …</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>postgresql</tag>
      </tags>
  </entry>
  <entry>
    <title>centos6.8下PHP5.3.3升级到5.6</title>
    <url>/2017/09/30/centos6-8%E4%B8%8BPHP5-3-3%E5%8D%87%E7%BA%A7%E5%88%B05-6/</url>
    <content><![CDATA[<p>centos6.8的php预设5.3.3这个版本，其实对centos来说就是替换掉yum的资料库<br>分以下步骤進行<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm</span><br><span class="line">wget http://rpms.famillecollet.com/enterprise/remi-release-6.rpm</span><br><span class="line">sudo rpm -Uvh remi-release-6*.rpm epel-release-6*.rpm</span><br><span class="line">sudo vim /etc/yum.repos.d/remi.repo</span><br></pre></td></tr></table></figure></p>
<p>進去把所有的enabled参数改成1</p>
<p>yum –enablerepo=remi update php<em> mysql</em>  </p>
<p>最后再进行一次升级动作<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y update php*</span><br></pre></td></tr></table></figure></p>
<p>全部安装成功后确认一下：</p>
<p>yum list installed | grep php</p>
<p>最后重启服务</p>
<p>service httpd restart</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>docker redis sentinel高可用部署</title>
    <url>/2019/02/16/docker-redis-sentinel%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="docker-redis-sentinel高可用部署"><a href="/2019/02/16/docker-redis-sentinel高可用部署/#docker-redis-sentinel高可用部署" class="headerlink" title="docker redis sentinel高可用部署"></a>docker redis sentinel高可用部署</h3><p>目前来说，高可用(主从复制、主从切换)redis集群有两种方案。</p>
<ul>
<li>一种是redis-sentinel，只有一个master，各实例数据保持一致；</li>
<li>一种是redis-cluster，也叫分布式redis集群，可以有多个master，数据分片分布在这些master上。一种是redis-sentinel，只有一个master，各实例数据保持一致；</li>
</ul>
<p>本文基于docker和redis-sentinel的高可用redis集群搭建。</p>
<p><img src="https://clyhs.github.io/images/redis/redis01.png" alt="img"></p>
<p><em>单个redis-sentinel进程来监控redis集群是不可靠的，由于redis-sentinel本身也有single-point-of-failure-problem(单点问题)，当出现问题时整个redis集群系统将无法按照预期的方式切换主从。官方推荐：一个健康的集群部署，至少需要3个Sentinel实例。另外，redis-sentinel只需要配置监控redis master，而集群之间可以通过master相互通信。</em></p>
<p>分别有3个Sentinel节点，1个主节点，2个从节点组成一个Redis Sentinel集群。</p>
<table>
<thead>
<tr>
<th>name</th>
<th>ip</th>
<th>port</th>
</tr>
</thead>
<tbody>
<tr>
<td>redis-master</td>
<td>192.168.0.7</td>
<td>6300</td>
</tr>
<tr>
<td>redis-slave1</td>
<td>192.168.0.16</td>
<td>6301</td>
</tr>
<tr>
<td>redis-slave2</td>
<td>192.168.0.16</td>
<td>6302</td>
</tr>
<tr>
<td>sentinel1</td>
<td>192.168.0.7</td>
<td>26000</td>
</tr>
<tr>
<td>sentinel2</td>
<td>192.168.0.16</td>
<td>26001</td>
</tr>
<tr>
<td>sentinel3</td>
<td>192.168.0.16</td>
<td>26002</td>
</tr>
</tbody>
</table>
<h3 id="docker-部署redis"><a href="/2019/02/16/docker-redis-sentinel高可用部署/#docker-部署redis" class="headerlink" title="docker 部署redis"></a>docker 部署redis</h3><p>在192.168.0.7上运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --name redis-master --network host -d redis --appendonly yes --port 6300</span><br></pre></td></tr></table></figure>
<p>在192.168.0.16上运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --name redis-slave1 --network host -d redis --appendonly yes --port 6301 --slaveof 192.168.0.7 6300</span><br><span class="line"></span><br><span class="line">docker run -it --name redis-slave2 --network host -d redis --appendonly yes --port 6302 --slaveof 192.168.0.7 6300</span><br></pre></td></tr></table></figure>
<h3 id="搭建sentinel环境"><a href="/2019/02/16/docker-redis-sentinel高可用部署/#搭建sentinel环境" class="headerlink" title="搭建sentinel环境"></a>搭建sentinel环境</h3><h4 id="配置文件"><a href="/2019/02/16/docker-redis-sentinel高可用部署/#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>通过网络下载sentinel.conf文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/redis-stable/sentinel.conf</span><br></pre></td></tr></table></figure>
<p>下载到<strong>/app/app/</strong>目录下</p>
<p>并复制sentinel1.conf，sentinel2.conf，sentinel3.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mymaster:自定义集群名，如果需要监控多个redis集群，只需要配置多次并定义不同的&lt;master-name&gt; &lt;master-redis-ip&gt;:主库ip &lt;master-redis-port&gt;:主库port &lt;quorum&gt;:最小投票数，由于有三台redis-sentinel实例，所以可以设置成2</span><br><span class="line">sentinel monitor mymaster &lt;master-redis-ip&gt; &lt;master-redis-port&gt; &lt;quorum&gt;</span><br><span class="line">	</span><br><span class="line"># 注：redis主从库搭建的时候，要么都不配置密码(这样下面这句也不需要配置)，不然都需要设置成一样的密码</span><br><span class="line">sentinel auth-pass mymaster redispassword</span><br><span class="line">	</span><br><span class="line"># 添加后台运行</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure>
<p>内容如下：</p>
<p><strong>sentinel1.conf</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 26000</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/tmp&quot;</span><br><span class="line">sentinel monitor mymaster 192.168.0.7 6300 2</span><br><span class="line"></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>
<p><strong>sentinel2.conf</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 26001</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/tmp&quot;</span><br><span class="line">sentinel monitor mymaster 192.168.0.7 6300 2</span><br><span class="line"></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>
<p><strong>sentinel3.conf</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 26002</span><br><span class="line">daemonize yes</span><br><span class="line">dir &quot;/tmp&quot;</span><br><span class="line">sentinel monitor mymaster 192.168.0.7 6300 2</span><br><span class="line"></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure>
<h4 id="方法一"><a href="/2019/02/16/docker-redis-sentinel高可用部署/#方法一" class="headerlink" title="方法一"></a>方法一</h4><h5 id="搭建sentinel主节点"><a href="/2019/02/16/docker-redis-sentinel高可用部署/#搭建sentinel主节点" class="headerlink" title="搭建sentinel主节点"></a>搭建sentinel主节点</h5><p>在192.168.0.7上运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --name redis-sentinel1 --network host -v /app/app/sentinel1.conf:/usr/local/etc/redis/sentinel.conf -d redis /bin/bash</span><br></pre></td></tr></table></figure>
<h5 id="搭建sentinel从节点"><a href="/2019/02/16/docker-redis-sentinel高可用部署/#搭建sentinel从节点" class="headerlink" title="搭建sentinel从节点"></a>搭建sentinel从节点</h5><p>在192.168.0.16上运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --name redis-sentinel2 --network host -v /app/app/sentinel2.conf:/usr/local/etc/redis/sentinel.conf -d redis /bin/bash</span><br><span class="line"></span><br><span class="line">docker run -it --name redis-sentinel3 --network host -v /app/app/sentinel3.conf:/usr/local/etc/redis/sentinel.conf -d redis /bin/bash</span><br></pre></td></tr></table></figure>
<p><em>分别进入以上三个容器启动redis-sentinel：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it redis-sentinel(x) bash</span><br><span class="line">redis-sentinel /usr/local/etc/redis/sentinel.conf</span><br><span class="line">或</span><br><span class="line">redis-server /usr/local/etc/redis/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>
<h4 id="方法二"><a href="/2019/02/16/docker-redis-sentinel高可用部署/#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>也可以一步完成，在/app/app/建目录sentinel01,sentinel02,sentinel03,目录结构如*</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel01/data</span><br><span class="line">          /conf/sentinel1.conf</span><br><span class="line">sentinel02/data</span><br><span class="line">          /conf/sentinel2.conf</span><br><span class="line">sentinel03/data</span><br><span class="line">          /conf/sentinel3.conf</span><br></pre></td></tr></table></figure>
<p><em>然后依次执行</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --network host --name sentinel1 \</span><br><span class="line">-v /app/app/sentinel01/data:/var/redis/data \</span><br><span class="line">-v /app/app/sentinel01/conf:/usr/local/etc/redis/sentinel.conf \</span><br><span class="line">redis \ </span><br><span class="line">/usr/local/etc/redis/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>
<h4 id="查询是否成功"><a href="/2019/02/16/docker-redis-sentinel高可用部署/#查询是否成功" class="headerlink" title="查询是否成功"></a>查询是否成功</h4><p>在192.168.0.7或192.168.0.16上执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -p 26000或26001、26002</span><br><span class="line">sentinel master mymaster或sentinel slaves mymaster</span><br><span class="line"></span><br><span class="line">如下：</span><br><span class="line">[root@centoss2 app]# redis-cli -p 26000</span><br><span class="line">127.0.0.1:26000&gt; sentinel master mymaster</span><br><span class="line"> 1) &quot;name&quot;</span><br><span class="line"> 2) &quot;mymaster&quot;</span><br><span class="line"> 3) &quot;ip&quot;</span><br><span class="line"> 4) &quot;192.168.0.7&quot;</span><br><span class="line"> 5) &quot;port&quot;</span><br><span class="line"> 6) &quot;6300&quot;</span><br><span class="line"> 7) &quot;runid&quot;</span><br><span class="line"> 8) &quot;f2eee0697508217b9dbd151feca340587aee87d7&quot;</span><br><span class="line"> 9) &quot;flags&quot;</span><br><span class="line">10) &quot;master&quot;</span><br><span class="line">11) &quot;link-pending-commands&quot;</span><br><span class="line">12) &quot;0&quot;</span><br><span class="line">13) &quot;link-refcount&quot;</span><br><span class="line">14) &quot;1&quot;</span><br><span class="line">15) &quot;last-ping-sent&quot;</span><br><span class="line">16) &quot;0&quot;</span><br><span class="line">17) &quot;last-ok-ping-reply&quot;</span><br><span class="line">18) &quot;395&quot;</span><br><span class="line">19) &quot;last-ping-reply&quot;</span><br><span class="line">20) &quot;395&quot;</span><br><span class="line">21) &quot;down-after-milliseconds&quot;</span><br><span class="line">22) &quot;30000&quot;</span><br><span class="line">23) &quot;info-refresh&quot;</span><br><span class="line">24) &quot;2598&quot;</span><br><span class="line">25) &quot;role-reported&quot;</span><br><span class="line">26) &quot;master&quot;</span><br><span class="line">27) &quot;role-reported-time&quot;</span><br><span class="line">28) &quot;62813&quot;</span><br><span class="line">29) &quot;config-epoch&quot;</span><br><span class="line">30) &quot;0&quot;</span><br><span class="line">31) &quot;num-slaves&quot;</span><br><span class="line">32) &quot;2&quot;</span><br><span class="line">33) &quot;num-other-sentinels&quot;</span><br><span class="line">34) &quot;1&quot;</span><br><span class="line">35) &quot;quorum&quot;</span><br><span class="line">36) &quot;2&quot;</span><br><span class="line">37) &quot;failover-timeout&quot;</span><br><span class="line">38) &quot;180000&quot;</span><br><span class="line">39) &quot;parallel-syncs&quot;</span><br><span class="line">40) &quot;1&quot;</span><br></pre></td></tr></table></figure>
<p><em>参考：<a href="https://blog.csdn.net/OneZhous/article/details/80679352" target="_blank" rel="noopener">https://blog.csdn.net/OneZhous/article/details/80679352</a></em></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>docker redis cluster集群部署</title>
    <url>/2019/02/18/docker-redis-cluster%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="docker部署redis集群"><a href="/2019/02/18/docker-redis-cluster集群部署/#docker部署redis集群" class="headerlink" title="docker部署redis集群"></a>docker部署redis集群</h3><p>用两台虚拟机模拟6个节点，一台机器3个节点，创建出3 master、3 salve 环境。</p>
<table>
<thead>
<tr>
<th>name</th>
<th>ip</th>
<th>port</th>
<th>remark</th>
</tr>
</thead>
<tbody>
<tr>
<td>redis1</td>
<td>192.168.0.16</td>
<td>8001</td>
<td>master</td>
</tr>
<tr>
<td>redis2</td>
<td>192.168.0.16</td>
<td>8002</td>
<td>master</td>
</tr>
<tr>
<td>redis3</td>
<td>192.168.0.16</td>
<td>8003</td>
<td>master</td>
</tr>
<tr>
<td>redis4</td>
<td>192.168.0.7</td>
<td>8004</td>
<td>slave</td>
</tr>
<tr>
<td>redis5</td>
<td>192.168.0.7</td>
<td>8005</td>
<td>slave</td>
</tr>
<tr>
<td>redis6</td>
<td>192.168.0.7</td>
<td>8006</td>
<td>slave</td>
</tr>
</tbody>
</table>
<h4 id="准备镜像"><a href="/2019/02/18/docker-redis-cluster集群部署/#准备镜像" class="headerlink" title="准备镜像"></a>准备镜像</h4><p>publicisworldwide/redis-cluster:latest</p>
<p>inem0o/redis-trib:latest</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull publicisworldwide/redis-cluster</span><br><span class="line">docker pull inem0o/redis-trib</span><br></pre></td></tr></table></figure>
<h4 id="新建容器"><a href="/2019/02/18/docker-redis-cluster集群部署/#新建容器" class="headerlink" title="新建容器"></a>新建容器</h4><p>在192.168.0.16新建/app/app/redis/docker-compose.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /app/app/redis/docker-compose.yml</span><br><span class="line"></span><br><span class="line">version: &apos;3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"> redis1:</span><br><span class="line">  image: publicisworldwide/redis-cluster</span><br><span class="line">  network_mode: host</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8001/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8001</span><br><span class="line"></span><br><span class="line"> redis2:</span><br><span class="line">  image: publicisworldwide/redis-cluster</span><br><span class="line">  network_mode: host</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8002/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8002</span><br><span class="line"></span><br><span class="line"> redis3:</span><br><span class="line">  image: publicisworldwide/redis-cluster</span><br><span class="line">  network_mode: host</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8003/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8003</span><br></pre></td></tr></table></figure>
<p>在192.168.0.7新建/app/app/redis/docker-compose.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /app/app/redis/docker-compose.yml</span><br><span class="line"></span><br><span class="line">version: &apos;3&apos;</span><br><span class="line"> redis4:</span><br><span class="line">  image: publicisworldwide/redis-cluster</span><br><span class="line">  network_mode: host</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8004/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8004</span><br><span class="line"></span><br><span class="line"> redis5:</span><br><span class="line">  image: publicisworldwide/redis-cluster</span><br><span class="line">  network_mode: host</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8005/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8005</span><br><span class="line"></span><br><span class="line"> redis6:</span><br><span class="line">  image: publicisworldwide/redis-cluster</span><br><span class="line">  network_mode: host</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8006/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8006</span><br></pre></td></tr></table></figure>
<p><em>若同一台宿主机，不想使用host模式同一台，也可以把network_mode去掉，但就要加ports映射。<br>redis-cluster的节点端口共分为2种，一种是节点提供服务的端口，如6379；一种是节点间通信的端口，固定格式为：10000+6379。</em></p>
<p><em>如:</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose.yml</span><br><span class="line"></span><br><span class="line">version: &apos;3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"> redis1:</span><br><span class="line">  image: publicisworldwide/redis-cluster</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8001/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8001</span><br><span class="line">  ports:</span><br><span class="line">    - &apos;8001:8001&apos;</span><br><span class="line">    - &apos;18001:18001&apos;</span><br><span class="line">    </span><br><span class="line"> redis2:</span><br><span class="line">  image: publicisworldwide/redis-cluster</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8002/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8002</span><br><span class="line">  ports:</span><br><span class="line">    - &apos;8002:8002&apos;</span><br><span class="line">    - &apos;18002:18002&apos;</span><br><span class="line">    </span><br><span class="line"> redis3:</span><br><span class="line">  image: publicisworldwide/redis-cluster</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8003/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8003</span><br><span class="line">  ports:</span><br><span class="line">    - &apos;8003:8003&apos;</span><br><span class="line">    - &apos;18003:18003&apos;</span><br><span class="line">    </span><br><span class="line"> redis4:</span><br><span class="line">  image: publicisworldwide/redis-cluster</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8004/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8004</span><br><span class="line">  ports:</span><br><span class="line">    - &apos;8004:8004&apos;</span><br><span class="line">    - &apos;18004:18004&apos;</span><br><span class="line">    </span><br><span class="line"> redis5:</span><br><span class="line">  image: publicisworldwide/redis-cluster</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8005/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8005</span><br><span class="line">  ports:</span><br><span class="line">    - &apos;8005:8005&apos;</span><br><span class="line">    - &apos;18005:18005&apos;</span><br><span class="line">    </span><br><span class="line"> redis6:</span><br><span class="line">  image: publicisworldwide/redis-cluster</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8006/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8006</span><br><span class="line">  ports:</span><br><span class="line">    - &apos;8006:8006&apos;</span><br><span class="line">    - &apos;18006:18006&apos;</span><br></pre></td></tr></table></figure>
<h4 id="直接启动服务"><a href="/2019/02/18/docker-redis-cluster集群部署/#直接启动服务" class="headerlink" title="直接启动服务"></a>直接启动服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">窗口模式</span><br><span class="line">docker-compose up</span><br><span class="line">后台进程</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p><em>以上镜像不能设置永久密码，其实redis一般是内网访问，可以不需密码。</em></p>
<h4 id="redis容器集群配置"><a href="/2019/02/18/docker-redis-cluster集群部署/#redis容器集群配置" class="headerlink" title="redis容器集群配置"></a>redis容器集群配置</h4><h5 id="方法一、直接启动"><a href="/2019/02/18/docker-redis-cluster集群部署/#方法一、直接启动" class="headerlink" title="方法一、直接启动"></a>方法一、直接启动</h5><p>不指定master</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm -it inem0o/redis-trib create --replicas 1 192.168.0.16:8001 192.168.0.16:8002 192.168.0.16:8003 192.168.0.7:8004 192.168.0.7:8005 192.168.0.7:8006</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</span><br><span class="line">Using 3 masters:</span><br><span class="line">192.168.0.16:8001</span><br><span class="line">192.168.0.16:8002</span><br><span class="line">192.168.0.16:8003</span><br><span class="line">Adding replica 192.168.0.7:8004 to 192.168.0.16:8001</span><br><span class="line">Adding replica 192.168.0.7:8005 to 192.168.0.16:8002</span><br><span class="line">Adding replica 192.168.0.7:8006 to 192.168.0.16:8003</span><br><span class="line">M: 0e594d4e46fef74366c0ce9f43f5d805af3bf639 192.168.0.16:8001</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">M: 0f86275fa7a965295153206c872d901d28461e6b 192.168.0.16:8002</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">M: 25b5951be791956cc8aa7b93b8cecda25927d0f4 192.168.0.16:8003</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">S: 9bd2ee334963a472a7ae183d69133c0cc0ede8d8 192.168.0.7:8004</span><br><span class="line">   replicates 0e594d4e46fef74366c0ce9f43f5d805af3bf639</span><br><span class="line">S: 2bd8d9a3e24b142d19bb4922f5aace9e60b9a16f 192.168.0.7:8005</span><br><span class="line">   replicates 0f86275fa7a965295153206c872d901d28461e6b</span><br><span class="line">S: c844c9277b34f685fc979dcdb47a1e71011a185a 192.168.0.7:8006</span><br><span class="line">   replicates 25b5951be791956cc8aa7b93b8cecda25927d0f4</span><br><span class="line">Can I set the above configuration? (type &apos;yes&apos; to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting for the cluster to join...</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.0.16:8001)</span><br><span class="line">M: 0e594d4e46fef74366c0ce9f43f5d805af3bf639 192.168.0.16:8001</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 25b5951be791956cc8aa7b93b8cecda25927d0f4 192.168.0.16:8003@18003</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 9bd2ee334963a472a7ae183d69133c0cc0ede8d8 192.168.0.7:8004@18004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 0e594d4e46fef74366c0ce9f43f5d805af3bf639</span><br><span class="line">S: 2bd8d9a3e24b142d19bb4922f5aace9e60b9a16f 192.168.0.7:8005@18005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 0f86275fa7a965295153206c872d901d28461e6b</span><br><span class="line">M: 0f86275fa7a965295153206c872d901d28461e6b 192.168.0.16:8002@18002</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: c844c9277b34f685fc979dcdb47a1e71011a185a 192.168.0.7:8006@18006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 25b5951be791956cc8aa7b93b8cecda25927d0f4</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>
<h5 id="方法二、指定master"><a href="/2019/02/18/docker-redis-cluster集群部署/#方法二、指定master" class="headerlink" title="方法二、指定master"></a>方法二、指定master</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm -it inem0o/redis-trib create  192.168.0.16:8001 192.168.0.16:8002 192.168.0.16:8003</span><br><span class="line"></span><br><span class="line">检查集群</span><br><span class="line"></span><br><span class="line">docker run --rm -it inem0o/redis-trib check 192.168.0.16:8001</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.0.16:8001)</span><br><span class="line">M: dbb6b214215f70b6a9e7ce150d1898ebadbf90fc 192.168.0.16:8001</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   0 additional replica(s)</span><br><span class="line">M: 6915f5f4bb5df77c72a943a5afb1b619bdc0d937 192.168.0.16:8002@18002</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   0 additional replica(s)</span><br><span class="line">M: d80ee99cea1a6050a16fee952b012df455b2fb07 192.168.0.16:8003@18003</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   0 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>
<p>添加从节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm -it inem0o/redis-trib add-node --slave --master-id dbb6b214215f70b6a9e7ce150d1898ebadbf90fc 192.168.0.7:8004 192.168.0.16:8001</span><br><span class="line"></span><br><span class="line">docker run --rm -it inem0o/redis-trib add-node --slave --master-id 6915f5f4bb5df77c72a943a5afb1b619bdc0d937 192.168.0.7:8005 192.168.0.16:8002</span><br><span class="line"></span><br><span class="line">docker run --rm -it inem0o/redis-trib add-node --slave --master-id d80ee99cea1a6050a16fee952b012df455b2fb07 192.168.0.7:8006 192.168.0.16:8003</span><br><span class="line"></span><br><span class="line">查询三个主节点，都有一个从节点</span><br><span class="line"></span><br><span class="line">docker run --rm -it inem0o/redis-trib info 192.168.0.16:8001</span><br><span class="line">192.168.0.16:8001 (dbb6b214...) -&gt; 0 keys | 5461 slots | 1 slaves.</span><br><span class="line">192.168.0.16:8002@18002 (6915f5f4...) -&gt; 0 keys | 5462 slots | 1 slaves.</span><br><span class="line">192.168.0.16:8003@18003 (d80ee99c...) -&gt; 0 keys | 5461 slots | 1 slaves.</span><br><span class="line">[OK] 0 keys in 3 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br></pre></td></tr></table></figure>
<h4 id="查看redis-trib使用"><a href="/2019/02/18/docker-redis-cluster集群部署/#查看redis-trib使用" class="headerlink" title="查看redis-trib使用"></a>查看redis-trib使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm -it inem0o/redis-trib help</span><br></pre></td></tr></table></figure>
<p><em>1、create：创建集群<br>2、check：检查集群<br>3、info：查看集群信息<br>4、fix：修复集群<br>5、reshard：在线迁移slot<br>6、rebalance：平衡集群节点slot数量<br>7、add-node：将新节点加入集群<br>8、del-node：从集群中删除节点<br>9、set-timeout：设置集群节点间心跳连接的超时时间<br>10、call：在集群全部节点上执行命令<br>11、import：将外部redis数据导入集群</em></p>
<h3 id="自己创建镜像"><a href="/2019/02/18/docker-redis-cluster集群部署/#自己创建镜像" class="headerlink" title="自己创建镜像"></a>自己创建镜像</h3><h4 id="准备脚本"><a href="/2019/02/18/docker-redis-cluster集群部署/#准备脚本" class="headerlink" title="准备脚本"></a>准备脚本</h4><p>/app/app/redis/entrypoint.sh</p>
<p>vi entrypoint.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#只作用于当前进程,不作用于其创建的子进程</span><br><span class="line">set -e</span><br><span class="line">#$0--Shell本身的文件名 $1--第一个参数 $@--所有参数列表</span><br><span class="line"># allow the container to be started with `--user`</span><br><span class="line">if [ &quot;$1&quot; = &apos;redis-server&apos; -a &quot;$(id -u)&quot; = &apos;0&apos; ]; then</span><br><span class="line">    sed -i &apos;s/REDIS_PORT/&apos;$REDIS_PORT&apos;/g&apos; /usr/local/etc/redis.conf</span><br><span class="line">    chown -R redis .  #改变当前文件所有者</span><br><span class="line">    exec gosu redis &quot;$0&quot; &quot;$@&quot;  #gosu是sudo轻量级”替代品”</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec &quot;$@&quot;</span><br></pre></td></tr></table></figure>
<p>/app/app/redis/redis.conf</p>
<p>vi redis.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#端口</span><br><span class="line">port REDIS_PORT</span><br><span class="line">#开启集群</span><br><span class="line">cluster-enabled yes</span><br><span class="line">#配置文件</span><br><span class="line">cluster-config-file nodes.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">#更新操作后进行日志记录</span><br><span class="line">appendonly yes</span><br><span class="line">#设置主服务的连接密码</span><br><span class="line"># masterauth</span><br><span class="line">#设置从服务的连接密码</span><br><span class="line"># requirepass</span><br></pre></td></tr></table></figure>
<ul>
<li>requirepass和masterauth不能启用，否则redis-trib创建集群失败。</li>
<li>protected-mode 保护模式是禁止公网访问，但是不能设置密码和bind ip。</li>
</ul>
<p>编写Dockerfile文件</p>
<p>/app/app/redis/Dockerfile</p>
<p>vi Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#基础镜像</span><br><span class="line">FROM redis</span><br><span class="line">#修复时区</span><br><span class="line">RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">RUN echo &apos;Asia/Shanghai&apos; &gt;/etc/timezone</span><br><span class="line">#环境变量</span><br><span class="line">ENV REDIS_PORT 8000</span><br><span class="line">#ENV REDIS_PORT_NODE 18000</span><br><span class="line">#暴露变量</span><br><span class="line">EXPOSE $REDIS_PORT</span><br><span class="line">#EXPOSE $REDIS_PORT_NODE</span><br><span class="line">#复制</span><br><span class="line">COPY entrypoint.sh /usr/local/bin/</span><br><span class="line">COPY redis.conf /usr/local/etc/</span><br><span class="line">#for config rewrite</span><br><span class="line">RUN chmod 777 /usr/local/etc/redis.conf</span><br><span class="line">RUN chmod +x /usr/local/bin/entrypoint.sh</span><br><span class="line">#入口</span><br><span class="line">ENTRYPOINT [&quot;/usr/local/bin/entrypoint.sh&quot;]</span><br><span class="line">#命令</span><br><span class="line">CMD [&quot;redis-server&quot;, &quot;/usr/local/etc/redis.conf&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="创建镜像"><a href="/2019/02/18/docker-redis-cluster集群部署/#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /app/app/redis</span><br><span class="line">docker build -t pascloud/redis-cluster:1.0 .</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 4.608 kB</span><br><span class="line">Step 1/11 : FROM redis</span><br><span class="line"> ---&gt; 0f55cf3661e9</span><br><span class="line">Step 2/11 : RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"> ---&gt; Running in 5aa77cdb9d96</span><br><span class="line"> ---&gt; 67c21c2f65cc</span><br><span class="line">Removing intermediate container 5aa77cdb9d96</span><br><span class="line">Step 3/11 : RUN echo &apos;Asia/Shanghai&apos; &gt;/etc/timezone</span><br><span class="line"> ---&gt; Running in b08571fcaca3</span><br><span class="line"> ---&gt; 75c88a71c3e2</span><br><span class="line">Removing intermediate container b08571fcaca3</span><br><span class="line">Step 4/11 : ENV REDIS_PORT 8000</span><br><span class="line"> ---&gt; Running in 264dd35607f9</span><br><span class="line"> ---&gt; 237723740c53</span><br><span class="line">Removing intermediate container 264dd35607f9</span><br><span class="line">Step 5/11 : EXPOSE $REDIS_PORT</span><br><span class="line"> ---&gt; Running in 3ec733186488</span><br><span class="line"> ---&gt; d44c858fd07a</span><br><span class="line">Removing intermediate container 3ec733186488</span><br><span class="line">Step 6/11 : COPY entrypoint.sh /usr/local/bin/</span><br><span class="line"> ---&gt; 53cc6f8e9979</span><br><span class="line">Removing intermediate container 253c851483a9</span><br><span class="line">Step 7/11 : COPY redis.conf /usr/local/etc/</span><br><span class="line"> ---&gt; 849df9aace37</span><br><span class="line">Removing intermediate container 1cb7033269a5</span><br><span class="line">Step 8/11 : RUN chmod 777 /usr/local/etc/redis.conf</span><br><span class="line"> ---&gt; Running in c755b51d08ef</span><br><span class="line"> ---&gt; 232eff722727</span><br><span class="line">Removing intermediate container c755b51d08ef</span><br><span class="line">Step 9/11 : RUN chmod +x /usr/local/bin/entrypoint.sh</span><br><span class="line"> ---&gt; Running in ec35a6c8b212</span><br><span class="line"> ---&gt; 555f5497fb9c</span><br><span class="line">Removing intermediate container ec35a6c8b212</span><br><span class="line">Step 10/11 : ENTRYPOINT /usr/local/bin/entrypoint.sh</span><br><span class="line"> ---&gt; Running in 8b0dd921d40a</span><br><span class="line"> ---&gt; c377c55da021</span><br><span class="line">Removing intermediate container 8b0dd921d40a</span><br><span class="line">Step 11/11 : CMD redis-server /usr/local/etc/redis.conf</span><br><span class="line"> ---&gt; Running in 080d23a389c3</span><br><span class="line"> ---&gt; d281c0f4ded9</span><br><span class="line">Removing intermediate container 080d23a389c3</span><br><span class="line">Successfully built d281c0f4ded9</span><br></pre></td></tr></table></figure>
<h4 id="创建网络"><a href="/2019/02/18/docker-redis-cluster集群部署/#创建网络" class="headerlink" title="创建网络"></a>创建网络</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create redis-cluster-net</span><br></pre></td></tr></table></figure>
<h4 id="编写docker-compose-yml"><a href="/2019/02/18/docker-redis-cluster集群部署/#编写docker-compose-yml" class="headerlink" title="编写docker-compose.yml"></a>编写docker-compose.yml</h4><p>在192.168.0.16新建/app/app/redis/docker-compose.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"> redis1:</span><br><span class="line">  image: pascloud/redis-cluster:1.0</span><br><span class="line">  network_mode: host</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8001/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8001</span><br><span class="line">    </span><br><span class="line"> redis2:</span><br><span class="line">  image: pascloud/redis-cluster:1.0</span><br><span class="line">  network_mode: host</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8002/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8002</span><br><span class="line">    </span><br><span class="line"> redis3:</span><br><span class="line">  image: pascloud/redis-cluster:1.0</span><br><span class="line">  network_mode: host</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8003/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8003</span><br></pre></td></tr></table></figure>
<p>在192.168.0.7新建/app/app/redis/docker-compose.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"> redis4:</span><br><span class="line">  image: pascloud/redis-cluster:1.0</span><br><span class="line">  network_mode: host</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8004/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8004</span><br><span class="line">    </span><br><span class="line"> redis5:</span><br><span class="line">  image: pascloud/redis-cluster:1.0</span><br><span class="line">  network_mode: host</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8005/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8005</span><br><span class="line">    </span><br><span class="line"> redis6:</span><br><span class="line">  image: pascloud/redis-cluster:1.0</span><br><span class="line">  network_mode: host</span><br><span class="line">  restart: always</span><br><span class="line">  volumes:</span><br><span class="line">   - /app/app/redis/8006/data:/data</span><br><span class="line">  environment:</span><br><span class="line">   - REDIS_PORT=8006</span><br></pre></td></tr></table></figure>
<h4 id="启动"><a href="/2019/02/18/docker-redis-cluster集群部署/#启动" class="headerlink" title="启动"></a>启动</h4><p>分别在16和07上执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
<p>在16上执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm -it inem0o/redis-trib create --replicas 1 192.168.0.16:8001 192.168.0.16:8002 192.168.0.16:8003 192.168.0.7:8004 192.168.0.7:8005 192.168.0.7:8006</span><br></pre></td></tr></table></figure>
<p><strong>设置集群密码</strong></p>
<p>分别通过端口设置密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost src]# ./redis-cli -c -p 8001(8002...8006)</span><br><span class="line">127.0.0.1:8001&gt; config set masterauth 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:8001&gt; config set requirepass 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:8001&gt; config rewrite</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:8001&gt; auth 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:8001&gt; config rewrite</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p><strong>查看密码文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it 容器ID /bin/bash</span><br><span class="line">cat /usr/local/etc/redis.conf</span><br><span class="line"></span><br><span class="line">root@centoss1:/data# cat /usr/local/etc/redis.conf</span><br><span class="line">#端口</span><br><span class="line">port 8002</span><br><span class="line">#开启集群</span><br><span class="line">cluster-enabled yes</span><br><span class="line">#配置文件</span><br><span class="line">cluster-config-file &quot;nodes.conf&quot;</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">#更新操作后进行日志记录</span><br><span class="line">appendonly yes</span><br><span class="line">#设置主服务的连接密码</span><br><span class="line"># masterauth</span><br><span class="line">#设置从服务的连接密码</span><br><span class="line"># requirepass</span><br><span class="line"># Generated by CONFIG REWRITE</span><br><span class="line">dir &quot;/data&quot;</span><br><span class="line">masterauth &quot;123456&quot;</span><br><span class="line">requirepass &quot;123456&quot;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>docker一些常见问题处理</title>
    <url>/2019/07/12/docker%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="docker常见问题"><a href="/2019/07/12/docker一些常见问题处理/#docker常见问题" class="headerlink" title="docker常见问题"></a>docker常见问题</h3><p>1、docker启动后发现端口是<em>tcp6</em>的，无法访问，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp6       0      0 :::3306                 :::*                    LISTEN      9863/docker-proxy</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<p>配置/etc/sysctl.conf，添加以下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#开户ipv4路由转发</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">#关闭ipv6</span><br><span class="line">net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class="line">net.ipv6.conf.default.disable_ipv6 = 1</span><br></pre></td></tr></table></figure>
<p>让参数生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<p>重启docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>重启docker服务就可以解决。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker与iptables之间的网络通信</title>
    <url>/2019/05/30/docker%E4%B8%8Eiptables%E4%B9%8B%E9%97%B4%E7%9A%84%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h3 id="docker的几种网络模式"><a href="/2019/05/30/docker与iptables之间的网络通信/#docker的几种网络模式" class="headerlink" title="docker的几种网络模式"></a>docker的几种网络模式</h3><ul>
<li>（1）host：与主机公共同一网络（network namespqce），器将不会虚拟出自己的网卡，配置自己的ip，而是使用宿主机的ip和端口</li>
<li>（2）container：指和已经存在的一个容器共享一个network namespaces，那两个容器除了网络方面，其它的资源还是隔离的，两个容器的进程可以通过lo网卡设备通信。</li>
<li>（3）none：拥有自己的network namespaces，但是docker进行任何网络配置，需要我们自己为docker容器添加网络、配置ip</li>
<li>（4）bridge：默认的网络设置，此模式会为每个容器分配network namespace、设置ip等，并将一个主机的docker容器连接到一个虚拟网络上</li>
</ul>
<p>当docker deamon 启动的时候会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似。</p>
<p>容器发包出去的过程：ip包会从container发往自己默认的网关docker0，到包到达docker0时就时到达了主机，这时候会查询主机的路由表，发现包应该从主机的网卡eth0出去，如下的iptables的规则就起作用，对包做nat转换，将原地址转成eth0的地址，这样对于外部来说docker容器就是不可见的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</span><br></pre></td></tr></table></figure>
<h3 id="启动容器报错"><a href="/2019/05/30/docker与iptables之间的网络通信/#启动容器报错" class="headerlink" title="启动容器报错"></a>启动容器报错</h3><p>当关闭了iptables之后，再启动带端口映射的容器会报如下错误，内容的意思是容器添加iptables规则失败。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker: Error response from daemon: driver failed programming external connectivity on endpoint happy_ptolemy (9cedc114be35eb86cd6f7f7bb4f11f93b5f8d2c0745afc72664cef8e96aad439): iptables failed: iptables --wait -t filter -A DOCKER ! -i docker0 -o docker0 -p tcp -d 172.17.0.2 --dport 3000 -j ACCEPT: iptables: No chain/target/match by that name.</span><br><span class="line"></span><br><span class="line">(exit status 1).</span><br></pre></td></tr></table></figure>
<p>这种情况重启docker就好了。原因是docker在启动过程中会将一些docker网络需要的规则写入iptables表，生产环境不能总是靠重启来解决问题。docker daemon启动过程会初始化一系列的iptables规则以及修改部分内核参数。</p>
<p>启动docker前iptables的规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> Generated by iptables-save</span><br><span class="line"></span><br><span class="line">*filter</span><br><span class="line"></span><br><span class="line">:INPUT ACCEPT [87:6944]</span><br><span class="line"></span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line"></span><br><span class="line">:OUTPUT ACCEPT [69:7184]</span><br><span class="line"></span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>
<p>重启docker后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> </span><br><span class="line"></span><br><span class="line">*nat</span><br><span class="line"></span><br><span class="line">:PREROUTING ACCEPT [32:1280]</span><br><span class="line"></span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line"></span><br><span class="line">:OUTPUT ACCEPT [2:283]</span><br><span class="line"></span><br><span class="line">:POSTROUTING ACCEPT [2:283]</span><br><span class="line"></span><br><span class="line">:DOCKER - [0:0]</span><br><span class="line"></span><br><span class="line">-A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER</span><br><span class="line"></span><br><span class="line">-A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER</span><br><span class="line"></span><br><span class="line">-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</span><br><span class="line"></span><br><span class="line">-A DOCKER -i docker0 -j RETURN</span><br><span class="line"></span><br><span class="line">COMMIT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> </span><br><span class="line"></span><br><span class="line">*filter</span><br><span class="line"></span><br><span class="line">:INPUT ACCEPT [107:8246]</span><br><span class="line"></span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line"></span><br><span class="line">:OUTPUT ACCEPT [88:11662]</span><br><span class="line"></span><br><span class="line">:DOCKER - [0:0]</span><br><span class="line"></span><br><span class="line">:DOCKER-ISOLATION - [0:0]</span><br><span class="line"></span><br><span class="line">-A FORWARD -j DOCKER-ISOLATION</span><br><span class="line"></span><br><span class="line">-A FORWARD -o docker0 -j DOCKER</span><br><span class="line"></span><br><span class="line">-A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A FORWARD -i docker0 ! -o docker0 -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A FORWARD -i docker0 -o docker0 -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A DOCKER-ISOLATION -j RETURN</span><br><span class="line"></span><br><span class="line">COMMIT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<h3 id="ipv4转发被关闭"><a href="/2019/05/30/docker与iptables之间的网络通信/#ipv4转发被关闭" class="headerlink" title="ipv4转发被关闭"></a>ipv4转发被关闭</h3><p>Docker容器启动报WARNING: IPv4 forwarding is disabled. Networking will not work </p>
<p>将/etc/sysctl中的net.ipv4.ip_forward改为1，重启network就可以了。</p>
<p><em>参考：<a href="https://www.jianshu.com/p/5e941739196d" target="_blank" rel="noopener">https://www.jianshu.com/p/5e941739196d</a></em></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker与jenkins搭建持续集成</title>
    <url>/2019/06/26/docker%E4%B8%8Ejenkins%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h3 id="环境"><a href="/2019/06/26/docker与jenkins搭建持续集成/#环境" class="headerlink" title="环境"></a>环境</h3><table>
<thead>
<tr>
<th>服务器</th>
<th>软件</th>
</tr>
</thead>
<tbody>
<tr>
<td>192.168.0.7</td>
<td>docker,git,registry,jenkins</td>
</tr>
<tr>
<td>192.168.0.16</td>
<td>docker</td>
</tr>
</tbody>
</table>
<h3 id="安装docker和git"><a href="/2019/06/26/docker与jenkins搭建持续集成/#安装docker和git" class="headerlink" title="安装docker和git"></a>安装docker和git</h3><p><strong>192.168.0.7,192.168.0.16</strong>(先自行安装docker,git)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker</span><br><span class="line">yum install git</span><br></pre></td></tr></table></figure>
<p>离线安装git需要以下安装包</p>
<p>   perl-Error-1:0.17020-2.el7<br>   perl-TermReadKey-2.30-20.el7<br>   perl-Git-1.8.3.1-19.el7<br>   git-1.8.3.1-19.el7 </p>
<p>在192.168.0.7上创建git</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建git用户</span><br><span class="line">useradd git</span><br><span class="line">passwd git</span><br><span class="line">#创建mytest项目</span><br><span class="line">su - git</span><br><span class="line">mkdir mytest.git</span><br><span class="line">cd mytest.git/</span><br><span class="line">git --bare init</span><br></pre></td></tr></table></figure>
<p>在192.168.0.16上执行，可以克隆</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@192.168.0.7:/home/git/mytest.git</span><br></pre></td></tr></table></figure>
<h3 id="jenkins安装"><a href="/2019/06/26/docker与jenkins搭建持续集成/#jenkins安装" class="headerlink" title="jenkins安装"></a>jenkins安装</h3><p>在192.168.0.7上安装jenkins         </p>
<p>下载jenkins包</p>
<p>地址：<a href="http://mirrors.jenkins.io/war-stable/latest/jenkins.war" target="_blank" rel="noopener">http://mirrors.jenkins.io/war-stable/latest/jenkins.war</a> </p>
<p>部署到tomcat/webapps里面，清掉webapps里面自带目录，把jenkins.war 改成ROOT.war</p>
<p>如：/home/domains/tomcat/webapps/ROOT.war</p>
<p>或者直接DOCKER部署</p>
<p> docker pull jenkins/jenkins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name jenkins -p 8888:8080 -p 50000:50000 -v /home/domains/jenkins_home:/var/jenkins_home jenkins/jenkins</span><br></pre></td></tr></table></figure>
<p>查看日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f jenkins</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/jenkins/01.png" alt="img"></p>
<p>找到启动输入的password复制</p>
<p>打开http://{ip}:8888/ 输入password</p>
<p><img src="https://clyhs.github.io/images/jenkins/02.png" alt="img"></p>
<p>选择推荐安装插件。</p>
<p>创建第一个管理员。</p>
<p><img src="https://clyhs.github.io/images/jenkins/03.png" alt="img"></p>
<p>可以通过<a href="http://{ip}:8888/login?from=%2F" target="_blank" rel="noopener">http://{ip}:8888/login?from=%2F</a>           登录</p>
<p>登录后发现空白，可能是权限问题，解决方法：把映射的目录权限改为777，重启服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop jenkins</span><br><span class="line">chmod -R 777 /home/domains/jenkins_home/</span><br><span class="line">docker start jenkins</span><br></pre></td></tr></table></figure>
<h3 id="部署私有镜像仓库"><a href="/2019/06/26/docker与jenkins搭建持续集成/#部署私有镜像仓库" class="headerlink" title="部署私有镜像仓库"></a>部署私有镜像仓库</h3><p>在192.168.0.7上安装docker私有仓库    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -v /home/domains/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure>
<p>在192.168.0.16、192.168.0.7添加http信任</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br><span class="line">#加入</span><br><span class="line">&#123;&quot;insecure-registries&quot;:[&quot;192.168.0.7:5000&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p>重启docker:systemctl restart docker</p>
<p>然后找一个镜像，重新打一个与标签</p>
<p>这里用nginx:1.15.8</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag nginx:1.15.8 192.168.0.7:5000/nginx:1.15.8</span><br><span class="line">docker push 192.168.0.7:5000/nginx:1.15.8</span><br></pre></td></tr></table></figure>
<p>可以在192.168.0.7的/home/domains/registry看到生成一个docker目录，存放刚才push进去的镜像。</p>
<h3 id="Jenkins配置全局工具配置"><a href="/2019/06/26/docker与jenkins搭建持续集成/#Jenkins配置全局工具配置" class="headerlink" title="Jenkins配置全局工具配置"></a>Jenkins配置全局工具配置</h3><p>系统管理-&gt;全局工具配置</p>
<p>先把maven，jdk复制到/home/domains/jenkins_home目录下，下面填写的jdk和maven用容器内部地址</p>
<p>比如jdk在/var/jenkins_home/jdk<em>**</em>目录下</p>
<p><img src="https://clyhs.github.io/images/jenkins/04.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/jenkins/05.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/jenkins/06.png" alt="img"></p>
<p>添加凭证，可以远程通过ssh连接192.168.0.7</p>
<p>系统管理-&gt;凭据-&gt;系统</p>
<p><img src="https://clyhs.github.io/images/jenkins/07.png" alt="img"></p>
<p>系统管理-&gt;系统设置-&gt;SSH remote hosts</p>
<p><img src="https://clyhs.github.io/images/jenkins/08.png" alt="img"></p>
<h3 id="上传JAVA项目到git仓库"><a href="/2019/06/26/docker与jenkins搭建持续集成/#上传JAVA项目到git仓库" class="headerlink" title="上传JAVA项目到git仓库"></a>上传JAVA项目到git仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://gitee.com/clyhs/mytest.git</span><br><span class="line">git remote remove origin </span><br><span class="line">git remote add origin git@192.168.0.7:/home/git/mytest.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;init&quot;</span><br><span class="line">git tag 1.0.0</span><br><span class="line">git push origin 1.0.0</span><br></pre></td></tr></table></figure>
<p>如何获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@192.168.0.7:/home/git/mytest.git</span><br><span class="line">git checkout 1.0.0</span><br></pre></td></tr></table></figure>
<h3 id="创建jenkins项目"><a href="/2019/06/26/docker与jenkins搭建持续集成/#创建jenkins项目" class="headerlink" title="创建jenkins项目"></a>创建jenkins项目</h3><p><img src="https://clyhs.github.io/images/jenkins/09.png" alt="img"></p>
<p>选择构建一个maven项目（如果没有这个选择，可以去插件管理进行安装）</p>
<h4 id="参数化构建过程"><a href="/2019/06/26/docker与jenkins搭建持续集成/#参数化构建过程" class="headerlink" title="参数化构建过程"></a>参数化构建过程</h4><p><img src="https://clyhs.github.io/images/jenkins/10.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/jenkins/11.png" alt="img"></p>
<h4 id="源码管理"><a href="/2019/06/26/docker与jenkins搭建持续集成/#源码管理" class="headerlink" title="源码管理"></a>源码管理</h4><p><img src="https://clyhs.github.io/images/jenkins/12.png" alt="img"></p>
<p>如果显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Failed to connect to repository : Command &quot;git ls-remote -h git@192.168.0.7:/home/git/mytest.git HEAD&quot; returned status code 128:</span><br><span class="line">stdout: </span><br><span class="line">stderr: Host key verification failed </span><br><span class="line">fatal: Could not read from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure>
<h4 id="创建一个jenkins"><a href="/2019/06/26/docker与jenkins搭建持续集成/#创建一个jenkins" class="headerlink" title="创建一个jenkins"></a>创建一个jenkins</h4><p>需要在192.168.0.7创建一个jenkins用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd jenkins</span><br><span class="line">passwd jenkins</span><br><span class="line">su jenkins</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">cat .ssh/id_rsa.pub #复制一下私钥</span><br></pre></td></tr></table></figure>
<p>在jenkins里面添加一个jenkins用户凭证</p>
<p><img src="https://clyhs.github.io/images/jenkins/14.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/jenkins/15.png" alt="img"></p>
<p>配置maven</p>
<p><img src="https://clyhs.github.io/images/jenkins/16.png" alt="img"></p>
<h4 id="POST-STEP执行shell"><a href="/2019/06/26/docker与jenkins搭建持续集成/#POST-STEP执行shell" class="headerlink" title="POST STEP执行shell"></a>POST STEP执行shell</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPO=192.168.0.7:5000/mytest:$&#123;Tag&#125;</span><br><span class="line">cat &gt; Dockerfile &lt;&lt; EOF</span><br><span class="line">FROM 192.168.0.7:5000/tomcat:7</span><br><span class="line">run rm -rf /usr/local/tomcat/webapps/ROOT</span><br><span class="line">COPY target/*.war /usr/local/tomcat/webapps/ROOT.war</span><br><span class="line">CMD [&quot;catalina.sh&quot;,&quot;run&quot;]</span><br><span class="line">EOF</span><br><span class="line">docker build -t $REPO .</span><br><span class="line">docker push $REPO</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/jenkins/17.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPOSITORY=192.168.0.7:5000/mytest:$&#123;Tag&#125;</span><br><span class="line"># 部署</span><br><span class="line">docker rm -f mytest |true</span><br><span class="line">docker image rm $REPOSITORY |true</span><br><span class="line">docker container run -d --name mytest -p 8111:8080 $REPOSITORY</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/jenkins/18.png" alt="img"></p>
<h3 id="开始构建"><a href="/2019/06/26/docker与jenkins搭建持续集成/#开始构建" class="headerlink" title="开始构建"></a>开始构建</h3><p><img src="https://clyhs.github.io/images/jenkins/19.png" alt="img"></p>
<p>根据版本号参数进行构建</p>
<p><img src="https://clyhs.github.io/images/jenkins/20.png" alt="img"></p>
<p>构建过程发现jenkins里面没有docker命令，为了之前配置jenkins容器的数据不丢失，把运行的jenkins容器，打成镜像<strong>clyhs/jenkins:1.0</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker commit containerId clyhs/jenkins:1.0</span><br></pre></td></tr></table></figure>
<p>停止之前运行的容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stop containerId</span><br></pre></td></tr></table></figure>
<p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name jenkins_my -p 8888:8080 -p 50000:50000 -v /home/domains/jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):/usr/bin/docker -v /usr/lib64/libltdl.so.7:/usr/lib/x86_64-linux-gnu/libltdl.so.7 clyhs/jenkins:1.0</span><br></pre></td></tr></table></figure>
<ul>
<li><p>现没有/var/run/docker.sock权限，</p>
</li>
<li><p>缺少libltdl.so.7依赖</p>
</li>
</ul>
<p>只能利用clyhs/jenkins:1.0来打新的镜像<strong>clyhs/jenkins:2.0</strong></p>
<h3 id="重建镜像"><a href="/2019/06/26/docker与jenkins搭建持续集成/#重建镜像" class="headerlink" title="重建镜像"></a>重建镜像</h3><p>vi Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM clyhs/jenkins:1.0</span><br><span class="line">USER root</span><br><span class="line">#清除了基础镜像设置的源，切换成阿里云的jessie源</span><br><span class="line">RUN echo &apos;&apos; &gt; /etc/apt/sources.list.d/jessie-backports.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian jessie main contrib non-free&quot; &gt; /etc/apt/sources.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian jessie-updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list \</span><br><span class="line">  &amp;&amp; echo &quot;deb http://mirrors.aliyun.com/debian-security jessie/updates main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">#更新源并安装缺少的包</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y libltdl7</span><br><span class="line"></span><br><span class="line">ARG dockerGid=999</span><br><span class="line"></span><br><span class="line">RUN echo &quot;docker:x:$&#123;dockerGid&#125;:jenkins&quot; &gt;&gt; /etc/group \</span><br><span class="line">USER jenkins</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t clyhs/jenkins:2.0 .</span><br></pre></td></tr></table></figure>
<h4 id="重新启动"><a href="/2019/06/26/docker与jenkins搭建持续集成/#重新启动" class="headerlink" title="重新启动"></a>重新启动</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name jenkins_my2 -p 8888:8080 -p 50000:50000 -v /home/domains/jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):/usr/bin/docker  clyhs/jenkins:2.0</span><br></pre></td></tr></table></figure>
<p><em>注意：$(which docker)表示用宿主的docker</em></p>
<p>终于构建成功</p>
<p><img src="https://clyhs.github.io/images/jenkins/21.png" alt="img"></p>
<p>运行的容器如下：</p>
<p><img src="https://clyhs.github.io/images/jenkins/22.png" alt="img"></p>
<p>用浏览器访问8111，出现正常的hello world!</p>
]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>docker中mysql的数据导出导入</title>
    <url>/2019/01/18/docker%E4%B8%ADmysql%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5/</url>
    <content><![CDATA[<h3 id="docker启动mysql"><a href="/2019/01/18/docker中mysql的数据导出导入/#docker启动mysql" class="headerlink" title="docker启动mysql"></a>docker启动mysql</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name pascloud_mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7 --lower_case_table_names=1 --character-set-server=utf8 --collation-server=utf8</span><br></pre></td></tr></table></figure>
<p>1、导出数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it pascloud_mysql mysqldump -uroot -proot pascloud &gt; /opt/pascloud.sql</span><br></pre></td></tr></table></figure></p>
<p>2、复制文件到容器里面<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp /opt/pascloud.sql pascloud_mysql:/opt/pascloud.sql</span><br></pre></td></tr></table></figure></p>
<p>3、进入容器<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it pascloud_mysql bash</span><br></pre></td></tr></table></figure></p>
<p>4、还原数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -proot</span><br><span class="line">&gt;create database pascloud;</span><br><span class="line">&gt;use pascloud;</span><br><span class="line">&gt;source /opt/pascloud.sql</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker中redis设置密码</title>
    <url>/2019/01/19/docker%E4%B8%ADredis%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h3 id="redis启动"><a href="/2019/01/19/docker中redis设置密码/#redis启动" class="headerlink" title="redis启动"></a>redis启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name redis_test -p 6378:6379 --restart=always redis:latest redis-server --appendonly yes --requirepass &quot;123456&quot;</span><br></pre></td></tr></table></figure>
<p><em>redis-server –appendonly yes在容器执行redis-server启动命令，并打开redis持久化</em><br>1、访问<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it c0de7caa5d1c redis-cli -a &apos;123456&apos;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it c0de7caa5d1c redis-cli -h 127.0.0.1 -p 6378 -a &apos;123456&apos;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or set)</span><br></pre></td></tr></table></figure>
<p><em>c0de7caa5d1c为容器ID</em></p>
<h3 id="redis挂载目录"><a href="/2019/01/19/docker中redis设置密码/#redis挂载目录" class="headerlink" title="redis挂载目录"></a>redis挂载目录</h3><ul>
<li>/home/domains/pascloud/redis/redis.conf:/etc/redis/redis.conf</li>
<li>/home/domains/pascloud/redis/data:/data<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --privileged=true -p 6379:6379 -v /home/domains/pascloud/redis/redis.conf:/etc/redis/redis.conf -v /home/domains/pascloud/redis/data:/data --name pascloud_redis redis:latest redis-server /etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/etc/redis/redis.conf 关键配置，让redis以指定的配置文件启动，而不是默认无配置启动。</p>
<p>–appendonly yes redis启动后开启数据持久化</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>docker目录迁移</title>
    <url>/2019/01/10/docker%E7%9B%AE%E5%BD%95%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h3 id="docker目录迁移"><a href="/2019/01/10/docker目录迁移/#docker目录迁移" class="headerlink" title="docker目录迁移"></a>docker目录迁移</h3><p>Docker的默认目录是在/var/lib/docker目录下<br>目录包括：<br><img src="https://clyhs.github.io/images/docker/201901101.png" alt="img"><br>将/var/lib/docker的目录迁移到/home/docker/lib/docker目录下</p>
<p>1、    用于查看Docker的磁盘使用情况<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure></p>
<p><img src="https://clyhs.github.io/images/docker/201901102.png" alt="img"></p>
<p>2、    关闭docker<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure></p>
<p>3、    命令查看磁盘使用情况<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -hs /var/lib/docker/</span><br></pre></td></tr></table></figure></p>
<p><img src="https://clyhs.github.io/images/docker/201901103.png" alt="img"></p>
<p>4、    创建新的docker目录，执行命令df -h,找一个大的磁盘。 我在 /home目录下面建了<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/docker/lib/docker</span><br></pre></td></tr></table></figure></p>
<p>5、    迁移/var/lib/docker目录下面的文件到 /home/docker/lib/docker<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -R /var/lib/docker/* /home/docker/lib/docker/</span><br></pre></td></tr></table></figure></p>
<p>6、    配置 /etc/systemd/system/docker.service.d/devicemapper.conf。查看 devicemapper.conf 是否存在。如果不存在，就新建<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d/</span><br><span class="line">vi /etc/systemd/system/docker.service.d/devicemapper.conf</span><br></pre></td></tr></table></figure></p>
<p>7、    然后在 devicemapper.conf 写入<br>内容如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/usr/bin/dockerd  --graph=/home/docker/lib/docker</span><br></pre></td></tr></table></figure></p>
<p>8、    重新加载 docker<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></p>
<p>9、    启动成功后，再确认之前的镜像还在：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></p>
<p><img src="https://clyhs.github.io/images/docker/201901104.png" alt="img"></p>
<p>10、确定容器没问题后删除/var/lib/docker/目录中的文件。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器入门</title>
    <url>/2017/04/08/docker%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="Docker容器入门"><a href="/2017/04/08/docker容器入门/#Docker容器入门" class="headerlink" title="Docker容器入门"></a>Docker容器入门</h1><h2 id="docker简介"><a href="/2017/04/08/docker容器入门/#docker简介" class="headerlink" title="docker简介"></a>docker简介</h2><blockquote>
<p>Docker是一个开源的引擎,可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器</p>
</blockquote>
<hr>
<h3 id="centos7安装docker"><a href="/2017/04/08/docker容器入门/#centos7安装docker" class="headerlink" title="centos7安装docker"></a>centos7安装docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> yum install docker</span><br></pre></td></tr></table></figure>
<h3 id="启动docker"><a href="/2017/04/08/docker容器入门/#启动docker" class="headerlink" title="启动docker"></a>启动docker</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> systemctl start docker</span><br></pre></td></tr></table></figure>
<h3 id="常用命令"><a href="/2017/04/08/docker容器入门/#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><blockquote>
<p>1、查看镜像。<br>docker images<br>2、查看本机运行的镜像<br>docker ps<br>3、从dockerhub上pull 镜像<br>docker pull镜像名称<br>4、查看docker 版本<br>   docker version<br>5、登陆docker Hub的账号<br>   docker login<br>6、运行容器<br>docker run -it #启动docker容器在前端<br>docker run -d #启动docker容器在后台<br>7、保存镜像<br>docker save –o xxx.tar.gz xxx/xxx:tag<br>8、导入镜像<br>docker load &lt; /path/xxx.tar.gz</p>
<p>9、限制目录大小</p>
<p>–log-opt max-size=100m –log-opt max-file=3</p>
<p>如：docker run -d –log-opt max-size=100m –log-opt max-file=3 –name pascloud_tomcat7 -p:8080:8080 -v /home/domains/pascloud/tomcat7:/home/domains/pascloud/tomcat7 -v /home/domains/pascloud/pas-cloud-service-demo:/home/domains/pascloud/pas-cloud-service-demo  pascloud/jdk7:v1.0  /home/domains/pascloud/tomcat7/bin/catalina.sh run </p>
<p>10、从容器中复制文件,把docker容器里的文件xxx.log复制到/home/pascloud/</p>
<p>docker cp containerId:/home/xxx.log /home/pascloud/xxx.log</p>
</blockquote>
<h4 id="自己创建一个镜像"><a href="/2017/04/08/docker容器入门/#自己创建一个镜像" class="headerlink" title="自己创建一个镜像"></a>自己创建一个镜像</h4><p>先网上拉下一个做为基础镜像<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># docker pull centos</span><br></pre></td></tr></table></figure></p>
<p>下载jdk-8u111-linux-x64.tar.gz和apache-tomcat-7.0.29.tar.gz包到本地<br>创建Dockerfile文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vi Dockerfile</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM centos:latest</span><br><span class="line">MAINTAINER author</span><br><span class="line">#设置工作目录</span><br><span class="line">WORKDIR /usr/local</span><br><span class="line"></span><br><span class="line">ADD jdk-8u111-linux-x64.tar.gz /usr/local/</span><br><span class="line">ADD apache-tomcat-7.0.29.tar.gz /usr/local/</span><br><span class="line"># 配置环境变量 </span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8.0_111</span><br><span class="line">ENV CLASSPATH .:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-7.0.29</span><br><span class="line"></span><br><span class="line">#暴露端口</span><br><span class="line">EXPOSE 8080  </span><br><span class="line">#设置tomcat 自启动  </span><br><span class="line">CMD [ &quot;/usr/local/apache-tomcat-7.0.29/bin/catalina.sh&quot;, &quot;run&quot; ]</span><br></pre></td></tr></table></figure>
<p>执行创建镜像命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># docker build -t tomcat/centos:latest .</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：</strong>最后面的<code>.</code>符号<br>运行容器<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># docker run -d -p 8080:8080 tomcat/centos:latest</span><br></pre></td></tr></table></figure></p>
<h4 id="创建一个JDK镜像"><a href="/2017/04/08/docker容器入门/#创建一个JDK镜像" class="headerlink" title="创建一个JDK镜像"></a>创建一个JDK镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line"></span><br><span class="line">MAINTAINER  abigfish</span><br><span class="line"></span><br><span class="line">ENV  TIME_ZONE Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>RUN rm -rf /etc/localtime &amp;&amp; ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime #修改时区</span><br><span class="line">RUN rm -rf /etc/localtime &amp;&amp; ln -s /usr/share/zoneinfo/$&#123;TIME_ZONE&#125; /etc/localtime</span><br><span class="line">RUN echo "$&#123;TIME_ZONE&#125;" &gt;/etc/timezone</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>RUN yum -y install kde-l10n-Chinese &amp;&amp; yum -y reinstall glibc-common</span><br><span class="line">RUN localedef -c -f UTF-8 -i zh_CN zh_CN.utf8 #配置显示中文</span><br><span class="line">ENV LC_ALL zh_CN.utf8 #设置环境变量</span><br><span class="line"></span><br><span class="line">ADD jdk-7u80-linux-x64.tar.gz /usr/local/</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.7.0_80</span><br><span class="line">ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">ENV PATH $PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd入门</title>
    <url>/2017/04/09/etcd%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="ETCD简介"><a href="/2017/04/09/etcd入门/#ETCD简介" class="headerlink" title="ETCD简介"></a>ETCD简介</h1><p>ETCD是用于共享配置和服务发现的分布式，一致性的KV存储系统。该项目目前最新稳定版本为2.3.0. 具体信息请参考[项目首页]和[Github]。ETCD是CoreOS公司发起的一个开源项目，授权协议为Apache。</p>
<hr>
<p>提供配置共享和服务发现的系统比较多，其中最为大家熟知的是[Zookeeper]（后文简称ZK），而ETCD可以算得上是后起之秀了。在项目实现，一致性协议易理解性，运维，安全等多个维度上，ETCD相比Zookeeper都占据优势。</p>
<h2 id="ETCD-vs-ZK"><a href="/2017/04/09/etcd入门/#ETCD-vs-ZK" class="headerlink" title="ETCD vs ZK"></a>ETCD vs ZK</h2><ul>
<li>一致性协议： ETCD使用[Raft]协议， ZK使用ZAB（类PAXOS协议），前者容易理解，方便工程实现；</li>
<li>运维方面：ETCD方便运维;</li>
<li>项目活跃度：ETCD社区与开发活跃，ZK已经快死了；</li>
<li>API：ETCD提供HTTP+JSON, gRPC接口，跨平台跨语言，ZK需要使用其客户端；</li>
<li>访问安全方面：ETCD支持HTTPS访问，ZK在这方面缺失；</li>
</ul>
<h3 id="ETCD的使用场景"><a href="/2017/04/09/etcd入门/#ETCD的使用场景" class="headerlink" title="ETCD的使用场景"></a>ETCD的使用场景</h3><p>和ZK类似，ETCD有很多使用场景，包括：</p>
<ul>
<li>配置管理</li>
<li>服务注册于发现</li>
<li>选主</li>
<li>应用调度</li>
<li>分布式队列</li>
<li>分布式锁</li>
</ul>
<h3 id="ETCD读写性能"><a href="/2017/04/09/etcd入门/#ETCD读写性能" class="headerlink" title="ETCD读写性能"></a>ETCD读写性能</h3><p>按照官网给出的[Benchmark], 在2CPU，1.8G内存，SSD磁盘这样的配置下，单节点的写性能可以达到16K QPS, 而先写后读也能达到12K QPS。这个性能还是相当可观的。</p>
<h3 id="ETCD工作原理"><a href="/2017/04/09/etcd入门/#ETCD工作原理" class="headerlink" title="ETCD工作原理"></a>ETCD工作原理</h3><p>ETCD使用Raft协议来维护集群内各个节点状态的一致性。简单说，ETCD集群是一个分布式系统，由多个节点相互通信构成整体对外服务，每个节点都存储了完整的数据，并且通过Raft协议保证每个节点维护的数据是一致的。<br><img src="https://clyhs.github.io/images/etcd/etcd01.png" alt="img"><br>如图所示，每个ETCD节点都维护了一个状态机，并且，任意时刻至多存在一个有效的主节点。主节点处理所有来自客户端写操作，通过Raft协议保证写操作对状态机的改动会可靠的同步到其他节点。</p>
<p>ETCD工作原理核心部分在于Raft协议。本节接下来将简要介绍Raft协议，具体细节请参考其[论文]。<br>Raft协议正如论文所述，确实方便理解。主要分为三个部分：选主，日志复制，安全性。</p>
<h4 id="选主"><a href="/2017/04/09/etcd入门/#选主" class="headerlink" title="选主"></a>选主</h4><p>Raft协议是用于维护一组服务节点数据一致性的协议。这一组服务节点构成一个集群，并且有一个主节点来对外提供服务。当集群初始化，或者主节点挂掉后，面临一个选主问题。集群中每个节点，任意时刻处于Leader, Follower, Candidate这三个角色之一。选举特点如下：</p>
<ul>
<li>当集群初始化时候，每个节点都是Follower角色；</li>
<li>集群中存在至多1个有效的主节点，通过心跳与其他节点同步数据；</li>
<li>当Follower在一定时间内没有收到来自主节点的心跳，会将自己角色改变为Candidate，并发起一次选主投票；当收到包括自己在内超过半数节点赞成后，选举成功；当收到票数不足半数选举失败，或者选举超时。若本轮未选出主节点，将进行下一轮选举（出现这种情况，是由于多个节点同时选举，所有节点均为获得过半选票）。</li>
<li>Candidate节点收到来自主节点的信息后，会立即终止选举过程，进入Follower角色。为了避免陷入选主失败循环，每个节点未收到心跳发起选举的时间是一定范围内的随机值，这样能够避免2个节点同时发起选主。</li>
</ul>
<h4 id="日志复制"><a href="/2017/04/09/etcd入门/#日志复制" class="headerlink" title="日志复制"></a>日志复制</h4><p>所谓日志复制，是指主节点将每次操作形成日志条目，并持久化到本地磁盘，然后通过网络IO发送给其他节点。其他节点根据日志的逻辑时钟(TERM)和日志编号(INDEX)来判断是否将该日志记录持久化到本地。当主节点收到包括自己在内超过半数节点成功返回，那么认为该日志是可提交的(committed），并将日志输入到状态机，将结果返回给客户端。</p>
<p>这里需要注意的是，每次选主都会形成一个唯一的TERM编号，相当于逻辑时钟。每一条日志都有全局唯一的编号。</p>
<p><img src="https://clyhs.github.io/images/etcd/etcd02.png" alt="img"></p>
<p>主节点通过网络IO向其他节点追加日志。若某节点收到日志追加的消息，首先判断该日志的TERM是否过期，以及该日志条目的INDEX是否比当前以及提交的日志的INDEX跟早。若已过期，或者比提交的日志更早，那么就拒绝追加，并返回该节点当前的已提交的日志的编号。否则，将日志追加，并返回成功。</p>
<p>当主节点收到其他节点关于日志追加的回复后，若发现有拒绝，则根据该节点返回的已提交日志编号，发生其编号下一条日志。</p>
<p>主节点像其他节点同步日志，还作了拥塞控制。具体地说，主节点发现日志复制的目标节点拒绝了某次日志追加消息，将进入日志探测阶段，一条一条发送日志，直到目标节点接受日志，然后进入快速复制阶段，可进行批量日志追加。</p>
<p>按照日志复制的逻辑，我们可以看到，集群中慢节点不影响整个集群的性能。另外一个特点是，数据只从主节点复制到Follower节点，这样大大简化了逻辑流程。</p>
<h4 id="安全性"><a href="/2017/04/09/etcd入门/#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>截止此刻，选主以及日志复制并不能保证节点间数据一致。试想，当一个某个节点挂掉了，一段时间后再次重启，并当选为主节点。而在其挂掉这段时间内，集群若有超过半数节点存活，集群会正常工作，那么会有日志提交。这些提交的日志无法传递给挂掉的节点。当挂掉的节点再次当选主节点，它将缺失部分已提交的日志。在这样场景下，按Raft协议，它将自己日志复制给其他节点，会将集群已经提交的日志给覆盖掉。</p>
<p>这显然是不可接受的。</p>
<p>其他协议解决这个问题的办法是，新当选的主节点会询问其他节点，和自己数据对比，确定出集群已提交数据，然后将缺失的数据同步过来。这个方案有明显缺陷，增加了集群恢复服务的时间（集群在选举阶段不可服务），并且增加了协议的复杂度。</p>
<p>Raft解决的办法是，在选主逻辑中，对能够成为主的节点加以限制，确保选出的节点已定包含了集群已经提交的所有日志。如果新选出的主节点已经包含了集群所有提交的日志，那就不需要从和其他节点比对数据了。简化了流程，缩短了集群恢复服务的时间。</p>
<p>这里存在一个问题，加以这样限制之后，还能否选出主呢？答案是：只要仍然有超过半数节点存活，这样的主一定能够选出。因为已经提交的日志必然被集群中超过半数节点持久化，显然前一个主节点提交的最后一条日志也被集群中大部分节点持久化。当主节点挂掉后，集群中仍有大部分节点存活，那这存活的节点中一定存在一个节点包含了已经提交的日志了。</p>
<p>至此，关于Raft协议的简介就全部结束了。</p>
<h4 id="ETCD使用案例"><a href="/2017/04/09/etcd入门/#ETCD使用案例" class="headerlink" title="ETCD使用案例"></a>ETCD使用案例</h4><p>据公开资料显示，至少有CoreOS, Google Kubernetes, Cloud Foundry, 以及在Github上超过500个项目在使用ETCD。</p>
<h4 id="ETCD接口"><a href="/2017/04/09/etcd入门/#ETCD接口" class="headerlink" title="ETCD接口"></a>ETCD接口</h4><p>ETCD提供HTTP协议，在最新版本中支持Google gRPC方式访问。具体支持接口情况如下：</p>
<ul>
<li>ETCD是一个高可靠的KV存储系统，支持PUT/GET/DELETE接口；</li>
<li>为了支持服务注册与发现，支持WATCH接口（通过http long poll实现）；</li>
<li>支持KEY持有TTL属性；</li>
<li>CAS（compare and swap)操作;</li>
<li>支持多key的事务操作；</li>
<li>支持目录操作</li>
</ul>
<p>[^] <a href="https://yq.aliyun.com/articles/11035" target="_blank" rel="noopener">https://yq.aliyun.com/articles/11035</a></p>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab本地部署</title>
    <url>/2019/09/24/gitlab%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="gitlab本地部署"><a href="/2019/09/24/gitlab本地部署/#gitlab本地部署" class="headerlink" title="gitlab本地部署"></a>gitlab本地部署</h3><h4 id="准备"><a href="/2019/09/24/gitlab本地部署/#准备" class="headerlink" title="准备"></a>准备</h4><p>下载地址：<a href="https://packages.gitlab.com/gitlab/gitlab-ce/" target="_blank" rel="noopener">https://packages.gitlab.com/gitlab/gitlab-ce/</a></p>
<p>系统：centos7</p>
<p>软件包：gitlab-ce-10.5.1-ce.0.el7.x86_64.rpm</p>
<h4 id="先安装依赖"><a href="/2019/09/24/gitlab本地部署/#先安装依赖" class="headerlink" title="先安装依赖"></a>先安装依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install curl openssh-server openssh-clients postfix cronie policycoreutils-python</span><br></pre></td></tr></table></figure>
<h4 id="安装gitlab"><a href="/2019/09/24/gitlab本地部署/#安装gitlab" class="headerlink" title="安装gitlab"></a>安装gitlab</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -ivh gitlab-ce-10.5.1-ce.0.el7.x86_64.rpm</span><br><span class="line">#安装完成后，执行配置</span><br><span class="line">gitlab-ctl reconfigure</span><br></pre></td></tr></table></figure>
<p>修改/etc/gitblab/gitlab.rb</p>
<p>将external_url，改成具体ip，如：<a href="http://192.168.0.7" target="_blank" rel="noopener">http://192.168.0.7</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#重新配置</span><br><span class="line">gitlab-ctl reconfigure</span><br><span class="line">#重启</span><br><span class="line">gitlab-ctl restart</span><br></pre></td></tr></table></figure>
<p> 查看gitlab版本 </p>
<p>head -1 /opt/gitlab/version-manifest.txt</p>
<p>通过浏览器登录</p>
<p><a href="http://192.168.0.7" target="_blank" rel="noopener">http://192.168.0.7</a></p>
<p>配置用户密码，默认用户为root</p>
<h4 id="汉化"><a href="/2019/09/24/gitlab本地部署/#汉化" class="headerlink" title="汉化"></a>汉化</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/marbleqi/gitlab-ce-zh.git</span><br><span class="line">cd gitlab-ce-zh</span><br><span class="line">git pull origin #从远端获取最新库</span><br><span class="line">git branch -a</span><br><span class="line">git checkout remotes/origin/v10.5.1-zh-patch</span><br></pre></td></tr></table></figure>
<p>将汉化文件覆盖到/opt/gitlab/embedded/service/gitlab-rails/</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\cp -r -f gitlab-ce-zh/* /opt/gitlab/embedded/service/gitlab-rails/</span><br></pre></td></tr></table></figure>
<p>修改/etc/gitlab/gitlab.rb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/gitlab/gitlab.rb</span><br><span class="line">gitlab_rails[&apos;time_zone&apos;] = &apos;PRC&apos; #将标准时修改为中国时间</span><br><span class="line"></span><br><span class="line">gitlab-ctl reconfigure #使修改的配置文件生效</span><br><span class="line">#注：如果上述命令执行后，未汉化或有异常，则执行以下命令</span><br><span class="line">gitlab-ctl stop #停止gitlab服务</span><br><span class="line">gitlab-ctl start #启动gitlab服务</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/gitlab/gitlab-01.png" alt="img"></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言的web框架</title>
    <url>/2017/05/23/go%E8%AF%AD%E8%A8%80%E4%B9%8Bweb%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>总结一下GO的WEB框架，如下图：</p>
<p><img src="https://clyhs.github.io/images/go/goweb.png" alt="img"></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go之web框架bee入门</title>
    <url>/2017/04/07/go%E4%B9%8Bweb%E6%A1%86%E6%9E%B6bee%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="从GIT上获取bee包"><a href="/2017/04/07/go之web框架bee入门/#从GIT上获取bee包" class="headerlink" title="从GIT上获取bee包"></a>从GIT上获取bee包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># go get github.com/beego/bee</span><br><span class="line"># go get github.com/astaxie/beego</span><br></pre></td></tr></table></figure>
<p>下载完了之后去$GOPATH/bin查看是否已经生成bee文件，如果在win下是bee.exe<br>将$GOPATH/bin添加到环境变量PATH后面</p>
<h3 id="利用bee来创建WEB"><a href="/2017/04/07/go之web框架bee入门/#利用bee来创建WEB" class="headerlink" title="利用bee来创建WEB"></a>利用bee来创建WEB</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd $GOPATH/src/github.com/clyhs</span><br><span class="line"># bee new helloweb</span><br><span class="line"># cd helloweb</span><br><span class="line"># go build</span><br></pre></td></tr></table></figure>
<p>如下图（win7下面执行，先安装git）<br><img src="https://github.com/clyhs/clyhs.github.io/blob/master/images/go/go_01.png?raw=true" alt></p>
<h3 id="运行生成服务"><a href="/2017/04/07/go之web框架bee入门/#运行生成服务" class="headerlink" title="运行生成服务"></a>运行生成服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ./helloweb</span><br></pre></td></tr></table></figure>
<p>通过浏览器访问<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br><img src="https://github.com/clyhs/clyhs.github.io/blob/master/images/go/go_02.png?raw=true" alt></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>gulp使用笔记</title>
    <url>/2017/04/15/gulp%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="gulp简介"><a href="/2017/04/15/gulp使用笔记/#gulp简介" class="headerlink" title="gulp简介"></a>gulp简介</h1><p>gulp是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。</p>
<p>gulp是基于Nodejs的自动任务运行器， 她能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。通过本文，我们将学习如何使用Gulp来改变开发流程，从而使开发更加快速高效。</p>
<p>gulp 和 grunt 非常类似，但相比于 grunt 的频繁 IO 操作，gulp 的流操作，能更快地更便捷地完成构建工作。</p>
<hr>
<h2 id="安装-gulp"><a href="/2017/04/15/gulp使用笔记/#安装-gulp" class="headerlink" title="安装 gulp"></a>安装 gulp</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># npm install -g gulp</span><br><span class="line"># gulp -v</span><br><span class="line">[19:20:24] CLI version 3.9.1</span><br></pre></td></tr></table></figure>
<h3 id="新建-package-json"><a href="/2017/04/15/gulp使用笔记/#新建-package-json" class="headerlink" title="新建 package.json"></a>新建 package.json</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># npm init</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;helloweb&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># npm install gulp --save</span><br></pre></td></tr></table></figure></p>
<p>package.json<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;helloweb&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;gulpfile.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;gulp&quot;: &quot;^3.9.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="安装semantic"><a href="/2017/04/15/gulp使用笔记/#安装semantic" class="headerlink" title="安装semantic"></a>安装semantic</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># npm install semantic-ui --save</span><br><span class="line"></span><br><span class="line">&gt; Automatic (Use defaults locations and all components)</span><br><span class="line">  Express (Set components and output folder)</span><br><span class="line">  Custom (Customize all src/dist values)</span><br></pre></td></tr></table></figure>
<p>选择一项按回车键安装semantic<br>在目录下生成<code>semantic.json</code>与<code>semantic</code>目录</p>
<h3 id="把semantic的gulpfile-js文件-移到上层static目录下"><a href="/2017/04/15/gulp使用笔记/#把semantic的gulpfile-js文件-移到上层static目录下" class="headerlink" title="把semantic的gulpfile.js文件 移到上层static目录下"></a>把<code>semantic</code>的<code>gulpfile.js</code>文件 移到上层static目录下</h3><p>修改gulpfile.js<br>把所有<br><code>./tasks/*</code> =&gt; <code>./semantic/tasks/*</code></p>
<p>修改<code>package.json</code>的<code>&quot;main&quot;:&quot;gulpfile.js&quot;</code></p>
<p>###生成semantic.js<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd semantic</span><br><span class="line"># gulp build</span><br></pre></td></tr></table></figure></p>
<p>在semantic目录生成dist目录</p>
]]></content>
      <categories>
        <category>gulp</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>hbase设计rowkey例子</title>
    <url>/2018/04/03/hbase%E8%AE%BE%E8%AE%A1rowkey%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<h3 id="HBASE表的模板"><a href="/2018/04/03/hbase设计rowkey例子/#HBASE表的模板" class="headerlink" title="HBASE表的模板"></a>HBASE表的模板</h3><table cellspacing="0" cellpadding="0" style="border-collapse:collapse; margin-left:0pt"><tr><td rowspan="2" style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:65.2pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">rowkey</span></p></td><td colspan="2" style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:87.4pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">CF1</span></p></td><td colspan="2" style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:87.4pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">CF2</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:63.7pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">CF(N)</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:68.4pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">timestamp</span></p></td></tr><tr><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:38.3pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">C</span><span style="font-family:Calibri; font-size:10.5pt">olumn1</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:38.3pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">C</span><span style="font-family:Calibri; font-size:10.5pt">olumn2</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:38.3pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">C</span><span style="font-family:Calibri; font-size:10.5pt">olumn3</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:38.3pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">C</span><span style="font-family:Calibri; font-size:10.5pt">olumn4</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:63.7pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">…</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:68.4pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">&#xa0;</span></p></td></tr><tr><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:65.2pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">&#xa0;</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:38.3pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">&#xa0;</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:38.3pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">&#xa0;</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:38.3pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">&#xa0;</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:38.3pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">&#xa0;</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:63.7pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">&#xa0;</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:68.4pt"><p style="margin:0pt; orphans:0; text-align:center; widows:0"><span style="font-family:Calibri; font-size:10.5pt">&#xa0;</span></p></td></tr><tr style="height:0pt"><td style="width:76pt; border:none"></td><td style="width:49.1pt; border:none"></td><td style="width:49.1pt; border:none"></td><td style="width:49.1pt; border:none"></td><td style="width:49.1pt; border:none"></td><td style="width:74.5pt; border:none"></td><td style="width:79.2pt; border:none"></td></tr></table>


<p>说明：hbase表由rowkey+列族(CF)+ timestamp组成<br>A）、Rowkey 相当于主键<br>B）、CF1 全写是 columnFamily ,就是列族<br>C）、Timestamp 这个时间截相当于版本号，因为一行数据可能会更新，HBASE不会删除老的数据，每条数据加一个时间截，做为版本标记</p>
<p>一般设计Hbase表主要就是对rowkey跟CF(列族)，设计rowkey是根据查询条件来决定，列族是根据查询结果来定的。</p>
<h3 id="rowKey设计原则"><a href="/2018/04/03/hbase设计rowkey例子/#rowKey设计原则" class="headerlink" title="rowKey设计原则"></a>rowKey设计原则</h3><p>1、长度越短越好<br>2、唯一性<br>3、散列原则</p>
<p>Rowkey是一个二进制码流，目前操作系统是都是64位系，控制在16个字节，8字节的整数倍利用操作系统的最佳特性。下面是rowkey的结构表</p>
<table cellspacing="0" cellpadding="0" style="border-collapse:collapse; margin-left:0pt"><tr><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:37.15pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">第</span><span style="font-family:Calibri; font-size:10.5pt">1</span><span style="font-family:宋体; font-size:10.5pt">字节</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:38.8pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">第</span><span style="font-family:Calibri; font-size:10.5pt">2</span><span style="font-family:宋体; font-size:10.5pt">字节</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:31.75pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">第</span><span style="font-family:Calibri; font-size:10.5pt">3</span><span style="font-family:宋体; font-size:10.5pt">字节</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:31.7pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">第</span><span style="font-family:Calibri; font-size:10.5pt">4</span><span style="font-family:宋体; font-size:10.5pt">字节</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:31.75pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">第</span><span style="font-family:Calibri; font-size:10.5pt">5</span><span style="font-family:宋体; font-size:10.5pt">字节</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:38.8pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">第</span><span style="font-family:Calibri; font-size:10.5pt">6</span><span style="font-family:宋体; font-size:10.5pt">字节</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:38.8pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">第</span><span style="font-family:Calibri; font-size:10.5pt">7</span><span style="font-family:宋体; font-size:10.5pt">字节</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:31.75pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">第</span><span style="font-family:Calibri; font-size:10.5pt">8</span><span style="font-family:宋体; font-size:10.5pt">字节</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:45.9pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:Calibri; font-size:10.5pt">…</span></p></td></tr><tr><td colspan="4" style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:171.8pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="color:#ff0000; font-family:宋体; font-size:10.5pt">散列字段</span></p></td><td colspan="4" style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:173.5pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="color:#ff0000; font-family:宋体; font-size:10.5pt">时间字段</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:45.9pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="color:#ff0000; font-family:宋体; font-size:10.5pt">扩展字段</span></p></td></tr><tr><td colspan="4" style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:171.8pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:Calibri; font-size:10.5pt">&#xa0;</span></p></td><td colspan="4" style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:173.5pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:Calibri; font-size:10.5pt">&#xa0;</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:45.9pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:Calibri; font-size:10.5pt">&#xa0;</span></p></td></tr><tr style="height:0pt"><td style="width:47.95pt; border:none"></td><td style="width:49.6pt; border:none"></td><td style="width:42.55pt; border:none"></td><td style="width:42.5pt; border:none"></td><td style="width:42.55pt; border:none"></td><td style="width:49.6pt; border:none"></td><td style="width:49.6pt; border:none"></td><td style="width:42.55pt; border:none"></td><td style="width:56.7pt; border:none"></td></tr></table>

<ul>
<li><p>散列字段 = 就是hash字段，这个字段可以根据HBASE多少节点来做随机，比如HBASE有3个节点，那么，这个节点的值可以是 1 、 2 、3，这样做的好处是，数据会分散到3个节点去存，也就是分片的依据</p>
</li>
<li><p>时间字段，如果HBASE表用天分表，这个字段就可以存时分，那么就比较短，所以表最好是以天来建最好，可以减少rowkey的长度</p>
</li>
<li><p>扩展字段主要就是查询输入项的字段了，比如币种，分类字段啊什么的。</p>
</li>
</ul>
<p>所以表的rowkey主要三个部分组成</p>
<h3 id="客户经理报表设计（综合业绩信息）"><a href="/2018/04/03/hbase设计rowkey例子/#客户经理报表设计（综合业绩信息）" class="headerlink" title="客户经理报表设计（综合业绩信息）"></a>客户经理报表设计（综合业绩信息）</h3><p>输入项：<br>统计日期、指标类别、币种、统计方式、单位。（下面是按天分表，所以时间字段只存时分秒）</p>
<table cellspacing="0" cellpadding="0" style="border-collapse:collapse; margin-left:0pt"><tr><td colspan="3" style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:415.3pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">rowkey</span></p></td></tr><tr><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:65.5pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">散列字段</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:60.05pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">时间字段</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:268.15pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">扩展字段</span></p></td></tr><tr><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:65.5pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">001</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:60.05pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">123012</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:268.15pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">指标类别</span><span style="font-family:宋体; font-size:10.5pt">（001）+</span><span style="font-family:宋体; font-size:10.5pt">币种</span><span style="font-family:宋体; font-size:10.5pt">（01）+</span><span style="font-family:宋体; font-size:10.5pt">统计方式</span><span style="font-family:宋体; font-size:10.5pt">（02）+</span><span style="font-family:宋体; font-size:10.5pt">单位</span><span style="font-family:宋体; font-size:10.5pt">（01）</span></p></td></tr><tr><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:65.5pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">001</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:60.05pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">123012</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:268.15pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">001010201</span></p></td></tr><tr><td colspan="3" style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:415.3pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">合并：001123012001010201</span></p></td></tr><tr style="height:0pt"><td style="width:76.3pt; border:none"></td><td style="width:70.85pt; border:none"></td><td style="width:278.95pt; border:none"></td></tr></table>

<p>整个表结构如下</p>
<table cellspacing="0" cellpadding="0" style="border-collapse:collapse; margin-left:0pt"><tr><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:58.4pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">rowkey</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:204.05pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">C</span><span style="font-family:宋体; font-size:10.5pt">F</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:131.25pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">timestamp</span></p></td></tr><tr><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:58.4pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">&#xa0;</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:204.05pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">&#xa0;</span></p></td><td style="border-bottom-color:#000000; border-bottom-style:solid; border-bottom-width:0.75pt; border-left-color:#000000; border-left-style:solid; border-left-width:0.75pt; border-right-color:#000000; border-right-style:solid; border-right-width:0.75pt; border-top-color:#000000; border-top-style:solid; border-top-width:0.75pt; padding-left:5.03pt; padding-right:5.03pt; vertical-align:top; width:131.25pt"><p style="margin:0pt; orphans:0; text-align:justify; widows:0"><span style="font-family:宋体; font-size:10.5pt">&#xa0;</span></p></td></tr></table>




]]></content>
      <categories>
        <category>hbase</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>go入门之旅</title>
    <url>/2017/04/07/go%E5%85%A5%E9%97%A8%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<h1 id="go入门"><a href="/2017/04/07/go入门之旅/#go入门" class="headerlink" title="go入门"></a>go入门</h1><h2 id="go简介"><a href="/2017/04/07/go入门之旅/#go简介" class="headerlink" title="go简介"></a>go简介</h2><blockquote>
<p>Go语言是由谷歌开发出来的一种新的语言。</p>
</blockquote>
<h3 id="系统版本"><a href="/2017/04/07/go入门之旅/#系统版本" class="headerlink" title="系统版本"></a>系统版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">centos7</span><br></pre></td></tr></table></figure>
<h3 id="go安装"><a href="/2017/04/07/go入门之旅/#go安装" class="headerlink" title="go安装"></a>go安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum install go</span><br></pre></td></tr></table></figure>
<h3 id="查看go版本"><a href="/2017/04/07/go入门之旅/#查看go版本" class="headerlink" title="查看go版本"></a>查看go版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># go version</span><br><span class="line"># go version go1.6.3 linux/amd4</span><br></pre></td></tr></table></figure>
<h3 id="配置环境变量"><a href="/2017/04/07/go入门之旅/#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd ~</span><br><span class="line"># mkdir go</span><br></pre></td></tr></table></figure>
<p>编辑profile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># vi /etc/profile</span><br><span class="line"># export GOPATH=$HOME/go</span><br><span class="line"># export PATH=$GOPATH/bin:$PATH</span><br><span class="line"># source /etc/profile</span><br><span class="line"># echo $GOPATH</span><br><span class="line">/root/go</span><br></pre></td></tr></table></figure>
<h3 id="新建一个项目"><a href="/2017/04/07/go入门之旅/#新建一个项目" class="headerlink" title="新建一个项目"></a>新建一个项目</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mkdir -p $GOPATH/src/github.com/clyhs(这里是你的用户名)</span><br><span class="line"># cd $GOPATH/src/github.com/clyhs</span><br><span class="line"># git clone https://github.com/clyhs/hello-go.git</span><br><span class="line"># cd hello-go</span><br></pre></td></tr></table></figure>
<h3 id="编写main-go"><a href="/2017/04/07/go入门之旅/#编写main-go" class="headerlink" title="编写main.go"></a>编写<code>main.go</code></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(<span class="string">"hello!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 go build编译当前目录<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># go build</span><br><span class="line"># ./hello-go</span><br><span class="line">hello!</span><br></pre></td></tr></table></figure></p>
<h3 id="提交到git仓库"><a href="/2017/04/07/go入门之旅/#提交到git仓库" class="headerlink" title="提交到git仓库"></a>提交到git仓库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># git add .</span><br><span class="line"># git commit -m &quot;first commit&quot;</span><br><span class="line"># git push -u origin master</span><br></pre></td></tr></table></figure>
<h3 id="在-GOPATH-bin生成hello-go文件"><a href="/2017/04/07/go入门之旅/#在-GOPATH-bin生成hello-go文件" class="headerlink" title="在$GOPATH/bin生成hello-go文件"></a>在$GOPATH/bin生成hello-go文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get github.com/clyhs/hello-go</span><br></pre></td></tr></table></figure>
<h3 id="编写一个HTTP服务"><a href="/2017/04/07/go入门之旅/#编写一个HTTP服务" class="headerlink" title="编写一个HTTP服务"></a>编写一个HTTP服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd $GOPATH/src/github.com/clyhs</span><br><span class="line"># mkdir helloworld</span><br><span class="line"># cd helloworld</span><br><span class="line"># vi main.go</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">    &quot;log&quot;</span><br><span class="line">)</span><br><span class="line">func sayhelloName(w http.ResponseWriter, r *http.Request) &#123;</span><br><span class="line">    r.ParseForm() //解析参数，默认是不会解析的</span><br><span class="line">    fmt.Println(r.Form) //这些信息是输出到服务器端的打印信息</span><br><span class="line">    fmt.Println(&quot;path&quot;, r.URL.Path)</span><br><span class="line">    fmt.Println(&quot;scheme&quot;, r.URL.Scheme)</span><br><span class="line">    fmt.Println(r.Form[&quot;url_long&quot;])</span><br><span class="line">    for k, v := range r.Form &#123;</span><br><span class="line">        fmt.Println(&quot;key:&quot;, k)</span><br><span class="line">        fmt.Println(&quot;val:&quot;, strings.Join(v, &quot;&quot;))</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Fprintf(w, &quot;Hello astaxie!&quot;) //这个写入到w的是输出到客户端的</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    http.HandleFunc(&quot;/&quot;, sayhelloName) //设置访问的路由</span><br><span class="line">    err := http.ListenAndServe(&quot;:8080&quot;, nil) //设置监听的端口</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        log.Fatal(&quot;ListenAndServe: &quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># go build</span><br><span class="line"># ./helloworld</span><br></pre></td></tr></table></figure>
<p>在浏览器里输入<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出`Hello astaxie!`</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins利用testng自动化测试</title>
    <url>/2019/07/10/jenkins%E5%88%A9%E7%94%A8testng%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h3 id="自动化测试"><a href="/2019/07/10/jenkins利用testng自动化测试/#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h3><h4 id="Eclipse-TestNG"><a href="/2019/07/10/jenkins利用testng自动化测试/#Eclipse-TestNG" class="headerlink" title="Eclipse+TestNG"></a>Eclipse+TestNG</h4><p>TestNG插件安装，直接通过eclipse marketplace查找</p>
<p><img src="https://clyhs.github.io/images/jenkins/23.png" alt="img"></p>
<p><strong>在工程中新建TestNG类</strong></p>
<p><img src="https://clyhs.github.io/images/jenkins/24.png" alt="img"></p>
<p>生成TestNG.xml，<strong>NewTest.java</strong>如下</p>
<p><img src="https://clyhs.github.io/images/jenkins/30.png" alt="img"></p>
<p>提交到git</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;2.0.0&quot;</span><br><span class="line">git tag 2.0.0</span><br><span class="line">git push origin 2.0.0</span><br></pre></td></tr></table></figure>
<h4 id="jenkins安装xUnit-plugin和TestNG-Result"><a href="/2019/07/10/jenkins利用testng自动化测试/#jenkins安装xUnit-plugin和TestNG-Result" class="headerlink" title="jenkins安装xUnit plugin和TestNG Result"></a>jenkins安装xUnit plugin和TestNG Result</h4><p>进入系统管理-&gt;插件管理</p>
<p><strong>安装xUnit plugin</strong></p>
<p><img src="https://clyhs.github.io/images/jenkins/25.png" alt="img"></p>
<p><strong>安装TestNG Result</strong></p>
<p><img src="https://clyhs.github.io/images/jenkins/28.png" alt="img"></p>
<h4 id="修改mytest配置"><a href="/2019/07/10/jenkins利用testng自动化测试/#修改mytest配置" class="headerlink" title="修改mytest配置"></a>修改mytest配置</h4><p><em>之前配置看上一篇<a href="http://abigfish.net/2019/06/26/docker%E4%B8%8Ejenkins%E6%90%AD%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90">docker与jenkins搭建持续集成</a></em></p>
<p><strong>构件</strong></p>
<p><img src="https://clyhs.github.io/images/jenkins/27.png" alt="img"></p>
<p><strong>构建后操作</strong></p>
<p>选择publish TestNG Results</p>
<p><img src="https://clyhs.github.io/images/jenkins/29.png" alt="img"></p>
<h4 id="构建"><a href="/2019/07/10/jenkins利用testng自动化测试/#构建" class="headerlink" title="构建"></a>构建</h4><p>选择tag为2.0.0</p>
<p>构建完成如下：</p>
<p><img src="https://clyhs.github.io/images/jenkins/31.png" alt="img"></p>
<p>多了一个testng Results</p>
<p><img src="https://clyhs.github.io/images/jenkins/32.png" alt="img"></p>
<p>进去</p>
<p><img src="https://clyhs.github.io/images/jenkins/34.png" alt="img"></p>
<h4 id="查看服务器"><a href="/2019/07/10/jenkins利用testng自动化测试/#查看服务器" class="headerlink" title="查看服务器"></a>查看服务器</h4><p><img src="https://clyhs.github.io/images/jenkins/33.png" alt="img"></p>
]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s istio</title>
    <url>/2022/08/19/k8s%20istio/</url>
    <content><![CDATA[<h2 id="istio-安装"><a href="/2022/08/19/k8s istio/#istio-安装" class="headerlink" title="istio 安装"></a>istio 安装</h2><p>istio-1.14.3.tar.gz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv istio-1.14.3.tar.gz /usr/local/</span><br><span class="line">tar -zvxf istio-1.14.3</span><br><span class="line">cd ~</span><br><span class="line">vi .bash_profile</span><br><span class="line"># 开始</span><br><span class="line">export ISTIO_HOME=/usr/local/istio-1.14.3</span><br><span class="line">export PATH=$PATH:$ISTIO_HOME/bin</span><br><span class="line"># 结束</span><br><span class="line">source .bash_profile</span><br><span class="line">#安装</span><br><span class="line">istioctl install --set profile=demo -y</span><br><span class="line">✔ Istio core installed                         </span><br><span class="line">✔ Istiod installed                          </span><br><span class="line">✔ Ingress gateways installed                              </span><br><span class="line">✔ Egress gateways installed            </span><br><span class="line">✔ Installation complete                                                                                                         Making this installation the default for injection and validation.</span><br><span class="line"></span><br><span class="line">#给命名空间添加标签，指示 Istio 在部署应用的时候，自动注入 Envoy 边车代理：</span><br><span class="line">kubectl label namespace default istio-injection=enabled</span><br><span class="line"></span><br><span class="line">kubectl get svc -n istio-system</span><br><span class="line">NAME                                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">istio-egressgateway-68cbb757cc-jdc8l    1/1     Running   0          8m8s</span><br><span class="line">istio-ingressgateway-6fbd8dddbf-2b25p   1/1     Running   0          8m8s</span><br><span class="line">istiod-6fcfb4fbd9-6jklv                 1/1     Running   0          10m</span><br></pre></td></tr></table></figure>
<h2 id="安装kiali"><a href="/2022/08/19/k8s istio/#安装kiali" class="headerlink" title="安装kiali"></a>安装kiali</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/istio/istio/release-1.14/samples/addons/kiali.yaml</span><br></pre></td></tr></table></figure>
<p>设置可视化界面kiali为外部访问模式并查询nodeport号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl patch svc -n istio-system kiali -p &apos;&#123;&quot;spec&quot;: &#123;&quot;type&quot;: &quot;NodePort&quot;&#125;&#125;&apos;</span><br><span class="line"></span><br><span class="line">kubectl describe svc -n istio-system kiali</span><br><span class="line">Name:                     kiali</span><br><span class="line">Namespace:                istio-system</span><br><span class="line">Labels:                   app=kiali</span><br><span class="line">                          app.kubernetes.io/instance=kiali</span><br><span class="line">                          app.kubernetes.io/managed-by=Helm</span><br><span class="line">                          app.kubernetes.io/name=kiali</span><br><span class="line">                          app.kubernetes.io/part-of=kiali</span><br><span class="line">                          app.kubernetes.io/version=v1.50.0</span><br><span class="line">                          helm.sh/chart=kiali-server-1.50.0</span><br><span class="line">                          version=v1.50.0</span><br><span class="line">Annotations:              &lt;none&gt;</span><br><span class="line">Selector:                 app.kubernetes.io/instance=kiali,app.kubernetes.io/name=kiali</span><br><span class="line">Type:                     NodePort</span><br><span class="line">IP Families:              &lt;none&gt;</span><br><span class="line">IP:                       10.96.108.219</span><br><span class="line">IPs:                      10.96.108.219</span><br><span class="line">Port:                     http  20001/TCP</span><br><span class="line">TargetPort:               20001/TCP</span><br><span class="line">NodePort:                 http  31255/TCP</span><br><span class="line">Endpoints:                172.31.131.167:20001</span><br><span class="line">Port:                     http-metrics  9090/TCP</span><br><span class="line">TargetPort:               9090/TCP</span><br><span class="line">NodePort:                 http-metrics  32081/TCP</span><br><span class="line">Endpoints:                172.31.131.167:9090</span><br><span class="line">Session Affinity:         None</span><br><span class="line">External Traffic Policy:  Cluster</span><br><span class="line">Events:                   &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>（1）<strong>在istio上部署测试应用bookinfo</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、开启sidecar自动注入</span><br><span class="line">kubectl label namespace default istio-injection=enabled</span><br><span class="line">2、使用kubectl部署bookinfo并创建网关</span><br><span class="line">kubectl apply -f /usr/local/istio-1.14.3/samples/bookinfo/platform/kube/bookinfo.yaml</span><br><span class="line">kubectl apply -f /usr/local/istio-1.14.3/samples/bookinfo/networking/bookinfo-gateway.yaml </span><br><span class="line">3、设置访问网关的 INGRESS_HOST 和 INGRESS_PORT 变量，查询是否有外部负载均衡器</span><br><span class="line">kubectl get svc istio-ingressgateway -n istio-system</span><br><span class="line"></span><br><span class="line">EXTERNAL-IP是none或是pending说明没有问题</span><br><span class="line">修改istio的网关为nodeport模式　</span><br><span class="line"></span><br><span class="line">kubectl patch service istio-ingressgateway -n istio-system -p &apos;&#123;&quot;spec&quot;:&#123;&quot;type&quot;:&quot;NodePort&quot;&#125;&#125;&apos;</span><br><span class="line">采用nodeport方式暴露istio-ingressgateway</span><br><span class="line"></span><br><span class="line">export INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=&apos;&#123;.spec.ports[?(@.name==&quot;http2&quot;)].nodePort&#125;&apos;)</span><br><span class="line"></span><br><span class="line">export SECURE_INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath=&apos;&#123;.spec.ports[?(@.name==&quot;https&quot;)].nodePort&#125;&apos;)</span><br><span class="line"></span><br><span class="line">#获取 ingress IP 地址：</span><br><span class="line">export INGRESS_HOST=$(kubectl get po -l istio=ingressgateway -n istio-system -o &apos;jsonpath=&#123;.items[0].status.hostIP&#125;&apos;)</span><br><span class="line"></span><br><span class="line">查询URL</span><br><span class="line"></span><br><span class="line">echo $INGRESS_HOST:$INGRESS_PORT</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>istio</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程之信号量Semaphore</title>
    <url>/2017/05/11/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore/</url>
    <content><![CDATA[<h1 id="简介"><a href="/2017/05/11/java多线程之信号量Semaphore/#简介" class="headerlink" title="简介"></a>简介</h1><p>  信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。</p>
<p>  一个计数信号量。从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。拿到信号量的线程可以进入代码，否则就等待。通过acquire()和release()获取和释放访问许可。</p>
<h1 id="概念"><a href="/2017/05/11/java多线程之信号量Semaphore/#概念" class="headerlink" title="概念"></a>概念</h1><p>  Semaphore分为单值和多值两种，前者只能被一个线程获得，后者可以被若干个线程获得。<br>     以一个停车场运作为例。为了简单起见，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆不受阻碍的进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开两辆，则又可以放入两辆，如此往复。</p>
<p>  在这个停车场系统中，车位是公共资源，每辆车好比一个线程，看门人起的就是信号量的作用。</p>
<p>  更进一步，信号量的特性如下：信号量是一个非负整数（车位数），所有通过它的线程（车辆）都会将该整数减一（通过它当然是为了使用资源），当该整数值为零时，所有试图通过它的线程都将处于等待状态。在信号量上我们定义两种操作： Wait（等待） 和 Release（释放）。 当一个线程调用Wait（等待）操作时，它要么通过然后将信号量减一，要么一直等下去，直到信号量大于一或超时。Release（释放）实际上是在信号量上执行加操作，对应于车辆离开停车场，该操作之所以叫做“释放”是因为加操作实际上是释放了由信号量守护的资源。</p>
<p> 在java中，还可以设置该信号量是否采用公平模式，如果以公平方式执行，则线程将会按到达的顺序（FIFO）执行，如果是非公平，则可以后请求的有可能排在队列的头部。<br>JDK中定义如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Semaphore(int permits, boolean fair)</span><br></pre></td></tr></table></figure></p>
<p>创建具有给定的许可数和给定的公平设置的Semaphore。<br> Semaphore当前在多线程环境下被扩放使用，操作系统的信号量是个很重要的概念，在进程控制方面都有应用。Java并发库Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。比如在Windows下可以设置共享文件的最大客户端访问个数。</p>
<p>  Semaphore实现的功能就类似厕所有5个坑，假如有10个人要上厕所，那么同时只能有多少个人去上厕所呢？同时只能有5个人能够占用，当5个人中 的任何一个人让开后，其中等待的另外5个人中又有一个人可以占用了。另外等待的5个人中可以是随机获得优先机会，也可以是按照先来后到的顺序获得机会，这取决于构造Semaphore对象时传入的参数选项。单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另一个线程释放“锁”，这可应用于死锁恢复的一些场合。</p>
<h2 id="代码示例"><a href="/2017/05/11/java多线程之信号量Semaphore/#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DateTime: 2015年1月1日 下午6:41:01</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaPhore</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 线程池</span></span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 只能5个线程同时访问</span></span><br><span class="line">        <span class="keyword">final</span> Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 模拟20个客户端访问</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">50</span>; index++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> NO = index;</span><br><span class="line">            Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取许可</span></span><br><span class="line">                        semp.acquire();</span><br><span class="line">                        System.out.println(<span class="string">"Accessing: "</span> + NO);</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">6000</span>));</span><br><span class="line">                        <span class="comment">// 访问完后，释放</span></span><br><span class="line">                        semp.release();</span><br><span class="line">                        <span class="comment">//availablePermits()指的是当前信号灯库中有多少个可以被使用</span></span><br><span class="line">                        System.out.println(<span class="string">"-----------------"</span> + semp.availablePermits()); </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            exec.execute(run);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出线程池</span></span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm垃圾回收与调优</title>
    <url>/2019/05/30/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h3 id="jvm的模型"><a href="/2019/05/30/jvm垃圾回收与调优/#jvm的模型" class="headerlink" title="jvm的模型"></a>jvm的模型</h3><p>JVM堆内存被分为两部分<strong>年轻代</strong>（Young Generation）、<strong>老年代</strong>（Old Generation）和<strong>永久保存区</strong>（Perm Generation）。</p>
<p><img src="https://clyhs.github.io/images/java/jvm.png" alt="img"></p>
<h4 id="年轻代"><a href="/2019/05/30/jvm垃圾回收与调优/#年轻代" class="headerlink" title="年轻代"></a>年轻代</h4><p>年轻代是所有新对象产生的地方。当年轻代内存空间被用完时，就会触发垃圾回收。这个垃圾回收叫做<strong>Minor GC</strong>。年轻代被分为3个部分<strong>Enden区</strong>和两个<strong>Survivor区</strong>。</p>
<p>年轻代空间的要点：</p>
<ul>
<li>大多数新建的对象都位于Eden区。</li>
<li>当Eden区被对象填满时，就会执行Minor GC。并把所有存活下来的对象转移到其中一个survivor区。</li>
<li>Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区。</li>
<li>经过多次GC周期后，仍然存活下来的对象会被转移到年老代内存空间。通常这是在年轻代有资格提升到年老代前通过设定年龄阈值来完成的。</li>
</ul>
<h4 id="年老代"><a href="/2019/05/30/jvm垃圾回收与调优/#年老代" class="headerlink" title="年老代"></a>年老代</h4><p>年老代内存里包含了长期存活的对象和经过多次<strong>Minor GC</strong>后依然存活下来的对象。通常会在老年代内存被占满时进行垃圾回收。老年代的垃圾收集叫做<strong>Major GC</strong>。Major GC会花费更多的时间。</p>
<h4 id="永久区"><a href="/2019/05/30/jvm垃圾回收与调优/#永久区" class="headerlink" title="永久区"></a>永久区</h4><p>用于存放“永久”对象。这些对象管理着运行于JVM中的类和方法。</p>
<h3 id="jvm的垃圾回收"><a href="/2019/05/30/jvm垃圾回收与调优/#jvm的垃圾回收" class="headerlink" title="jvm的垃圾回收"></a>jvm的垃圾回收</h3><ul>
<li><strong>Serial GC</strong></li>
</ul>
<p>-XX:+UseSerialGC：Serial GC使用简单的<strong>标记、清除、压缩</strong>方法对年轻代和年老代进行垃圾回收，即Minor GC和Major GC。Serial GC在client模式（客户端模式）很有用，比如在简单的独立应用和CPU配置较低的机器</p>
<ul>
<li><strong>Parallel GC</strong></li>
</ul>
<p>-XX:+UseParallelGC：除了会产生N个线程来进行年轻代的垃圾收集外，Parallel GC和Serial GC几乎一样。这里的N是系统CPU的核数。我们可以使用 -XX:ParallelGCThreads=n 这个JVM选项来控制线程数量</p>
<ul>
<li><strong>CMS GC</strong> </li>
</ul>
<p>-XX:+UseConcMarkSweepGC：CMS收集器也被称为短暂停顿并发收集器。它是对年老代进行垃圾收集的。CMS收集器通过多线程并发进行垃圾回收，尽量减少垃圾收集造成的停顿。CMS收集器对年轻代进行垃圾回收使用的算法和Parallel收集器一样。这个垃圾收集器适用于不能忍受长时间停顿要求快速响应的应用。可使用 -XX:ParallelCMSThreads=n JVM选项来限制CMS收集器的线程数量。</p>
<ul>
<li><strong>G1 GC</strong></li>
</ul>
<p>-XX:+UseG1GC) G1（Garbage First）：垃圾收集器是在Java 7后才可以使用的特性，它的长远目标时代替CMS收集器。G1收集器是一个并行的、并发的和增量式压缩短暂停顿的垃圾收集器。G1收集器和其他的收集器运行方式不一样，不区分年轻代和年老代空间。它把堆空间划分为多个大小相等的区域</p>
<p><em>一般用得最多是cms gc 和G1 gc</em></p>
<h3 id="GC的参数解释"><a href="/2019/05/30/jvm垃圾回收与调优/#GC的参数解释" class="headerlink" title="GC的参数解释"></a>GC的参数解释</h3><p><strong>-XX:GCTimeRatio</strong> 垃圾收集时间占总时间的比率，如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1/（1+19）），默认值为99，就是允许最大1%（即1/（1+99））的垃圾收集时间。</p>
<p><strong>-XX:MaxTenuringThreshold</strong> 晋升老年代的最大年龄。默认为15，比如设为10，则对象在10次普通GC后将会被放入年老代</p>
<p><strong>-XX:+UseConcMarkSweepGC</strong> 开启CMS垃圾回收器</p>
<p><strong>-XX:CMSInitiatingOccupancyFraction</strong> 触发CMS收集器的内存比例。比如70%的意思就是说，当内存达到70%，就会开始进行CMS并发收集 </p>
<p><strong>-XX:CMSFullGCsBeforeCompaction</strong> 设置在几次CMS垃圾收集后，触发一次内存整理</p>
<p><strong>-XX:+ExplicitGCInvokesConcurrent</strong> System.gc()可以与应用程序并发执行。</p>
<p><strong>-XX:+UseCMSInitiatingOccupancyOnly</strong> 标志来命令JVM不基于运行时收集的数据来启动CMS垃圾收集周期。而是，当该标志被开启时，JVM通过CMSInitiatingOccupancyFraction的值进行每一次CMS收集，而不仅仅是第一次</p>
<p><strong>-XX:+CMSClassUnloadingEnabled</strong> 相对于并行收集器，CMS收集器默认不会对永久代进行垃圾回收。如果希望对永久代进行垃圾回收，可用设置标志</p>
<p><strong>-XX:+DisableExplicitGC</strong> 该标志将告诉JVM完全忽略系统的GC调用(system.gc())(不管使用的收集器是什么类型)</p>
<p><strong>-XX：+CMSConcurrentMTEnabled</strong> 当该标志被启用时，并发的CMS阶段将以多线程执行</p>
<p><strong>-XX：ConcGCThreads</strong> 比如value=4意味着CMS周期的所有阶段都以4个线程来执行</p>
<p><strong>-XX:SoftRefLRUPolicyMSPerMB=N</strong> 如果SoftReference引用对象的生存时长&lt;=空闲内存可保持软引用的最大时间范围，则不清除SoftReference所引用的对象；否则，则将其清除。soft reference 只会在垃圾回收时才会被清除，而垃圾回收并不总在发生。系统默认为一秒</p>
<p><strong>-XX:+UseG1GC</strong> 开启g1收集器</p>
<p><strong>-XX:InitiatingHeapOccupancyPercent=45</strong> 整个堆栈使用达到百分之多少的时候，启动GC周期. 基于整个堆，不仅仅是其中的某个代的占用情况，G1根据这个值来判断是否要触发GC周期, 0表示一直都在GC，默认值是45</p>
<p><strong>-XX:G1ReservePercent=n</strong> 预留多少内存，防止晋升失败的情况，默认值是10</p>
<p><strong>-XX:NewRatio=n</strong> 年轻代和老年代大小的比例，默认是2</p>
<p><strong>-XX:SurvivorRatio=n</strong> eden和survivor区域空间大小的比例，默认是8</p>
<p><strong>-XX:MaxGCPauseMillis=n</strong> 设置一个暂停时间期望目标，这是一个软目标，JVM会近可能的保证这个目标</p>
<p><em>参考 <a href="http://www.importnew.com/14086.html" target="_blank" rel="noopener">http://www.importnew.com/14086.html</a></em></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s安装部署</title>
    <url>/2022/05/10/k8s%20install/</url>
    <content><![CDATA[<h1 id="k8s-install"><a href="/2022/05/10/k8s install/#k8s-install" class="headerlink" title="k8s install"></a>k8s install</h1><blockquote>
<p>Kubernetes Cluster = N Master Node + N Worker Node：N主节点+N工作节点； N&gt;=1</p>
</blockquote>
<h2 id="ready-server"><a href="/2022/05/10/k8s install/#ready-server" class="headerlink" title="ready server"></a>ready server</h2><p>centos7 64</p>
<ul>
<li>master 192.168.2.221</li>
<li>node1  192.168.2.219</li>
<li>node2  192.168.2.220</li>
</ul>
<h2 id="kubeadm-install"><a href="/2022/05/10/k8s install/#kubeadm-install" class="headerlink" title="kubeadm install"></a>kubeadm install</h2><p><em>all server install such as:</em></p>
<h3 id="base-setting"><a href="/2022/05/10/k8s install/#base-setting" class="headerlink" title="base setting"></a>base setting</h3><blockquote>
<p>1、setting hostname</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname master</span><br><span class="line">hostnamectl set-hostname node1</span><br><span class="line">hostnamectl set-hostname node2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2、setting selinux</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i &apos;s/^SELINUX=enforcing$/SELINUX=permissive/&apos; /etc/selinux/config</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3、turn off swap</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swapoff -a  </span><br><span class="line">sed -ri &apos;s/.*swap.*/#&amp;/&apos; /etc/fstab</span><br></pre></td></tr></table></figure>
<blockquote>
<p>4、iptables could bridge</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<p>or do</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line"># </span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<blockquote>
<p>5、install kubelet、kubeadm、kubectl</p>
<p>kubectl 是供程序员使用的命令行，一般只安装在mater(总部)。</p>
<p>kubeadm 帮助程序员管理集群 (如设置主节点并创建主节点中的控制平面的组件)。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">exclude=kubelet kubeadm kubectl</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetes</span><br></pre></td></tr></table></figure>
<blockquote>
<p>6、start kubelet</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable --now kubelet</span><br><span class="line"># look at kubelet status</span><br><span class="line">systemctl status kubelet</span><br></pre></td></tr></table></figure>
<blockquote>
<p>7、use kubeadm to Cluster </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo tee ./images.sh &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">#!/bin/bash</span><br><span class="line">images=(</span><br><span class="line">kube-apiserver:v1.20.9</span><br><span class="line">kube-proxy:v1.20.9</span><br><span class="line">kube-controller-manager:v1.20.9</span><br><span class="line">kube-scheduler:v1.20.9</span><br><span class="line">coredns:1.7.0</span><br><span class="line">etcd:3.4.13-0</span><br><span class="line">pause:3.2</span><br><span class="line">)</span><br><span class="line">for imageName in $&#123;images[@]&#125; ; do</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/$imageName</span><br><span class="line">done</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x ./images.sh &amp;&amp; ./images.sh</span><br><span class="line"></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><em>finish install</em></p>
<p><strong>next copy vm to node1 node2</strong></p>
<blockquote>
<p>9、setting domain mapping to all vm(master,node1,node2)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;192.168.2.221  cluster-endpoint&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>
<blockquote>
<p>10、init master</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.2.221 \</span><br><span class="line">--control-plane-endpoint=cluster-endpoint \</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">--kubernetes-version v1.20.9 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=172.31.0.0/16</span><br></pre></td></tr></table></figure>
<p><strong><code>-pod-network-cidr=172.31.0.0/16</code> 非常重要，用于为pod分配ip地址</strong></p>
<ul>
<li>初始化主节点成功,同时给出一系列<strong>提示</strong>（接下来按提示操作）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ...</span><br><span class="line"># 【翻译】你的Kubernetes控制平面已经成功初始化</span><br><span class="line">[init] Using Kubernetes version: v1.20.9</span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING Service-Docker]: docker service is not enabled, please run &apos;systemctl enable docker.service&apos;</span><br><span class="line">        [WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/</span><br><span class="line">[preflight] Pulling images required for setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action in beforehand using &apos;kubeadm config images pull&apos;</span><br><span class="line">[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;</span><br><span class="line">[certs] Generating &quot;ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver&quot; certificate and key</span><br><span class="line">[certs] apiserver serving cert is signed for DNS names [centosdb cluster-endpoint kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.2.221]</span><br><span class="line">[certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;front-proxy-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/ca&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;etcd/server&quot; certificate and key</span><br><span class="line">[certs] etcd/server serving cert is signed for DNS names [centosdb localhost] and IPs [192.168.2.221 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/peer&quot; certificate and key</span><br><span class="line">[certs] etcd/peer serving cert is signed for DNS names [centosdb localhost] and IPs [192.168.2.221 127.0.0.1 ::1]</span><br><span class="line">[certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key</span><br><span class="line">[certs] Generating &quot;sa&quot; key and public key</span><br><span class="line">[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;</span><br><span class="line">[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file</span><br><span class="line">[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;</span><br><span class="line">[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;</span><br><span class="line">[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;</span><br><span class="line">[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s</span><br><span class="line">[apiclient] All control plane components are healthy after 16.003830 seconds</span><br><span class="line">[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace</span><br><span class="line">[kubelet] Creating a ConfigMap &quot;kubelet-config-1.20&quot; in namespace kube-system with the configuration for the kubelets in the cluster</span><br><span class="line">[upload-certs] Skipping phase. Please see --upload-certs</span><br><span class="line">[mark-control-plane] Marking the node centosdb as control-plane by adding the labels &quot;node-role.kubernetes.io/master=&apos;&apos;&quot; and &quot;node-role.kubernetes.io/control-plane=&apos;&apos; (deprecated)&quot;</span><br><span class="line">[mark-control-plane] Marking the node centosdb as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]</span><br><span class="line">[bootstrap-token] Using token: xxxid4.qfgy66yoykp07cjw</span><br><span class="line">[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to get nodes</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token</span><br><span class="line">[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster</span><br><span class="line">[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace</span><br><span class="line">[kubelet-finalize] Updating &quot;/etc/kubernetes/kubelet.conf&quot; to point to a rotatable kubelet client certificate and key</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of control-plane nodes by copying certificate authorities</span><br><span class="line">and service account keys on each node and then running the following as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join cluster-endpoint:6443 --token xxxid4.qfgy66yoykp07cjw \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:c00aaa55766bdfef9f92c04a1c7e8f871e9f270dc1619f47519ab6d3223e3450 \</span><br><span class="line">    --control-plane </span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join cluster-endpoint:6443 --token xxxid4.qfgy66yoykp07cjw \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:c00aaa55766bdfef9f92c04a1c7e8f871e9f270dc1619f47519ab6d3223e3450</span><br></pre></td></tr></table></figure>
<blockquote>
<p>10、按照英文提示执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>
<blockquote>
<p>11、 look  at all nodes</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line">NAME        STATUS     ROLES                  AGE   VERSION</span><br><span class="line">master     Ready    control-plane,master   17h   v1.20.9</span><br></pre></td></tr></table></figure>
<h3 id="install-network-components-calico"><a href="/2022/05/10/k8s install/#install-network-components-calico" class="headerlink" title="install network components calico"></a>install network components calico</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl https://docs.projectcalico.org/manifests/calico.yaml -O</span><br><span class="line"></span><br><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure>
<p><em>修改 calico.yaml 配置，使网段同 <code>--pod-network-cidr=172.31.0.0/16</code> 一致，除非是192.168**就不用改</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim calico.yaml </span><br><span class="line">?192.168 #vim工具搜索</span><br><span class="line"></span><br><span class="line"># no effect. This should fall within `--cluster-cidr`.</span><br><span class="line">- name: CALICO_IPV4POOL_CIDR</span><br><span class="line">    value: &quot;172.31.0.0/16&quot;</span><br><span class="line"># Disable file logging so `kubectl logs` works.</span><br></pre></td></tr></table></figure>
<p><em>常用命令</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看集群所有节点</span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">#根据配置文件，给集群创建资源</span><br><span class="line">kubectl apply -f xxxx.yaml</span><br><span class="line"></span><br><span class="line">#查看集群部署了哪些应用？</span><br><span class="line">docker ps   </span><br><span class="line"># 效果等于   </span><br><span class="line">kubectl get pods -A</span><br></pre></td></tr></table></figure>
<p><em>look at master status</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centosdb ~]# kubectl get pods -A</span><br><span class="line">NAMESPACE              NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system            calico-kube-controllers-6fcb5c5bcf-q5mkg     1/1     Running   0          17h</span><br><span class="line">kube-system            calico-node-8fnpb                            0/1     Running   0          17h</span><br><span class="line">kube-system            calico-node-l49k6                            0/1     Running   0          17h</span><br><span class="line">kube-system            calico-node-q5pd6                            0/1     Running   0          17h</span><br><span class="line">kube-system            coredns-5897cd56c4-kqvxd                     1/1     Running   0          17h</span><br><span class="line">kube-system            coredns-5897cd56c4-zkxmz                     1/1     Running   0          17h</span><br><span class="line">kube-system            etcd-centosdb                                1/1     Running   0          17h</span><br><span class="line">kube-system            kube-apiserver-centosdb                      1/1     Running   0          17h</span><br><span class="line">kube-system            kube-controller-manager-centosdb             1/1     Running   0          17h</span><br><span class="line">kube-system            kube-proxy-87h9h                             1/1     Running   0          17h</span><br><span class="line">kube-system            kube-proxy-b8zxc                             1/1     Running   0          17h</span><br><span class="line">kube-system            kube-proxy-vlhcs                             1/1     Running   0          17h</span><br><span class="line">kube-system            kube-scheduler-centosdb                      1/1     Running   0          17h</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将node1、node2 进入工作节点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubeadm join cluster-endpoint:6443 --token xxxid4.qfgy66yoykp07cjw \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:c00aaa55766bdfef9f92c04a1c7e8f871e9f270dc1619f47519ab6d3223e3450</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centosdb ~]# kubectl get nodes</span><br><span class="line">NAME         STATUS   ROLES                  AGE   VERSION</span><br><span class="line">node1   Ready    &lt;none&gt;                 17h   v1.20.9</span><br><span class="line">node2   Ready    &lt;none&gt;                 17h   v1.20.9</span><br><span class="line">master     Ready    control-plane,master   17h   v1.20.9</span><br></pre></td></tr></table></figure>
<h3 id="install-dashboard"><a href="/2022/05/10/k8s install/#install-dashboard" class="headerlink" title="install dashboard"></a>install dashboard</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml</span><br><span class="line"># or do</span><br><span class="line">kubectl apply -f recommended.yaml</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centosdb ~]# kubectl get pods -A</span><br><span class="line">kubernetes-dashboard   dashboard-metrics-scraper-79c5968bdc-qrbzf   1/1     Running   0          16h</span><br><span class="line">kubernetes-dashboard   kubernetes-dashboard-7448ffc97b-64tf2        1/1     Running   0          16h</span><br></pre></td></tr></table></figure>
<blockquote>
<p>设置访问端口</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard</span><br></pre></td></tr></table></figure>
<p>提示: 进入文件将<code>type: ClusterIP</code>改为<code>type: NodePort</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get svc -A | grep kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">[root@centosdb ~]# kubectl get svc -A | grep kubernetes-dashboard</span><br><span class="line">kubernetes-dashboard   dashboard-metrics-scraper   ClusterIP   10.96.117.164   &lt;none&gt;        8000/TCP                 16h</span><br><span class="line">kubernetes-dashboard   kubernetes-dashboard        NodePort    10.96.181.30    &lt;none&gt;        443:30104/TCP            16h</span><br></pre></td></tr></table></figure>
<p><em><a href="https://192.168.2.219:30104" target="_blank" rel="noopener">https://192.168.2.219:30104</a></em></p>
<blockquote>
<p>setting dashboard accout </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#vim dash.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f dash.yaml</span><br><span class="line"></span><br><span class="line"># generate dashboard token</span><br><span class="line"></span><br><span class="line">[root@centosdb ~]# kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath=&quot;&#123;.secrets[0].name&#125;&quot;) -o go-template=&quot;&#123;&#123;.data.token | base64decode&#125;&#125;&quot;</span><br><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6IndNSllNU3p0MzRJVDhoV0NWMEJqZkd5WmdveEpkcXExbEZmOHY1d21PUWcifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLXI4MnJiIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiI4ODQ3OWY5MC1jOTljLTQzNWYtYjkzMy04MWUwMDk5N2E0OWIiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZXJuZXRlcy1kYXNoYm9hcmQ6YWRtaW4tdXNlciJ9.YA23lwjuF3CW4pRYLOSFAPWeFtOQXNa7RPsz12v_twxOacvoZoZsxEpBJj0WO_TNSLk4luvHY4fhG3udfZxI_-IvJaPY667-C4AYENOIAQ1QCIU_Qo_NoyJCQ5WQfM_RpIsCng7X7dJy1sSs5UiceXFQfMDEfbUoSAZ4GViU_bXuloEaWkIfGl4c5RT_tuaDoDvHNjLRGUv_tQgpzAt6IZoZooLgsON1p0F9AIX8wJ-1c7BdvMa4quAvJ_eFgR65flLrfeWJH9lkz_gnz671jPqkVV_fRpL-H_767jHD1sKlS9wHqYVm-eu1p_gjISyPQUTdwrw72P7x_saMaG2XPA</span><br></pre></td></tr></table></figure>
<p>next login <em><a href="https://192.168.2.219:30104" target="_blank" rel="noopener">https://192.168.2.219:30104</a></em></p>
<p><strong>注：calico node不运行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kube-system            calico-node-8fnpb                            0/1     Running   0          17h</span><br><span class="line">kube-system            calico-node-l49k6                            0/1     Running   0          17h</span><br><span class="line">kube-system            calico-node-q5pd6                            0/1     Running   0          17h</span><br><span class="line"></span><br><span class="line">kubectl describe pod calico-node-8fnpb -n kube-system</span><br><span class="line"></span><br><span class="line">IRD: unable to connect to BIRDv4 socket: dial unix /var/run/calico/bird.ctl: connect: connection refused</span><br><span class="line">  Warning  Unhealthy  14m   kubelet            Readiness probe failed: 2022-05-07 03:01:44.179 [INFO][204] confd/health.go 180: Number of node(s) with BGP peering established = 0</span><br><span class="line">calico/node is not ready: BIRD is not ready: BGP not established with 192.168.2.219,192.168.2.220</span><br><span class="line">  Warning  Unhealthy  13m  kubelet  Readiness probe failed: 2022-05-07 03:01:54.107 [INFO][243] confd/health.go 180: Number of node(s) with BGP peering established = 0</span><br><span class="line">calico/node is not ready: BIRD is not ready: BGP not established with 192.168.2.219,192.168.2.220</span><br><span class="line">  Warning  Unhealthy  13m  kubelet  Readiness probe failed: 2022-05-07 03:02:04.112 [INFO][276] confd/health.go 180: Number of node(s) with BGP peering established = 0</span><br><span class="line">calico/node is not ready: BIRD is not ready: BGP not established with 192.168.2.219,192.168.2.220</span><br><span class="line">  Warning  Unhealthy  13m  kubelet  Readiness probe failed: 2022-05-07 03:02:14.133 [INFO][317] confd/health.go 180: Number of node(s) with BGP peering established = 0</span><br><span class="line">calico/node is not ready: BIRD is not ready: BGP not established with 192.168.2.219,192.168.2.220</span><br><span class="line">  Warning  Unhealthy  13m  kubelet  Readiness probe failed: 2022-05-07 03:02:24.106 [INFO][351] confd/health.go 180: Number of node(s) with BGP peering established = 0</span><br><span class="line">calico/node is not ready: BIRD is not ready: BGP not established with 192.168.2.219,192.168.2.220</span><br><span class="line">  Warning  Unhealthy  13m  kubelet  Readiness probe failed: 2022-05-07 03:02:34.133 [INFO][385] confd/health.go 180: Number of node(s) with BGP peering established = 0</span><br><span class="line">calico/node is not ready: BIRD is not ready: BGP not established with 192.168.2.219,192.168.2.220</span><br><span class="line">  Warning  Unhealthy  13m  kubelet  Readiness probe failed: 2022-05-07 03:02:44.119 [INFO][426] confd/health.go 180: Number of node(s) with BGP peering established = 0</span><br><span class="line">calico/node is not ready: BIRD is not ready: BGP not established with 192.168.2.219,192.168.2.220</span><br><span class="line">  Warning  Unhealthy  12m  kubelet  Readiness probe failed: 2022-05-07 03:02:54.108 [INFO][458] confd/health.go 180: Number of node(s) with BGP peering established = 0</span><br><span class="line">calico/node is not ready: BIRD is not ready: BGP not established with 192.168.2.219,192.168.2.220</span><br><span class="line">  Warning  Unhealthy  4m12s (x52 over 12m)  kubelet  (combined from similar events): Readiness probe failed: 2022-05-07 03:11:34.318 [INFO][2258] confd/health.go 180: Number of node(s) with BGP peering established = 0</span><br><span class="line">calico/node is not ready: BIRD is not ready: BGP not established with 192.168.2.219,192.168.2.220</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">kubectl edit daemonset calico-node -n kube-system</span><br><span class="line">- name: CALICO_IPV4POOL_CIDR</span><br><span class="line">  value: 172.31.0.0/16</span><br><span class="line">- name: IP_AUTODETECTION_METHOD</span><br><span class="line">  value: interface=eth0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods -A</span><br><span class="line">NAMESPACE              NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system            calico-node-bw8b9                            1/1     Running   0          35s</span><br><span class="line">kube-system            calico-node-g4dvb                            1/1     Running   0          50s</span><br><span class="line">kube-system            calico-node-tftp8                            1/1     Running   0          63s</span><br></pre></td></tr></table></figure>
<p><em>注意三台机必须相互能Ping得通</em></p>
<h3 id="namespace"><a href="/2022/05/10/k8s install/#namespace" class="headerlink" title="namespace"></a>namespace</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create ns hello</span><br><span class="line">kubectl delete ns hello</span><br><span class="line"></span><br><span class="line"># vi creates.yaml</span><br><span class="line">apiVersion: v1 # 版本</span><br><span class="line">kind: Namespace # 类型</span><br><span class="line">metadata:</span><br><span class="line">  name: hello</span><br><span class="line"></span><br><span class="line">kubectl apply -f creates.yaml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>运行Pod</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl run 【Pod名称】 --image=【镜像名称】</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl run mynginx --image=nginx</span><br><span class="line">pod/mynginx created</span><br><span class="line"></span><br><span class="line">[root@centosdb ~]# kubectl get pod</span><br><span class="line">NAME      READY   STATUS    RESTARTS   AGE</span><br><span class="line">mynginx   1/1     Running   0          81s</span><br></pre></td></tr></table></figure>
<p><em>常用命令</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看default名称空间的Pod</span><br><span class="line">kubectl get pod </span><br><span class="line">#描述</span><br><span class="line">kubectl describe pod 你自己的Pod名字</span><br><span class="line">#删除</span><br><span class="line">kubectl delete pod Pod名字</span><br><span class="line">#查看Pod的运行日志</span><br><span class="line">kubectl logs Pod名字</span><br><span class="line"></span><br><span class="line">#每个Pod-k8s都会分配一个ip</span><br><span class="line">kubectl get pod -owide</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl get pod -owide</span><br><span class="line">NAME      READY   STATUS    RESTARTS   AGE   IP               NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">mynginx   1/1     Running   0          27m   172.31.145.131   centosapp1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"></span><br><span class="line">#使用Pod的ip+pod里面运行容器的端口</span><br><span class="line">curl 172.31.145.131</span><br><span class="line"></span><br><span class="line">进入pod</span><br><span class="line">kubectl exec -ti [pod-name] -n &lt;your-namespace&gt; -- /bin/sh</span><br><span class="line">kubectl exec -ti mynginx -- /bin/sh</span><br></pre></td></tr></table></figure>
<h3 id="Deployment"><a href="/2022/05/10/k8s install/#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><blockquote>
<p>多副本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create deployment my-dep --image=nginx --replicas=3</span><br></pre></td></tr></table></figure>
<p>deployment.yaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: my-dep-02</span><br><span class="line">  name: my-dep-02</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: my-dep-02</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: my-dep-02</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        name: nginx</span><br></pre></td></tr></table></figure>
<blockquote>
<p>扩缩容</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl scale --replicas=5 deployment/my-dep</span><br><span class="line">kubectl edit deployment my-dep</span><br><span class="line"></span><br><span class="line">#修改replicas</span><br></pre></td></tr></table></figure>
<blockquote>
<p>滚动更新</p>
</blockquote>
<p>将一个pod集群在正常提供服务时从V1版本升级成 V2版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl set image deployment/my-dep-02 nginx=nginx:1.16.1 --record</span><br><span class="line">kubectl rollout status deployment/my-dep-02</span><br></pre></td></tr></table></figure>
<p>通过修改deployment配置文件实现更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl edit deployment/my-dep-02</span><br></pre></td></tr></table></figure>
<blockquote>
<p>版本回退</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl rollout history deployment/my-dep-02</span><br><span class="line">deployment.apps/my-dep-02 </span><br><span class="line">REVISION  CHANGE-CAUSE</span><br><span class="line">1         &lt;none&gt;</span><br><span class="line">2         &lt;none&gt;</span><br><span class="line">3         kubectl set image deployment/my-dep-02 nginx=nginx:1.16.1 --record=true</span><br></pre></td></tr></table></figure>
<p>查看某个历史详情</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl rollout history deployment/my-dep-02 --revision=3</span><br></pre></td></tr></table></figure>
<p>回滚到上次的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment/my-dep-02</span><br></pre></td></tr></table></figure>
<p>回滚到指定版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl rollout undo deployment/my-dep-02 --to-revision=1</span><br></pre></td></tr></table></figure>
<p>除了Deployment，k8s还有 <code>StatefulSet</code> 、<code>DaemonSet</code> 、<code>Job</code> 等 类型资源。我们都称为 <code>工作负载</code>。</p>
<p>有状态应用使用 <code>StatefulSet</code> 部署，无状态应用使用 <code>Deployment</code> 部署</p>
<h3 id="service"><a href="/2022/05/10/k8s install/#service" class="headerlink" title="service"></a>service</h3><p>以上内容的pod中的容器我们在外网都无法访问，使用Service来解决（–type=NodePort）。</p>
<blockquote>
<p>Service是 将一组 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener">Pods</a> 公开为网络服务的抽象方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl get service</span><br><span class="line">NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   21h</span><br></pre></td></tr></table></figure>
<blockquote>
<p>暴露deployment的服务和端口,进行端口映射，创建出具有ip地址的Service (pod的集群)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment my-dep-02 --port=8000 --target-port=80</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl get service</span><br><span class="line">NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP    22h</span><br><span class="line">my-dep-02    ClusterIP   10.96.226.142   &lt;none&gt;        8000/TCP   4s</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看pod的标签</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pod --show-labels</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl get pod --show-labels</span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE     LABELS</span><br><span class="line">my-dep-02-7b9d6bb69c-4fvl8   1/1     Running   0          5m31s   app=my-dep-02,pod-template-hash=7b9d6bb69c</span><br><span class="line">my-dep-02-7b9d6bb69c-j4mjk   1/1     Running   0          5m31s   app=my-dep-02,pod-template-hash=7b9d6bb69c</span><br><span class="line">my-dep-02-7b9d6bb69c-k7lhl   1/1     Running   0          5m31s   app=my-dep-02,pod-template-hash=7b9d6bb69c</span><br><span class="line">mynginx                      1/1     Running   0          157m    run=mynginx</span><br><span class="line">#使用标签检索Pod</span><br><span class="line">kubectl get pod -l app=my-dep-02</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看service/my-dep-02 的yaml配置文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get service/my-dep-02 -o yaml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>重里面pod访问</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl exec -ti my-dep-02-7b9d6bb69c-4fvl8 -- /bin/sh</span><br><span class="line"># curl my-dep-02.default.svc:8000</span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除Service</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl delete service/my-dep-02</span><br></pre></td></tr></table></figure>
<blockquote>
<p>clusterIP</p>
</blockquote>
<ul>
<li>默认就是ClusterIP 等同于没有–type的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment my-dep-02 --port=8000 --target-port=80 --type=ClusterIP</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NodePort</p>
</blockquote>
<ul>
<li>集群外可以访问</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment my-dep-02 --port=8000 --target-port=80 --type=NodePort</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl get service</span><br><span class="line">NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes   ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP          22h</span><br><span class="line">my-dep-02    NodePort    10.96.200.109   &lt;none&gt;        8000:30037/TCP   10s</span><br></pre></td></tr></table></figure>
<p> <strong>ip+port映射</strong>: 集群外<code>（mater、node1、node2的ip):30037</code> 映射到 <code>10.96.200.109:8000</code></p>
<p>外网访问 可以 <a href="http://192.168.2.219:30037" target="_blank" rel="noopener">http://192.168.2.219:30037</a></p>
<h3 id="Ingress-网关"><a href="/2022/05/10/k8s install/#Ingress-网关" class="headerlink" title="Ingress(网关)"></a>Ingress(网关)</h3><blockquote>
<p>Ingress：Service的统一网关入口（如百度的统一域名访问，统一Service层），Ingress是k8s机器集群的统一入口，请求流量先经过Ingress（入口）再进入集群内接受服务。</p>
<p> service是为一组pod服务提供一个统一集群内访问入口或外部访问的随机端口，而ingress做得是通过反射的形式对服务进行分发到对应的service上。</p>
<p>service一般是针对内部的，集群内部调用，而ingress应该是针对外部调用的</p>
<p>service只是开了端口，可以通过服务器IP:端口的方式去访问，但是服务器IP还是可变的，Ingress应该就是作为网关去转发</p>
<p>因为有很多服务,入口不统一,不方便管理</p>
</blockquote>
<blockquote>
<p>安装ingress</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://github.com/kubernetes/ingress-nginx/blob/controller-v0.47.0/deploy/static/provider/baremetal/deploy.yaml</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi deploy.yaml</span><br><span class="line">#将image的值改为如下值：</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/ingress-nginx-controller:v0.46.0</span><br><span class="line"></span><br><span class="line">kubectl apply -f deploy.yaml</span><br></pre></td></tr></table></figure>
<blockquote>
<p>查看安装结果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pod,svc -n ingress-nginx</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl get pod,svc -n ingress-nginx</span><br><span class="line">NAME                                            READY   STATUS              RESTARTS   AGE</span><br><span class="line">pod/ingress-nginx-admission-create-j92kq        0/1     Completed           0          2m27s</span><br><span class="line">pod/ingress-nginx-admission-patch-2pmwz         0/1     Completed           2          2m27s</span><br><span class="line">pod/ingress-nginx-controller-65bf56f7fc-8b4nk   0/1     ContainerCreating   0          2m27s</span><br></pre></td></tr></table></figure>
<ul>
<li>新建了Service，以NodePort方式暴露了端口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl get service -A | grep ingress</span><br><span class="line">ingress-nginx          ingress-nginx-controller             NodePort    10.96.160.237   &lt;none&gt;        80:32335/TCP,443:30536/TCP   3m29s</span><br><span class="line">ingress-nginx          ingress-nginx-controller-admission   ClusterIP   10.96.138.149   &lt;none&gt;        443/TCP                      3m29s</span><br></pre></td></tr></table></figure>
<p>映射：32335,30536</p>
<p><a href="http://192.168.2.221:30536/，bad" target="_blank" rel="noopener">http://192.168.2.221:30536/，bad</a> request</p>
<p><a href="http://192.168.2.221:32335" target="_blank" rel="noopener">http://192.168.2.221:32335</a> , notfound</p>
<ul>
<li>安装测试环境</li>
</ul>
<blockquote>
<p>应用配置文件，部署了2个Deployment,2个Service</p>
</blockquote>
<p>ingresstest.yaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: hello-server</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: hello-server</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: hello-server</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: hello-server</span><br><span class="line">        image: registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/hello-server</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9000</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-demo</span><br><span class="line">  name: nginx-demo</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-demo</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-demo</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        name: nginx</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-demo</span><br><span class="line">  name: nginx-demo</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx-demo</span><br><span class="line">  ports:</span><br><span class="line">  - port: 8000</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 80</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: hello-server</span><br><span class="line">  name: hello-server</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    app: hello-server</span><br><span class="line">  ports:</span><br><span class="line">  - port: 8000</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 9000</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl apply -f ingresstest.yaml </span><br><span class="line">deployment.apps/hello-server created</span><br><span class="line">deployment.apps/nginx-demo created</span><br><span class="line">service/nginx-demo created</span><br><span class="line">service/hello-server created</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl get service</span><br><span class="line">NAME           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">hello-server   ClusterIP   10.96.121.161   &lt;none&gt;        8000/TCP         69s</span><br><span class="line">kubernetes     ClusterIP   10.96.0.1       &lt;none&gt;        443/TCP          22h</span><br><span class="line">my-dep-02      NodePort    10.96.200.109   &lt;none&gt;        8000:30037/TCP   30m</span><br><span class="line">nginx-demo     ClusterIP   10.96.221.97    &lt;none&gt;        8000/TCP         69s</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl get deployment -o wide</span><br><span class="line">NAME           READY   UP-TO-DATE   AVAILABLE   AGE     CONTAINERS     IMAGES                                                          SELECTOR</span><br><span class="line">hello-server   2/2     2            2           2m48s   hello-server   registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/hello-server   app=hello-server</span><br><span class="line">my-dep-02      3/3     3            3           55m     nginx          nginx                                                           app=my-dep-02</span><br><span class="line">nginx-demo     2/2     2            2           2m48s   nginx          nginx                                                           app=nginx-demo</span><br><span class="line"></span><br><span class="line">[root@master ~]#  kubectl get pods -o wide</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE     IP               NODE         NOMINATED NODE   READINESS GATES</span><br><span class="line">hello-server-6cbb679d85-5t2t4   1/1     Running   0          3m34s   172.31.145.140   centosapp1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">hello-server-6cbb679d85-88ndh   1/1     Running   0          3m34s   172.31.145.139   centosapp1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">my-dep-02-7b9d6bb69c-4fvl8      1/1     Running   0          56m     172.31.145.136   centosapp1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">my-dep-02-7b9d6bb69c-j4mjk      1/1     Running   0          56m     172.31.19.198    centosapp2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">my-dep-02-7b9d6bb69c-k7lhl      1/1     Running   0          56m     172.31.145.137   centosapp1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">mynginx                         1/1     Running   0          3h28m   172.31.145.131   centosapp1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-demo-7d56b74b84-rkjcd     1/1     Running   0          3m34s   172.31.19.202    centosapp2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-demo-7d56b74b84-twfms     1/1     Running   0          3m34s   172.31.19.201    centosapp2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>域名访问</p>
</blockquote>
<ul>
<li>访问 hello.test.com 的请求由 hello-server (Service)集群处理</li>
<li>访问 demo.test.com 的请求由 nginx-demo (Service)集群处理</li>
<li>Ingress(网关)根据请求的域名分配对应的Service去处理</li>
</ul>
<p>ingresscom.yaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress  # 类型</span><br><span class="line">metadata:</span><br><span class="line">  name: ingress-host-bar</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: &quot;hello.test.com&quot; #域名</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - pathType: Prefix # 前缀</span><br><span class="line">        path: &quot;/&quot;</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: hello-server # Service 名称</span><br><span class="line">            port:</span><br><span class="line">              number: 8000 # 端口</span><br><span class="line">  - host: &quot;demo.test.com&quot;</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - pathType: Prefix</span><br><span class="line">        path: &quot;/nginx&quot;  # 把请求会转给下面的service，下面的service一定要能处理这个路径，不能处理就是404</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: nginx-demo  # java，比如使用路径重写，去掉前缀nginx</span><br><span class="line">            port:</span><br><span class="line">              number: 8000</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl apply -f ingresscom.yaml </span><br><span class="line">ingress.networking.k8s.io/ingress-host-bar created</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl get ingress</span><br><span class="line">NAME               CLASS   HOSTS                          ADDRESS         PORTS   AGE</span><br><span class="line">ingress-host-bar   nginx   hello.test.com,demo.test.com   192.168.2.220   80      2m47s</span><br></pre></td></tr></table></figure>
<ul>
<li>windows 配置域名映射（域名映射文件地址：<code>C:\Windows\System32\drivers\etc</code>）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.2.220 hello.test.com </span><br><span class="line">192.168.2.220 demo.test.com</span><br></pre></td></tr></table></figure>
<p>浏览器：<a href="http://hello.test.com:32335/" target="_blank" rel="noopener">http://hello.test.com:32335/</a></p>
<p>hello world!</p>
<p>浏览器：<a href="http://demo.test.com:30536/" target="_blank" rel="noopener">http://demo.test.com:30536/</a>  nginx是由Ingress层返回的</p>
<p>400 bad request</p>
<p>nginx</p>
<ul>
<li>修改Ingress配置文件,将<code>path: &quot;/nginx&quot;</code>改成<code>path: &quot;/nginx.html&quot;</code></li>
</ul>
<p>浏览器：<a href="http://demo.test.com:32335/nginx.html" target="_blank" rel="noopener">http://demo.test.com:32335/nginx.html</a></p>
<p>404 not found</p>
<p>nginx/1.21.5</p>
<p>问题： path: “/nginx.html” 与 path: “/” 为什么会有不同的效果？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl edit ingress ingress-host-bar</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>修改配置文件 ingresscom.yaml</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: networking.k8s.io/v1</span><br><span class="line">kind: Ingress  </span><br><span class="line">metadata:</span><br><span class="line">  annotations: # 路径重写配置功能开启</span><br><span class="line">    nginx.ingress.kubernetes.io/rewrite-target: /$2 </span><br><span class="line">  name: ingress-host-bar</span><br><span class="line">spec:</span><br><span class="line">  ingressClassName: nginx</span><br><span class="line">  rules:</span><br><span class="line">  - host: &quot;hello.test.com&quot;</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - pathType: Prefix</span><br><span class="line">        path: &quot;/&quot;</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: hello-server</span><br><span class="line">            port:</span><br><span class="line">              number: 8000</span><br><span class="line">  - host: &quot;demo.test.com&quot;</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - pathType: Prefix</span><br><span class="line">        path: &quot;/nginx(/|$)(.*)&quot;  # 配置忽略/nginx</span><br><span class="line">        backend:</span><br><span class="line">          service:</span><br><span class="line">            name: nginx-demo </span><br><span class="line">            port:</span><br><span class="line">              number: 8000</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl apply -f ingresscom.yaml </span><br><span class="line">ingress.networking.k8s.io/ingress-host-bar configured</span><br></pre></td></tr></table></figure>
<p><a href="http://demo.test.com:32335/nginx.html" target="_blank" rel="noopener">http://demo.test.com:32335/nginx.html</a></p>
<p><a href="http://demo.test.com:32335" target="_blank" rel="noopener">http://demo.test.com:32335</a></p>
<p>都返回</p>
<p>404 not found</p>
<p>nginx</p>
<h3 id="存储抽象"><a href="/2022/05/10/k8s install/#存储抽象" class="headerlink" title="存储抽象"></a>存储抽象</h3><blockquote>
<p>所有节点都安装nfs</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y nfs-utils</span><br></pre></td></tr></table></figure>
<blockquote>
<p>nfs主节点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;/nfs/data/ *(insecure,rw,sync,no_root_squash)&quot; &gt; /etc/exports</span><br><span class="line"></span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line">systemctl enable rpcbind --now</span><br><span class="line">systemctl enable nfs-server --now</span><br><span class="line">#配置生效</span><br><span class="line">exportfs -r</span><br><span class="line"></span><br><span class="line">[root@master ~]# exportfs</span><br><span class="line">/nfs/data       &lt;world&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从节点</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">showmount -e 192.168.2.221</span><br><span class="line">[root@node1 ~]# showmount -e 192.168.2.221</span><br><span class="line">Export list for 192.168.2.221:</span><br><span class="line">/nfs/data *</span><br><span class="line"></span><br><span class="line">#执行以下命令挂载nfs服务器上的共享目录到本机路径/root/nfsmount</span><br><span class="line">mkdir -p /nfs/data</span><br><span class="line"></span><br><span class="line">mount -t nfs 192.168.2.221:/nfs/data /nfs/data</span><br><span class="line">#写入一个测试文件</span><br><span class="line">echo &quot;hello nfs server&quot; &gt; /nfs/data/test.txt</span><br></pre></td></tr></table></figure>
<p>在其它服务器查看test.txt</p>
<h4 id="nfs（原生）方式数据挂载"><a href="/2022/05/10/k8s install/#nfs（原生）方式数据挂载" class="headerlink" title="nfs（原生）方式数据挂载"></a>nfs（原生）方式数据挂载</h4><p>在所有服务器创建目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /nfs/data/nginx-pv/</span><br></pre></td></tr></table></figure>
<p>mountnfs.yaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-pv-demo</span><br><span class="line">  name: nginx-pv-demo</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2 </span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-pv-demo</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-pv-demo</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        name: nginx</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: html</span><br><span class="line">          mountPath: /usr/share/nginx/html</span><br><span class="line">      volumes:</span><br><span class="line">        - name: html</span><br><span class="line">          nfs:</span><br><span class="line">            server: 192.168.2.221</span><br><span class="line">            path: /nfs/data/nginx-pv/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f mountnfs.yaml</span><br><span class="line">cd /nfs/data/nginx-pv/</span><br><span class="line">echo &quot;Hello Mount&quot; &gt; index.html</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get pods -o wide</span><br><span class="line"></span><br><span class="line">nginx-pv-demo-587489dfcf-ljwqr   1/1     Running   0          85s     172.31.145.141   centosapp1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-pv-demo-587489dfcf-ssc2c   1/1     Running   0          85s     172.31.19.203    centosapp2   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# curl 172.31.19.203</span><br><span class="line">Hello Mount</span><br></pre></td></tr></table></figure>
<h4 id="PV-持久卷-和PVC-持久卷申明"><a href="/2022/05/10/k8s install/#PV-持久卷-和PVC-持久卷申明" class="headerlink" title="PV(持久卷)和PVC(持久卷申明)"></a>PV(持久卷)和PVC(持久卷申明)</h4><p>NFS(原生)方式数据挂载存在一些问题：</p>
<ul>
<li>目录要自己创建</li>
<li>Deployment及其pod删除后,服务器目录数据依旧存在</li>
<li>挂载容量没有限制</li>
</ul>
<p>PV：持久卷（Persistent Volume），将应用需要持久化的数据保存到指定位置（存放持久化数据的目录就是持久卷）</p>
<p> PVC：持久卷申明（Persistent Volume Claim），申明需要使用的持久卷规格 （申请持久卷的申请书）</p>
<p>静态供应： 提取指定位置和空间大小</p>
<p>动态供应：位置和空间大小由pv自动创建</p>
<blockquote>
<p>创建pv池</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在master</span><br><span class="line">mkdir -p /nfs/data/01</span><br><span class="line">mkdir -p /nfs/data/02</span><br><span class="line">mkdir -p /nfs/data/03</span><br></pre></td></tr></table></figure>
<p>创建三个 PV（持久卷）<strong>静态供应的方式</strong>，配置文件createPV.yaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume # 类型</span><br><span class="line">metadata:</span><br><span class="line">  name: pv01-10m # 名称</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 10M # 持久卷空间大小</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany # 多节点可读可写</span><br><span class="line">  storageClassName: nfs # 存储类名</span><br><span class="line">  nfs:</span><br><span class="line">    path: /nfs/data/01 # pc目录位置</span><br><span class="line">    server: 192.168.2.221</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv02-1gi</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 1Gi # 持久卷空间大小</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  storageClassName: nfs</span><br><span class="line">  nfs:</span><br><span class="line">    path: /nfs/data/02 # pc目录位置</span><br><span class="line">    server: 192.168.2.221</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: pv03-3gi</span><br><span class="line">spec:</span><br><span class="line">  capacity:</span><br><span class="line">    storage: 3Gi # 持久卷空间大小</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  storageClassName: nfs</span><br><span class="line">  nfs:</span><br><span class="line">    path: /nfs/data/03 # pc目录位置</span><br><span class="line">    server: 192.168.2.221</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl apply -f createPV.yaml</span><br><span class="line">persistentvolume/pv01-10m created</span><br><span class="line">persistentvolume/pv02-1gi created</span><br><span class="line">persistentvolume/pv03-3gi created</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl get persistentvolume</span><br><span class="line">NAME       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE</span><br><span class="line">pv01-10m   10M        RWX            Retain           Available           nfs                     48s</span><br><span class="line">pv02-1gi   1Gi        RWX            Retain           Available           nfs                     48s</span><br><span class="line">pv03-3gi   3Gi        RWX            Retain           Available           nfs                     48s</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建PVC</p>
</blockquote>
<p>createPVC.yaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: PersistentVolumeClaim # 类型</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-pvc # PVC名称</span><br><span class="line">spec:</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteMany</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 200Mi # 需要空间</span><br><span class="line">  storageClassName: nfs # 要对应PV的storageClassName</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl apply -f createPVC.yaml </span><br><span class="line">persistentvolumeclaim/nginx-pvc created</span><br><span class="line">[root@master ~]# kubectl get persistentvolumeclaim</span><br><span class="line">NAME        STATUS   VOLUME     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">nginx-pvc   Bound    pv02-1gi   1Gi        RWX            nfs            30s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看PC,状态Bound(绑定),说明已经被使用,绑定信息： default/nginx-pvc =&gt; 名称空间/PVC名称</span><br><span class="line">[root@master ~]# kubectl get pv</span><br><span class="line">NAME       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM               STORAGECLASS   REASON   AGE</span><br><span class="line">pv01-10m   10M        RWX            Retain           Available                       nfs                     4m47s</span><br><span class="line">pv02-1gi   1Gi        RWX            Retain           Bound       default/nginx-pvc   nfs                     4m47s</span><br><span class="line">pv03-3gi   3Gi        RWX            Retain           Available                       nfs                     4m47s</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建Deployment ，让Deployment中的Pod绑定PVC</p>
</blockquote>
<p>boundPVC.yaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx-deploy-pvc # Deployment名称</span><br><span class="line">  name: nginx-deploy-pvc</span><br><span class="line">spec:</span><br><span class="line">  replicas: 2 # pod数量</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx-deploy-pvc</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx-deploy-pvc</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - image: nginx</span><br><span class="line">        name: nginx</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - name: html</span><br><span class="line">          mountPath: /usr/share/nginx/html # 挂载目录</span><br><span class="line">      volumes:</span><br><span class="line">        - name: html</span><br><span class="line">          persistentVolumeClaim:</span><br><span class="line">            claimName: nginx-pvc  # pvc 的名称</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]#  kubectl apply -f boundPVC.yaml</span><br><span class="line">deployment.apps/nginx-deploy-pvc created</span><br></pre></td></tr></table></figure>
<blockquote>
<p>向挂载目录 <code>/nfs/data/02</code>写入测试文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# cd /nfs/data/02</span><br><span class="line">[root@master 02]# echo &quot;boundPVC test nginx&quot; &gt; index.html</span><br><span class="line"></span><br><span class="line">[root@master 02]# kubectl get pod -o wide</span><br><span class="line">nginx-deploy-pvc-79fc8558c7-8m9nn   1/1     Running   0          97s     172.31.19.204    centosapp2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-deploy-pvc-79fc8558c7-s97vh   1/1     Running   0          97s     172.31.145.142   centosapp1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<h4 id="configMap-配置集"><a href="/2022/05/10/k8s install/#configMap-配置集" class="headerlink" title="configMap(配置集)"></a>configMap(配置集)</h4><p>ConfigMap 缩写为cm</p>
<p>ConfigMap（配置集）：用于配置文件挂载，抽取应用配置，并且可以自动更新。</p>
<blockquote>
<p>redis.conf内容如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl create configmap redis-conf --from-file=redis.conf</span><br><span class="line">configmap/redis-conf created</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl get configmap</span><br><span class="line">NAME               DATA   AGE</span><br><span class="line">kube-root-ca.crt   1      24h</span><br><span class="line">redis-conf         1      76s</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get configmap redis-conf -o yaml</span><br></pre></td></tr></table></figure>
<p>创建redistest.yaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod # 类型</span><br><span class="line">metadata:</span><br><span class="line">  name: redis # pod名称</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: redis</span><br><span class="line">    image: redis # 镜像</span><br><span class="line">    command:</span><br><span class="line">      - redis-server</span><br><span class="line">      - &quot;/redis-master/redis.conf&quot;  #指的是redis容器内部的位置</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 6379 </span><br><span class="line">    volumeMounts: # 配置卷挂载</span><br><span class="line">    - mountPath: /data </span><br><span class="line">      name: data 	# 卷挂载名称  对应 下面的 挂载卷 data</span><br><span class="line">    - mountPath: /redis-master</span><br><span class="line">      name: config	 # 卷挂载名称  对应 下面的 挂载卷 config</span><br><span class="line">  volumes: # 挂载卷</span><br><span class="line">    - name: data </span><br><span class="line">      emptyDir: &#123;&#125; </span><br><span class="line">    - name: config </span><br><span class="line">      configMap:   # 配置集</span><br><span class="line">        name: redis-conf</span><br><span class="line">        items:</span><br><span class="line">        - key: redis.conf</span><br><span class="line">          path: redis.conf</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl apply -f redistest.yaml </span><br><span class="line">pod/redis created</span><br><span class="line"></span><br><span class="line">kubectl exec -ti redis -- /bin/sh</span><br><span class="line">cd ../redis-manager</span><br><span class="line">more redis.conf</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<p>修改配置集的redis.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl edit configmap redis-conf</span><br></pre></td></tr></table></figure>
<p>加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centosdb ~]# kubectl exec -ti redis -- /bin/sh</span><br><span class="line"># cd ../</span><br><span class="line"># ls</span><br><span class="line">bin   data  etc   lib    media  opt   redis-master  run   srv  tmp  var</span><br><span class="line">boot  dev   home  lib64  mnt    proc  root          sbin  sys  usr</span><br><span class="line"># cd redis-master</span><br><span class="line"># more redis.conf</span><br><span class="line">appendonly yes</span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure>
<h4 id="secret"><a href="/2022/05/10/k8s install/#secret" class="headerlink" title="secret"></a>secret</h4><p> Secret 对象类型<strong>用来保存敏感信息</strong>，例如密码、OAuth 令牌和 SSH 密钥。 将这些信息放在 secret 中比放在 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-overview/" target="_blank" rel="noopener">Pod</a> 的定义或者 <a href="https://kubernetes.io/zh/docs/reference/glossary/?all=true#term-image" target="_blank" rel="noopener">容器镜像</a> 中来说更加安全和灵活。原理同ConfigMap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry 【Secret的名称】 \</span><br><span class="line">  --docker-server=【你的镜像仓库服务器】 \</span><br><span class="line">  --docker-username=【你的用户名】 \</span><br><span class="line">  --docker-password=【你的密码】 \</span><br><span class="line">  --docker-email=【你的邮箱地址】</span><br></pre></td></tr></table></figure>
<p>secret01.yaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: private-nginx # pod 名称</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: private-nginx</span><br><span class="line">    image: dockerywl/mysql # 私有镜像名称</span><br></pre></td></tr></table></figure>
<p>查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl get secret</span><br></pre></td></tr></table></figure>
<p><em>来源：<a href="https://blog.csdn.net/weixin_46703850/article/details/122922090" target="_blank" rel="noopener">https://blog.csdn.net/weixin_46703850/article/details/122922090</a></em></p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s安装kubesphere</title>
    <url>/2022/05/10/k8s%20kubesphere/</url>
    <content><![CDATA[<h1 id="kubesphere-on-k8s"><a href="/2022/05/10/k8s kubesphere/#kubesphere-on-k8s" class="headerlink" title="kubesphere on k8s"></a>kubesphere on k8s</h1><blockquote>
<p>helm install on master</p>
<p>tiller install on master</p>
<p>openEBS install on master</p>
</blockquote>
<h2 id="helm"><a href="/2022/05/10/k8s kubesphere/#helm" class="headerlink" title="helm"></a>helm</h2><ul>
<li>包含两个组件，分别是 helm 客户端 和 Tiller 服务器</li>
<li><strong>Tiller</strong> 是 Helm 的服务端。Tiller 负责接收 Helm 的请求，与 k8s 的 apiserver 交互，根据chart<br>来生成一个 release 并管理 release</li>
<li><strong>chart</strong> Helm的打包格式叫做chart，所谓chart就是一系列文件, 它描述了一组相关的 k8s 集群资源</li>
<li><strong>release</strong> 使用 helm install 命令在 Kubernetes 集群中部署的 Chart 称为 Release</li>
<li><p><strong>Repoistory</strong> Helm chart 的仓库，Helm 客户端通过 HTTP 协议来访问存储库中 chart 的索引文件和压缩包</p>
</li>
<li><p>download <a href="https://get.helm.sh/helm-v3.6.1-linux-amd64.tar.gz" target="_blank" rel="noopener">https://get.helm.sh/helm-v3.6.1-linux-amd64.tar.gz</a></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zvxf helm-v2.16.3-linux-amd64.tar.gz</span><br><span class="line">cd cd linux-amd64/</span><br><span class="line">cp helm /usr/local/bin/</span><br><span class="line">cp tiller /usr/local/bin/</span><br><span class="line"></span><br><span class="line">[root@master ~]# helm init</span><br><span class="line">Creating /root/.helm </span><br><span class="line">Creating /root/.helm/repository </span><br><span class="line">Creating /root/.helm/repository/cache </span><br><span class="line">Creating /root/.helm/repository/local </span><br><span class="line">Creating /root/.helm/plugins </span><br><span class="line">Creating /root/.helm/starters </span><br><span class="line">Creating /root/.helm/cache/archive </span><br><span class="line">Creating /root/.helm/repository/repositories.yaml </span><br><span class="line">Adding stable repo with URL: https://kubernetes-charts.storage.googleapis.com </span><br><span class="line">Error: error initializing: Looks like &quot;https://kubernetes-charts.storage.googleapis.com&quot; is not a valid chart repository or cannot be reached: Failed to fetch https://kubernetes-charts.storage.googleapis.com/index.yaml : 403 Forbidden</span><br><span class="line"></span><br><span class="line">[root@master ~]# helm version</span><br><span class="line">Client: &amp;version.Version&#123;SemVer:&quot;v2.16.3&quot;, GitCommit:&quot;1ee0254c86d4ed6887327dabed7aa7da29d7eb0d&quot;, GitTreeState:&quot;clean&quot;&#125;</span><br><span class="line">Error: could not find tiller</span><br></pre></td></tr></table></figure>
<h2 id="tiller"><a href="/2022/05/10/k8s kubesphere/#tiller" class="headerlink" title="tiller"></a>tiller</h2><p>tiller.yaml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: tiller</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: tiller</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line"> - kind: ServiceAccount</span><br><span class="line">    name: tiller</span><br><span class="line">    namespace: kube-system</span><br></pre></td></tr></table></figure>
<p>初始化helm服务端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm init --service-account tiller --tiller-image registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.16.3 --stable-repo-url https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</span><br><span class="line">如下：</span><br><span class="line">Creating /root/.helm/repository/repositories.yaml </span><br><span class="line">Adding stable repo with URL: https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts </span><br><span class="line">Adding local repo with URL: http://127.0.0.1:8879/charts </span><br><span class="line">$HELM_HOME has been configured at /root/.helm.</span><br><span class="line"></span><br><span class="line">Tiller (the Helm server-side component) has been installed into your Kubernetes Cluster.</span><br><span class="line">Please note: by default, Tiller is deployed with an insecure &apos;allow unauthenticated users&apos; policy.</span><br><span class="line">To prevent this, run `helm init` with the --tiller-tls-verify flag.</span><br><span class="line">For more information on securing your installation see: https://docs.helm.sh/using_helm/#securing-your-helm-installation</span><br><span class="line">#查询</span><br><span class="line">kubectl get pod -n kube-system</span><br><span class="line">tiller-deploy-7bf45f97c7-c2978             0/1     ContainerCreating   0          63s</span><br><span class="line">#过一会儿再查</span><br><span class="line">tiller-deploy-7bf45f97c7-c2978             1/1     Running   0          3m37s</span><br></pre></td></tr></table></figure>
<p>修改镜像地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# helm repo add stable http://mirror.azure.cn/kubernetes/charts</span><br><span class="line">&quot;stable&quot; has been added to your repositories</span><br></pre></td></tr></table></figure>
<h2 id="openEBS"><a href="/2022/05/10/k8s kubesphere/#openEBS" class="headerlink" title="openEBS"></a>openEBS</h2><p>确认 master 节点是否有 Taint，如下看到 master 节点有 Taint</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl describe node master | grep Taint</span><br><span class="line">Taints:             node-role.kubernetes.io/master:NoSchedule</span><br></pre></td></tr></table></figure>
<p>先去掉master的Taint:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl taint nodes master node-role.kubernetes.io/master:NoSchedule-</span><br><span class="line">node/centosdb untainted</span><br></pre></td></tr></table></figure>
<p>安装openEBS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl create ns openebs</span><br><span class="line">helm install --namespace openebs --name openebs stable/openebs --version 1.5.0</span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line">The OpenEBS has been installed. Check its status by running:</span><br><span class="line">$ kubectl get pods -n openebs</span><br><span class="line"></span><br><span class="line">For dynamically creating OpenEBS Volumes, you can either create a new StorageClass or</span><br><span class="line">use one of the default storage classes provided by OpenEBS.</span><br><span class="line"></span><br><span class="line">Use `kubectl get sc` to see the list of installed OpenEBS StorageClasses. A sample</span><br><span class="line">PVC spec using `openebs-jiva-default` StorageClass is given below:</span><br></pre></td></tr></table></figure>
<p>等几份钟，安装 OpenEBS 后将自动创建 4 个 StorageClass，查看创建的 StorageClass：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@master ~]# kubectl get pods -n openebs</span><br><span class="line">NAME                                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">openebs-admission-server-5dbc9f4456-jwv5f      1/1     Running   0          13m</span><br><span class="line">openebs-apiserver-659d656db5-xjkb5             1/1     Running   3          13m</span><br><span class="line">openebs-localpv-provisioner-6cb9d78965-fhmgz   1/1     Running   0          13m</span><br><span class="line">openebs-ndm-4zbrt                              1/1     Running   0          13m</span><br><span class="line">openebs-ndm-operator-5ff78c45f6-25hjf          1/1     Running   1          13m</span><br><span class="line">openebs-ndm-q58pr                              1/1     Running   0          13m</span><br><span class="line">openebs-ndm-td58x                              1/1     Running   0          13m</span><br><span class="line">openebs-provisioner-77b84d8cc-tnmn9            1/1     Running   0          13m</span><br><span class="line">openebs-snapshot-operator-6dcc7b6fbd-ssqn4     2/2     Running   0          13m</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl get sc</span><br><span class="line">NAME                        PROVISIONER                                                RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE</span><br><span class="line">openebs-device              openebs.io/local                                           Delete          WaitForFirstConsumer   false                  2m4s</span><br><span class="line">openebs-hostpath            openebs.io/local                                           Delete          WaitForFirstConsumer   false                  2m4s</span><br><span class="line">openebs-jiva-default        openebs.io/provisioner-iscsi                               Delete          Immediate              false                  2m5s</span><br><span class="line">openebs-snapshot-promoter   volumesnapshot.external-storage.k8s.io/snapshot-promoter   Delete          Immediate              false                  2m5s</span><br></pre></td></tr></table></figure>
<p>将 openebs-hostpath设置为 默认的 StorageClass：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl patch storageclass openebs-hostpath -p &apos;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&apos;</span><br><span class="line"></span><br><span class="line">[root@master ~]# kubectl patch storageclass openebs-hostpath -p &apos;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&apos;</span><br><span class="line">storageclass.storage.k8s.io/openebs-hostpath patched</span><br><span class="line"></span><br><span class="line">kubectl create ns storgeclass</span><br></pre></td></tr></table></figure>
<ul>
<li>创建deployment</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#nfs-client-provisioner.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-client-provisioner</span><br><span class="line">  labels:</span><br><span class="line">    app: nfs-client-provisioner</span><br><span class="line">  # replace with namespace where provisioner is deployed</span><br><span class="line">  namespace: openebs</span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  strategy:</span><br><span class="line">    type: Recreate</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nfs-client-provisioner</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nfs-client-provisioner</span><br><span class="line">    spec:</span><br><span class="line">      serviceAccountName: nfs-client-provisioner</span><br><span class="line">      containers:</span><br><span class="line">        - name: nfs-client-provisioner</span><br><span class="line">          #image: quay.io/external_storage/nfs-client-provisioner:latest</span><br><span class="line">          image: registry.cn-beijing.aliyuncs.com/xngczl/nfs-subdir-external-provisione:v4.0.0</span><br><span class="line">          volumeMounts:</span><br><span class="line">            - name: nfs-client-root</span><br><span class="line">              mountPath: /persistentvolumes</span><br><span class="line">          env:</span><br><span class="line">            - name: PROVISIONER_NAME</span><br><span class="line">              value: mynfs</span><br><span class="line">            - name: NFS_SERVER</span><br><span class="line">              value: 192.168.2.221</span><br><span class="line">            - name: NFS_PATH</span><br><span class="line">              value: /nfs/data</span><br><span class="line">      volumes:</span><br><span class="line">        - name: nfs-client-root</span><br><span class="line">          nfs:</span><br><span class="line">            server: 192.168.2.221</span><br><span class="line">            path: /nfs/data</span><br></pre></td></tr></table></figure>
<ul>
<li>rbac.yaml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-client-provisioner</span><br><span class="line">  # replace with namespace where provisioner is deployed</span><br><span class="line">  namespace: openebs</span><br><span class="line">---</span><br><span class="line">kind: ClusterRole</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: nfs-client-provisioner-runner</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources: [&quot;persistentvolumes&quot;]</span><br><span class="line">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;delete&quot;]</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources: [&quot;persistentvolumeclaims&quot;]</span><br><span class="line">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;update&quot;]</span><br><span class="line">  - apiGroups: [&quot;storage.k8s.io&quot;]</span><br><span class="line">    resources: [&quot;storageclasses&quot;]</span><br><span class="line">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;]</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources: [&quot;events&quot;]</span><br><span class="line">    verbs: [&quot;create&quot;, &quot;update&quot;, &quot;patch&quot;]</span><br><span class="line">---</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: run-nfs-client-provisioner</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: nfs-client-provisioner</span><br><span class="line">    # replace with namespace where provisioner is deployed</span><br><span class="line">    namespace: openebs</span><br><span class="line">roleRef:</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: nfs-client-provisioner-runner</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">---</span><br><span class="line">kind: Role</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: leader-locking-nfs-client-provisioner</span><br><span class="line">  # replace with namespace where provisioner is deployed</span><br><span class="line">  namespace: openebs</span><br><span class="line">rules:</span><br><span class="line">  - apiGroups: [&quot;&quot;]</span><br><span class="line">    resources: [&quot;endpoints&quot;]</span><br><span class="line">    verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;]</span><br><span class="line">---</span><br><span class="line">kind: RoleBinding</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">metadata:</span><br><span class="line">  name: leader-locking-nfs-client-provisioner</span><br><span class="line">  # replace with namespace where provisioner is deployed</span><br><span class="line">  namespace: openebs</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: nfs-client-provisioner</span><br><span class="line">    # replace with namespace where provisioner is deployed</span><br><span class="line">    namespace: openebs</span><br><span class="line">roleRef:</span><br><span class="line">  kind: Role</span><br><span class="line">  name: leader-locking-nfs-client-provisioner</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br></pre></td></tr></table></figure>
<ul>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#storgeclass.yaml</span><br><span class="line"></span><br><span class="line">apiVersion: storage.k8s.io/v1</span><br><span class="line">kind: storageClass</span><br><span class="line">metadata:</span><br><span class="line">  name: managed-nfs-storage</span><br><span class="line">  annotations:</span><br><span class="line">    storageclass.kubernetes.io/is-default-class: &quot;true&quot;</span><br><span class="line">provisioner: mynfs # or choose another name, must match deployment&apos;s env PROVISIONER_NAME&apos;</span><br><span class="line">parameters:</span><br><span class="line">  archiveOnDelete: &quot;false&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><em><a href="https://openebs.io/docs/concepts/localpv" target="_blank" rel="noopener">https://openebs.io/docs/concepts/localpv</a></em></p>
<h2 id="kubesphere"><a href="/2022/05/10/k8s kubesphere/#kubesphere" class="headerlink" title="kubesphere"></a>kubesphere</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.2.1/kubesphere-installer.yaml</span><br><span class="line">   </span><br><span class="line">kubectl apply -f https://github.com/kubesphere/ks-installer/releases/download/v3.2.1/cluster-configuration.yaml</span><br></pre></td></tr></table></figure>
<p>查看日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l app=ks-install -o jsonpath=&apos;&#123;.items[0].metadata.name&#125;&apos;) -f</span><br><span class="line"></span><br><span class="line">Error from server (BadRequest): container &quot;installer&quot; in pod &quot;ks-installer-85dcfff87d-wgcn2&quot; is waiting to start: trying and failing to pull image</span><br><span class="line">#在拉镜像，等会</span><br><span class="line"></span><br><span class="line">Waiting for all tasks to be completed ...</span><br><span class="line">task network status is successful  (1/4)</span><br><span class="line">task openpitrix status is successful  (2/4)</span><br><span class="line">task multicluster status is successful  (3/4)</span><br><span class="line">task monitoring status is successful  (4/4)</span><br><span class="line">**************************************************</span><br><span class="line">Collecting installation results ...</span><br><span class="line">#####################################################</span><br><span class="line">###              Welcome to KubeSphere!           ###</span><br><span class="line">#####################################################</span><br><span class="line"></span><br><span class="line">Console: http://192.168.2.219:30880</span><br><span class="line">Account: admin</span><br><span class="line">Password: P@88w0rd</span><br><span class="line"></span><br><span class="line">NOTES：</span><br><span class="line">  1. After you log into the console, please check the</span><br><span class="line">     monitoring status of service components in</span><br><span class="line">     &quot;Cluster Management&quot;. If any service is not</span><br><span class="line">     ready, please wait patiently until all components </span><br><span class="line">     are up and running.</span><br><span class="line">  2. Please change the default password after login.</span><br><span class="line"></span><br><span class="line">#####################################################</span><br><span class="line">https://kubesphere.io             2022-05-10 10:30:52</span><br><span class="line">#####################################################</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：</p>
<p>（1）prometheus-k8s-0容器一直处于SchedulerError状态，无法使用监控功能</p>
<p>running PreBind plugin “VolumeBinding”: binding volumes: timed out waiting for the condition</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl logs -n openebs -l openebs.io/component-name=openebs-localpv-provisioner</span><br></pre></td></tr></table></figure>
<p>“openebs-hostpath”: unexpected error getting claim reference: selfLink was empty, can’t make referen</p>
<p>elfLink was empty 在k8s集群 v1.20之前都存在，在v1.20之后被删除，需要在/etc/kubernetes/manifests/kube-apiserver.yaml 添加参数<br>增加 - –feature-gates=RemoveSelfLink=false</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">containers:</span><br><span class="line">- command:</span><br><span class="line">    - kube-apiserver</span><br><span class="line">    - --feature-gates=RemoveSelfLink=false</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl apply -f /etc/kubernetes/manifests/kube-apiserver.yaml</span><br></pre></td></tr></table></figure>
<p><strong>另一种方式：</strong>修改nfs-client-provisioner.yaml的image:registry.cn-beijing.aliyuncs.com/xngczl/nfs-subdir-external-provisione:v4.0.0</p>
<p>（2）有一台安装了gitlab，那台的node-expoter一直说端口9100被占用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab status</span><br><span class="line">[root@node2 ~]# gitlab-ctl status</span><br><span class="line">/opt/gitlab/embedded/lib/ruby/gems/2.3.0/gems/omnibus-ctl-0.5.0/lib/omnibus-ctl.rb:684: warning: Insecure world writable dir /home/domains/maven/bin in PATH, mode 040777</span><br><span class="line">run: gitaly: (pid 705) 33304154s; run: log: (pid 698) 33304154s</span><br><span class="line">run: gitlab-monitor: (pid 684) 33304154s; run: log: (pid 683) 33304154s</span><br><span class="line">run: gitlab-workhorse: (pid 704) 33304154s; run: log: (pid 695) 33304154s</span><br><span class="line">run: logrotate: (pid 15501) 566s; run: log: (pid 696) 33304154s</span><br><span class="line">run: nginx: (pid 699) 33304154s; run: log: (pid 688) 33304154s</span><br><span class="line">run: node-exporter: (pid 692) 33304154s; run: log: (pid 686) 33304154s</span><br><span class="line">run: postgres-exporter: (pid 702) 33304154s; run: log: (pid 690) 33304154s</span><br><span class="line">run: postgresql: (pid 693) 33304154s; run: log: (pid 691) 33304154s</span><br><span class="line">run: prometheus: (pid 706) 33304154s; run: log: (pid 703) 33304154s</span><br><span class="line">run: redis: (pid 682) 33304154s; run: log: (pid 681) 33304154s</span><br><span class="line">run: redis-exporter: (pid 687) 33304154s; run: log: (pid 685) 33304154s</span><br><span class="line">run: sidekiq: (pid 701) 33304154s; run: log: (pid 694) 33304154s</span><br><span class="line">run: unicorn: (pid 700) 33304154s; run: log: (pid 689) 33304154s</span><br></pre></td></tr></table></figure>
<p>关掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitlab-ctl stop node_exporter</span><br><span class="line"></span><br><span class="line">[root@node2 ~]# gitlab-ctl stop node_exporter</span><br><span class="line">/opt/gitlab/embedded/lib/ruby/gems/2.3.0/gems/omnibus-ctl-0.5.0/lib/omnibus-ctl.rb:684: warning: Insecure world writable dir /home/domains/maven/bin in PATH, mode 040777【没有权限】</span><br><span class="line"></span><br><span class="line">chmod go-w /home/domains/manve/bin</span><br><span class="line">再执行</span><br><span class="line">gitlab-ctl stop node_exporter</span><br><span class="line">如果 还不行，直接先gitlab-ctl stop</span><br><span class="line">再等k8s的node_exporter运行后，再gitlab-ctl start</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>kubernates单机安装日志</title>
    <url>/2017/04/17/kubernates%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="kubernates是什么"><a href="/2017/04/17/kubernates单机安装日志/#kubernates是什么" class="headerlink" title="kubernates是什么"></a>kubernates是什么</h1><p>Kubernetes是Google开源的容器集群管理系统，其提供应用部署、维护、 扩展机制等功能，利用Kubernetes能方便地管理跨机器运行容器化的应用</p>
<h2 id="安装环境"><a href="/2017/04/17/kubernates单机安装日志/#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>os:centos7 64<br>ip:192.168.112.128</p>
<h2 id="安装过程"><a href="/2017/04/17/kubernates单机安装日志/#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="第一步安装etcd"><a href="/2017/04/17/kubernates单机安装日志/#第一步安装etcd" class="headerlink" title="第一步安装etcd"></a>第一步安装etcd</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum install etcd</span><br></pre></td></tr></table></figure>
<p>修改/etc/etcd/etcd.conf<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># [member]</span><br><span class="line">ETCD_NAME=default</span><br><span class="line">ETCD_DATA_DIR=&quot;/var/lib/etcd/default.etcd&quot;</span><br><span class="line">#ETCD_WAL_DIR=&quot;&quot;</span><br><span class="line">#ETCD_SNAPSHOT_COUNT=&quot;10000&quot;</span><br><span class="line">#ETCD_HEARTBEAT_INTERVAL=&quot;100&quot;</span><br><span class="line">#ETCD_ELECTION_TIMEOUT=&quot;1000&quot;</span><br><span class="line">#ETCD_LISTEN_PEER_URLS=&quot;http://192.168.112.128:2380&quot;</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=&quot;http://0.0.0.0:2379&quot;</span><br><span class="line">#ETCD_MAX_SNAPSHOTS=&quot;5&quot;</span><br><span class="line">#ETCD_MAX_WALS=&quot;5&quot;</span><br><span class="line">#ETCD_CORS=&quot;&quot;</span><br><span class="line">#</span><br><span class="line">#[cluster]</span><br><span class="line">#ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;http://localhost:2380&quot;</span><br><span class="line"># if you use different ETCD_NAME (e.g. test), set ETCD_INITIAL_CLUSTER value for this name, i.e. &quot;test=http://...&quot;</span><br><span class="line">#ETCD_INITIAL_CLUSTER=&quot;default=http://localhost:2380&quot;</span><br><span class="line">#ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;</span><br><span class="line">#ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster&quot;</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=&quot;http://192.168.112.128:2379&quot;</span><br><span class="line">#ETCD_DISCOVERY=&quot;&quot;</span><br><span class="line">#ETCD_DISCOVERY_SRV=&quot;&quot;</span><br><span class="line">#ETCD_DISCOVERY_FALLBACK=&quot;proxy&quot;</span><br><span class="line">#ETCD_DISCOVERY_PROXY=&quot;&quot;</span><br><span class="line">#</span><br><span class="line">#[proxy]</span><br><span class="line">#ETCD_PROXY=&quot;off&quot;</span><br><span class="line">#ETCD_PROXY_FAILURE_WAIT=&quot;5000&quot;</span><br><span class="line">#ETCD_PROXY_REFRESH_INTERVAL=&quot;30000&quot;</span><br><span class="line">#ETCD_PROXY_DIAL_TIMEOUT=&quot;1000&quot;</span><br><span class="line">#ETCD_PROXY_WRITE_TIMEOUT=&quot;5000&quot;</span><br><span class="line">#ETCD_PROXY_READ_TIMEOUT=&quot;0&quot;</span><br><span class="line">#</span><br><span class="line">#[security]</span><br><span class="line">#ETCD_CERT_FILE=&quot;&quot;</span><br><span class="line">#ETCD_KEY_FILE=&quot;&quot;</span><br><span class="line">#ETCD_CLIENT_CERT_AUTH=&quot;false&quot;</span><br><span class="line">#ETCD_TRUSTED_CA_FILE=&quot;&quot;</span><br><span class="line">#ETCD_PEER_CERT_FILE=&quot;&quot;</span><br><span class="line">#ETCD_PEER_KEY_FILE=&quot;&quot;</span><br><span class="line">#ETCD_PEER_CLIENT_CERT_AUTH=&quot;false&quot;</span><br><span class="line">#ETCD_PEER_TRUSTED_CA_FILE=&quot;&quot;</span><br><span class="line">#</span><br><span class="line">#[logging]</span><br><span class="line">#ETCD_DEBUG=&quot;false&quot;</span><br><span class="line"># examples for -log-package-levels etcdserver=WARNING,security=DEBUG</span><br><span class="line">#ETCD_LOG_PACKAGE_LEVELS=&quot;&quot;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ etcdctl member list</span><br><span class="line">$ etcdctl set /atomic.io/network/config &apos;&#123; &quot;Network&quot;: &quot;172.17.0.0/16&quot; &#125;&apos;</span><br></pre></td></tr></table></figure>
<h3 id="第二步安装-flanneld"><a href="/2017/04/17/kubernates单机安装日志/#第二步安装-flanneld" class="headerlink" title="第二步安装 flanneld"></a>第二步安装 flanneld</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install flannel</span><br></pre></td></tr></table></figure>
<p>修改/etc/sysconfig/flannel<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Flanneld configuration options  </span><br><span class="line"></span><br><span class="line"># etcd url location.  Point this to the server where etcd runs</span><br><span class="line">FLANNEL_ETCD_ENDPOINTS=&quot;http://192.168.112.128:2379&quot;</span><br><span class="line"></span><br><span class="line"># etcd config key.  This is the configuration key that flannel queries</span><br><span class="line"># For address range assignment</span><br><span class="line">FLANNEL_ETCD_PREFIX=&quot;/atomic.io/network&quot;</span><br><span class="line"></span><br><span class="line"># Any additional options that you want toi pass</span><br><span class="line">FLANNEL_OPTIONS=&quot;&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="第三步安装docker"><a href="/2017/04/17/kubernates单机安装日志/#第三步安装docker" class="headerlink" title="第三步安装docker"></a>第三步安装docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install docker*</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改/usr/lib/systemd/system/docker.service<br>增加下面两行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import flannel configuration </span><br><span class="line">EnvironmentFile=-/etc/sysconfig/flanneld</span><br><span class="line">EnvironmentFile=-/run/flannel/subnet.env</span><br></pre></td></tr></table></figure>
<p>重启docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<h3 id="第四步安装kubernates"><a href="/2017/04/17/kubernates单机安装日志/#第四步安装kubernates" class="headerlink" title="第四步安装kubernates"></a>第四步安装kubernates</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum install kubernates</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 修改/etc/kubernates/apiserver</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###</span><br><span class="line"># kubernetes system config</span><br><span class="line">#</span><br><span class="line"># The following values are used to configure the kube-apiserver</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># The address on the local server to listen to.</span><br><span class="line">KUBE_API_ADDRESS=&quot;--insecure-bind-address=0.0.0.0&quot;</span><br><span class="line"></span><br><span class="line"># The port on the local server to listen on.</span><br><span class="line"> KUBE_API_PORT=&quot;--insecure-port=8080&quot;</span><br><span class="line"></span><br><span class="line"># Port minions listen on</span><br><span class="line"># KUBELET_PORT=&quot;--kubelet-port=10250&quot;</span><br><span class="line"></span><br><span class="line"># Comma separated list of nodes in the etcd cluster</span><br><span class="line">KUBE_ETCD_SERVERS=&quot;--etcd-servers=http://192.168.112.128:2379&quot;</span><br><span class="line"></span><br><span class="line"># Address range to use for services</span><br><span class="line">KUBE_SERVICE_ADDRESSES=&quot;--service-cluster-ip-range=172.16.0.0/24&quot;</span><br><span class="line"></span><br><span class="line"># default admission control policies</span><br><span class="line">#KUBE_ADMISSION_CONTROL=&quot;--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ServiceAccount,ResourceQuota&quot;</span><br><span class="line">#KUBE_ADMISSION_CONTROL=&quot;--admission-control=NamespaceLifecycle,NamespaceExists,LimitRanger,SecurityContextDeny,ResourceQuota&quot;</span><br><span class="line">KUBE_ADMISSION_CONTROL=&quot;&quot;</span><br><span class="line"></span><br><span class="line"># Add your own!</span><br><span class="line">KUBE_API_ARGS=&quot;&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>修改/etc/kubernates/config</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">###</span><br><span class="line"># kubernetes system config</span><br><span class="line">#</span><br><span class="line"># The following values are used to configure various aspects of all</span><br><span class="line"># kubernetes services, including</span><br><span class="line">#</span><br><span class="line">#   kube-apiserver.service</span><br><span class="line">#   kube-controller-manager.service</span><br><span class="line">#   kube-scheduler.service</span><br><span class="line">#   kubelet.service</span><br><span class="line">#   kube-proxy.service</span><br><span class="line"># logging to stderr means we get it in the systemd journal</span><br><span class="line">KUBE_LOGTOSTDERR=&quot;--logtostderr=true&quot;</span><br><span class="line"></span><br><span class="line"># journal message level, 0 is debug</span><br><span class="line">KUBE_LOG_LEVEL=&quot;--v=0&quot;</span><br><span class="line"></span><br><span class="line"># Should this cluster be allowed to run privileged docker containers</span><br><span class="line">KUBE_ALLOW_PRIV=&quot;--allow-privileged=false&quot;</span><br><span class="line"></span><br><span class="line"># How the controller-manager, scheduler, and proxy find the apiserver</span><br><span class="line">KUBE_MASTER=&quot;--master=http://192.168.112.128:8080&quot;</span><br></pre></td></tr></table></figure>
<h3 id="启动服务"><a href="/2017/04/17/kubernates单机安装日志/#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl start kube-apiserver.service kube-controller-manager.service kube-scheduler.service</span><br><span class="line">$ systemctl enable kube-apiserver.service kube-controller-manager.service kube-scheduler.service</span><br><span class="line">$ systemctl enable docker.service kubelet.service kube-proxy.service</span><br><span class="line">$ systemctl start docker.service kubelet.service kube-proxy.service</span><br></pre></td></tr></table></figure>
<h3 id="添加节点"><a href="/2017/04/17/kubernates单机安装日志/#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>暂略</p>
]]></content>
      <categories>
        <category>kubernates</category>
      </categories>
      <tags>
        <tag>kubernates</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel5.4简单入门</title>
    <url>/2017/09/30/laravel5-4%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h3 id="安装-Composer"><a href="/2017/09/30/laravel5-4简单入门/#安装-Composer" class="headerlink" title="安装 Composer"></a>安装 Composer</h3><p>Composer 需要 PHP 5.3.2+ 才能运行。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> curl -sS https://getcomposer.org/installer | php</span><br></pre></td></tr></table></figure></p>
<p>这个命令会将 composer.phar 下载到当前目录。PHAR（PHP 压缩包）是一个压缩格式，可以在命令行下直接运行。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv composer.phar /usr/local/bin/composer</span><br></pre></td></tr></table></figure></p>
<h3 id="安装-Laravel"><a href="/2017/09/30/laravel5-4简单入门/#安装-Laravel" class="headerlink" title="安装 Laravel"></a>安装 Laravel</h3><p>composer global require “laravel/installer=~1.1”</p>
<p>请确保把 ~/.composer/vendor/bin 路径添加到 PATH 环境变量里, 这样laravel 可执行文件才能被命令行找到, 以后您就可以在命令行下直接使用 laravel 命令.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/root/.composer/vendor/bin</span><br></pre></td></tr></table></figure>
<p>通过 Composer 的 create-project 命令安装 Laravel</p>
<p>还可以通过在命令行执行 Composer 的 create-project 命令来安装Laravel：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> composer create-project laravel/laravel laravelweb --prefer-dist</span><br><span class="line"></span><br><span class="line">composer create-project laravel/laravel=5.4.* laravelweb</span><br></pre></td></tr></table></figure></p>
<h3 id="demo"><a href="/2017/09/30/laravel5-4简单入门/#demo" class="headerlink" title="demo"></a>demo</h3><h4 id="注册登录"><a href="/2017/09/30/laravel5-4简单入门/#注册登录" class="headerlink" title="注册登录"></a>注册登录</h4><p>php artisan make:auth<br>php artisan migrate:refresh –seed </p>
<h4 id="建立文章后台"><a href="/2017/09/30/laravel5-4简单入门/#建立文章后台" class="headerlink" title="建立文章后台"></a>建立文章后台</h4><h5 id="建立model"><a href="/2017/09/30/laravel5-4简单入门/#建立model" class="headerlink" title="建立model"></a>建立model</h5><p>php artisan make:model Article</p>
<p>model文件目录是（基于Laravel5.4）app。目前简单例子中并不会在model中写点什么，但是没它不行。</p>
<h5 id="建立数据表"><a href="/2017/09/30/laravel5-4简单入门/#建立数据表" class="headerlink" title="建立数据表"></a>建立数据表</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php artisan make:migration create_article_table</span><br></pre></td></tr></table></figure>
<p>执行以上命令后，会在database/migrations下生成2*_create_article_table.php文件。修改它的up方法：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">up</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Schema::create(<span class="string">'articles'</span>, <span class="function"><span class="keyword">function</span><span class="params">(Blueprint $table)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $table-&gt;increments(<span class="string">'id'</span>);</span><br><span class="line">        $table-&gt;string(<span class="string">'title'</span>);</span><br><span class="line">        $table-&gt;text(<span class="string">'body'</span>)-&gt;nullable();</span><br><span class="line">        $table-&gt;integer(<span class="string">'user_id'</span>);</span><br><span class="line">        $table-&gt;timestamps();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后执行以下命令<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php artisan migrate</span><br></pre></td></tr></table></figure></p>
<p>数据库中会出现article表了。</p>
<h5 id="建立controller"><a href="/2017/09/30/laravel5-4简单入门/#建立controller" class="headerlink" title="建立controller"></a>建立controller</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php artisan make:controller ArticleController</span><br></pre></td></tr></table></figure>
<p>controller目录是app/Http/ 。以上语句执行成功后，会在该目录建立ArticleControllser.php</p>
]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel5.4+dingoapi+jwt构建restfulapi</title>
    <url>/2017/10/01/laravel5-4-dingoapi-jwt%E6%9E%84%E5%BB%BArestfulapi/</url>
    <content><![CDATA[<h3 id="添加jwt的认证"><a href="/2017/10/01/laravel5-4-dingoapi-jwt构建restfulapi/#添加jwt的认证" class="headerlink" title="添加jwt的认证"></a>添加jwt的认证</h3><p> 在composer.json的reqiure添加如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"tymon/jwt-auth": "1.0.*@dev",</span><br></pre></td></tr></table></figure></p>
<p>运行composer update将jwt装上去</p>
<p><em>proc_open(): fork failed - Cannot allocate memory </em><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">free -m</span><br><span class="line">/bin/dd if=/dev/zero of=/var/swap.1 bs=1M count=1024</span><br><span class="line">/sbin/mkswap /var/swap.1</span><br><span class="line">/sbin/swapon /var/swap.1</span><br><span class="line">composer update</span><br></pre></td></tr></table></figure></p>
<p><strong>在config/api.php添加内容</strong><br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">'auth'</span> =&gt; [</span><br><span class="line">    <span class="string">'jwt'</span> =&gt; Dingo\Api\Auth\Provider\JWT::class</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>在config/app.php<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">'providers'</span> =&gt; [</span><br><span class="line">    <span class="comment">// 前面很多</span></span><br><span class="line">    Tymon\JWTAuth\Providers\LaravelServiceProvider::class</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="string">'aliases'</span> =&gt; [</span><br><span class="line">    <span class="comment">// 前面很多</span></span><br><span class="line">    <span class="string">'JWTAuth'</span> =&gt; Tymon\JWTAuth\Facades\JWTAuth::class</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>在终端运行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php artisan vendor:publish --provider="Tymon\JWTAuth\Providers\LaravelServiceProvider"</span><br></pre></td></tr></table></figure></p>
<p>会生成config/jwt.php 这是jwt的配置文件<br>生成jwt的key到.env文件运行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php artisan jwt:secret</span><br></pre></td></tr></table></figure></p>
<h3 id="RegisterApiController"><a href="/2017/10/01/laravel5-4-dingoapi-jwt构建restfulapi/#RegisterApiController" class="headerlink" title="RegisterApiController"></a>RegisterApiController</h3><p>修改User.php<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Notifications</span>\<span class="title">Notifiable</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Auth</span>\<span class="title">User</span> <span class="title">as</span> <span class="title">Authenticatable</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Tymon</span>\<span class="title">JWTAuth</span>\<span class="title">Contracts</span>\<span class="title">JWTSubject</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Authenticatable</span> <span class="keyword">implements</span> <span class="title">JWTSubject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Notifiable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The attributes that are mass assignable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $fillable = [</span><br><span class="line">        <span class="string">'name'</span>, <span class="string">'email'</span>, <span class="string">'password'</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The attributes that should be hidden for arrays.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $hidden = [</span><br><span class="line">        <span class="string">'password'</span>, <span class="string">'remember_token'</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the identifier that will be stored in the subject claim of the JWT.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJWTIdentifier</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return a key value array, containing any custom claims to be added to the JWT.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJWTCustomClaims</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>添加 /app/Http/Controllers/Api/V1/Auth/RegisterApiController</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PhpStorm.</span></span><br><span class="line"><span class="comment"> * User: clyhs</span></span><br><span class="line"><span class="comment"> * Date: 2017/10/1</span></span><br><span class="line"><span class="comment"> * Time: 18:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Api</span>\<span class="title">V1</span>\<span class="title">Auth</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">User</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Api</span>\<span class="title">V1</span>\<span class="title">BaseController</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Validator</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Auth</span>\<span class="title">RegistersUsers</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Dingo</span>\<span class="title">Api</span>\<span class="title">Exception</span>\<span class="title">StoreResourceFailedException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Tymon</span>\<span class="title">JWTAuth</span>\<span class="title">Facades</span>\<span class="title">JWTAuth</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterApiController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> <span class="title">RegistersUsers</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $valid=<span class="keyword">$this</span>-&gt;valid($request-&gt;all());    <span class="comment">//验证表单</span></span><br><span class="line">        <span class="keyword">if</span>($valid-&gt;fails())&#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;sendFailResponse($valid-&gt;errors());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            $user=User::create([</span><br><span class="line">                <span class="string">'name'</span>=&gt;$request-&gt;name,</span><br><span class="line">                <span class="string">'email'</span>=&gt;$request-&gt;email,</span><br><span class="line">                <span class="string">'password'</span>=&gt;bcrypt($request-&gt;password)</span><br><span class="line">            ]);</span><br><span class="line">            <span class="keyword">if</span>($user)&#123;</span><br><span class="line">                $token=JWTAuth::fromuser($user);  <span class="comment">//获取token</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;array([</span><br><span class="line">                    <span class="string">"token"</span> =&gt; $token,</span><br><span class="line">                    <span class="string">"message"</span> =&gt; <span class="string">"Registration Success"</span>,</span><br><span class="line">                    <span class="string">"status_code"</span> =&gt; <span class="number">201</span></span><br><span class="line">                ]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;sendFailResponse(<span class="string">"Register Error"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">valid</span><span class="params">($data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Validator::make($data,[</span><br><span class="line">            <span class="string">'name'</span>=&gt;<span class="string">'required|unique:users|max:10'</span>,</span><br><span class="line">            <span class="string">'email'</span>=&gt;<span class="string">'required|unique:users|email'</span>,</span><br><span class="line">            <span class="string">'password'</span>=&gt;<span class="string">'required|min:6'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sendFailResponse</span><span class="params">($message)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;error($message,<span class="number">400</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>routes/api.php中添加路由<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$api-&gt;version(<span class="string">'v1'</span>, [<span class="string">'namespace'</span> =&gt; <span class="string">'App\Http\Controllers\Api\V1'</span>], <span class="function"><span class="keyword">function</span> <span class="params">($api)</span> </span>&#123;</span><br><span class="line">    $api-&gt;get(<span class="string">'user/&#123;id&#125;'</span>, <span class="string">'UserController@show'</span>);</span><br><span class="line">    $api-&gt;get(<span class="string">'user'</span>, <span class="string">'UserController@index'</span>);</span><br><span class="line">    $api-&gt;get(<span class="string">'user2/&#123;id&#125;'</span>, <span class="string">'UserApiController@getUserInfo'</span>);</span><br><span class="line">    $api-&gt;get(<span class="string">'user2/show/&#123;id&#125;'</span>, <span class="string">'UserApiController@show'</span>);</span><br><span class="line">    $api-&gt;get(<span class="string">'user2'</span>, <span class="string">'UserApiController@index'</span>);</span><br><span class="line">    $api-&gt;get(<span class="string">'user2forpage'</span>, <span class="string">'UserApiController@page'</span>);</span><br><span class="line"></span><br><span class="line">    $api-&gt;post(<span class="string">'register'</span>, <span class="string">'Auth\RegisterApiController@register'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>POSTMAN测试<br><img src="https://clyhs.github.io/images/php/jwt01.png" alt="img"></p>
<h3 id="LoginApiController"><a href="/2017/10/01/laravel5-4-dingoapi-jwt构建restfulapi/#LoginApiController" class="headerlink" title="LoginApiController"></a>LoginApiController</h3><p>添加 /app/Http/Controllers/Api/V1/Auth/LoginApiController<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PhpStorm.</span></span><br><span class="line"><span class="comment"> * User: clyhs</span></span><br><span class="line"><span class="comment"> * Date: 2017/10/1</span></span><br><span class="line"><span class="comment"> * Time: 18:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Api</span>\<span class="title">V1</span>\<span class="title">Auth</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">User</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Api</span>\<span class="title">V1</span>\<span class="title">BaseController</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Tymon</span>\<span class="title">JWTAuth</span>\<span class="title">Facades</span>\<span class="title">JWTAuth</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Hash</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">HttpKernel</span>\<span class="title">Exception</span>\<span class="title">UnauthorizedHttpException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Auth</span>\<span class="title">AuthenticatesUsers</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginApiController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">use</span> <span class="title">AuthenticatesUsers</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $user=User::where(<span class="string">'name'</span>,$request-&gt;email)-&gt;orwhere(<span class="string">'email'</span>,$request-&gt;email)-&gt;firstOrFail();</span><br><span class="line">        <span class="keyword">if</span>($user &amp;&amp; Hash::check($request-&gt;password,$user-&gt;password))&#123;</span><br><span class="line">            $token=JWTAuth::fromuser($user);    <span class="comment">//获取token</span></span><br><span class="line">            <span class="keyword">$this</span>-&gt;clearLoginAttempts($request);  <span class="comment">//清除登录次数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;array([</span><br><span class="line">                <span class="string">'token'</span>=&gt;$token,</span><br><span class="line">                <span class="string">'message'</span>=&gt;<span class="string">"Login Success"</span>,</span><br><span class="line">                <span class="string">'status_code'</span>=&gt;<span class="number">200</span></span><br><span class="line">            ]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnauthorizedHttpException(<span class="string">"Login Failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">logout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JWTAuth::invalidate(JWTAuth::getToken());    <span class="comment">//token加入黑名单(注销)</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;guard()-&gt;logout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>routes/api.php中添加路由<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$api-&gt;post(<span class="string">'login'</span>, <span class="string">'Auth\LoginApiController@login'</span>);</span><br></pre></td></tr></table></figure></p>
<p>POSTMAN测试<br><img src="https://clyhs.github.io/images/php/jwt01.png" alt="img"></p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>laravel</tag>
        <tag>dingoapi</tag>
        <tag>jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>mesos+marathon搭建集群</title>
    <url>/2017/04/08/mesos-marathon%E6%90%AD%E5%BB%BA%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="mesos-marathon搭建集群"><a href="/2017/04/08/mesos-marathon搭建集群/#mesos-marathon搭建集群" class="headerlink" title="mesos+marathon搭建集群"></a>mesos+marathon搭建集群</h1><h2 id="mesos简介"><a href="/2017/04/08/mesos-marathon搭建集群/#mesos简介" class="headerlink" title="mesos简介"></a>mesos简介</h2><blockquote>
<p>Mesos是Apache下的开源分布式资源管理框架，它被称为是分布式系统的内核。Mesos最初是由加州大学伯克利分校的AMPLab开发的，后在Twitter得到广泛使用。</p>
</blockquote>
<h2 id="marathon简介"><a href="/2017/04/08/mesos-marathon搭建集群/#marathon简介" class="headerlink" title="marathon简介"></a>marathon简介</h2><blockquote>
<p>它是一个mesos框架，能够支持运行长服务，比如web应用等。</p>
</blockquote>
<hr>
<h3 id="准备三台虚拟机"><a href="/2017/04/08/mesos-marathon搭建集群/#准备三台虚拟机" class="headerlink" title="准备三台虚拟机"></a>准备三台虚拟机</h3><table>
<thead>
<tr>
<th>主机名</th>
<th>IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>mesos_master</td>
<td>192.168.137.121</td>
</tr>
<tr>
<td>mesos_slave01</td>
<td>192.168.137.122</td>
</tr>
<tr>
<td>mesos_slave02</td>
<td>192.168.137.123</td>
</tr>
</tbody>
</table>
<h3 id="开发搭建"><a href="/2017/04/08/mesos-marathon搭建集群/#开发搭建" class="headerlink" title="开发搭建"></a>开发搭建</h3><ol>
<li>三台机都安装docker<blockquote>
<p>yum install docker*</p>
</blockquote>
</li>
<li>三台机都安装mesos<blockquote>
<p>rpm -Uvh <a href="http://repos.mesosphere.io/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm" target="_blank" rel="noopener">http://repos.mesosphere.io/el/7/noarch/RPMS/mesosphere-el-repo-7-1.noarch.rpm</a><br>rpm –import /etc/pki/rpm-gpg/RPM-GPG-KEY-mesosphere<br>yum install mesos -y</p>
</blockquote>
</li>
<li>修改hosts<blockquote>
<p>192.168.137.121 mesos_master<br>192.168.137.122 mesos_slave01<br>192.168.137.123 mesos_slave02</p>
</blockquote>
</li>
<li><p>mesos_master安装</p>
<blockquote>
<p>1、关闭selinux</p>
<pre><code>systemctl stop firewalld &amp;&amp; systemctl disable firewalld
</code></pre><p>2、安装 yum -y install mesosphere-zookeeper<br>3、给每一个master的zookeeper设置一个唯一id</p>
<pre><code>echo 1 &gt; /var/lib/zookeeper/myid
vi /etc/zookeeper/conf/zoo.cfg
server.1=192.168.137.121:2888:3888
vi /etc/mesos/zk
zk://192.168.137.121:2181/mesos
vi /etc/mesos-master/quorum
1（zookeeper的数量）
</code></pre><p>4、停掉mesos-slave</p>
<pre><code>systemctl stop mesos-slave.service
systemctl disable mesos-slave.service
</code></pre><p>5、安装marahton</p>
<pre><code>yum install -y marathon
</code></pre><p>6、其他</p>
<pre><code>vi /etc/mesos-master/ip
</code></pre><p>   (添加master的ip，默认是127.0.0.1，只做显示用)<br>   vi /etc/mesos-master/hostname<br>   (添加master的hostname，默认为localhost，主要在mesos集群间使用，不是机器的hostname，只做显示用)<br>7、marathon配置<br>这个设置和上面配置mesos的hostname效果一样，不配置会显示默认的localhost，不影响使用</p>
<pre><code>mkdir -p /etc/marathon/conf/ &amp;&amp; touch hostname
echo 192.168.137.121 | sudo tee /etc/marathon/conf/hostname
</code></pre></blockquote>
</li>
<li><p>mesos_slave01\slave02安装</p>
<blockquote>
<p>1、设置zookeeper</p>
<pre><code>vi /etc/mesos/zk
zk://192.168.1.24:2181/mesos
</code></pre><p>2、关闭mesos-master服务</p>
<pre><code>systemctl stop mesos-master.service
systemctl disable mesos-master.service
</code></pre><p>3、指定使用docker容器化</p>
<pre><code>echo &apos;docker,mesos&apos; &gt; /etc/mesos-slave/containerizers
</code></pre><p>4、考虑到拉取容器镜像等的操作，适当增加timeout的时间</p>
<pre><code>echo &apos;5mins&apos; &gt; /etc/mesos-slave/executor_registration_timeout
</code></pre></blockquote>
</li>
<li>启动服务<blockquote>
<p>  1、MASTER</p>
<pre><code>service zookeeper start
service mesos-master start
service marathon start
</code></pre><p>2、SLAVE01\02</p>
<pre><code>service mesos-slave start
</code></pre></blockquote>
</li>
</ol>
<h3 id="配置marathon"><a href="/2017/04/08/mesos-marathon搭建集群/#配置marathon" class="headerlink" title="配置marathon"></a>配置marathon</h3><p>修改端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi /etc/default/marathon</span><br><span class="line"></span><br><span class="line">export HTTP_PORT=8181</span><br><span class="line"></span><br><span class="line">export MARATHON_HTTP_PORT=8181</span><br></pre></td></tr></table></figure>
<p>添加案例nginx</p>
<p><a href="http://192.168.137.121:8181/ui" target="_blank" rel="noopener">http://192.168.137.121:8181/ui</a></p>
<p><img src="https://clyhs.github.io/images/marathon/01.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/marathon/02.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/marathon/03.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/marathon/04.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/marathon/05.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/marathon/06.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/marathon/07.png" alt="img"></p>
<h3 id="查看mesos-master"><a href="/2017/04/08/mesos-marathon搭建集群/#查看mesos-master" class="headerlink" title="查看mesos master"></a>查看mesos master</h3><p><a href="http://192.168.137.121:5050" target="_blank" rel="noopener">http://192.168.137.121:5050</a></p>
<p><img src="https://clyhs.github.io/images/marathon/08.png" alt="img"></p>
]]></content>
      <categories>
        <category>mesos</category>
      </categories>
      <tags>
        <tag>mesos</tag>
        <tag>marathon</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx代理服务搭建</title>
    <url>/2018/03/13/nginx%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="准备两个TOMCAT＋NGINX"><a href="/2018/03/13/nginx代理服务搭建/#准备两个TOMCAT＋NGINX" class="headerlink" title="准备两个TOMCAT＋NGINX"></a>准备两个TOMCAT＋NGINX</h3><ul>
<li>tomcat1 192.168.0.100:8080</li>
<li>tomcat2 192.168.0.100:8070</li>
<li>nginx   192.168.0.100:80</li>
</ul>
<h3 id="启动两台TOMCAT"><a href="/2018/03/13/nginx代理服务搭建/#启动两台TOMCAT" class="headerlink" title="启动两台TOMCAT"></a>启动两台TOMCAT</h3><ul>
<li>略</li>
</ul>
<h3 id="配置nginx-conf"><a href="/2018/03/13/nginx代理服务搭建/#配置nginx-conf" class="headerlink" title="配置nginx.conf"></a>配置nginx.conf</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> cd /etc/nginx</span><br><span class="line"><span class="meta">#</span> vi nginx.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>user  nobody;</span><br><span class="line">worker_processes  4;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>error_log  logs/error.log;</span><br><span class="line"><span class="meta">#</span>error_log  logs/error.log  notice;</span><br><span class="line"><span class="meta">#</span>error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  2048;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span><br><span class="line">    #                  '$status $body_bytes_sent "$http_referer" '</span><br><span class="line">    #                  '"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line">    #client_header_buffer_size 1024K;</span><br><span class="line">    #large_client_header_buffers 4 1024K;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">   #</span> proxy_connect_timeout   300; </span><br><span class="line"><span class="meta">   #</span> proxy_send_timeout      300; </span><br><span class="line"><span class="meta">   #</span> proxy_read_timeout      300; </span><br><span class="line"><span class="meta">   #</span> proxy_buffer_size       16k; </span><br><span class="line"><span class="meta">   #</span> proxy_buffers           4 64k; </span><br><span class="line"><span class="meta">   #</span> proxy_busy_buffers_size 128k; </span><br><span class="line"><span class="meta">   #</span> proxy_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line">    #</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_static on;  </span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    gzip_min_length 1400;</span><br><span class="line">    gzip_vary  on;</span><br><span class="line">    gzip_http_version 1.1;  </span><br><span class="line">    gzip_proxied expired no-cache no-store private auth;</span><br><span class="line">    gzip_types text/plain text/css text/xml text/javascript image/gif image/jpeg application/x-javascript application/xml;</span><br><span class="line">    gzip_disable "MSIE [1-6]\.(?!.*SV1)";</span><br><span class="line">    #</span><br><span class="line">    client_max_body_size 8m;</span><br><span class="line">    client_body_buffer_size 512k;</span><br><span class="line">    #</span><br><span class="line">    upstream backend_tomcats &#123;</span><br><span class="line">        server 192.168.0.100:8080 max_fails=3 weight=1 fail_timeout=300s;</span><br><span class="line">        #server 192.168.0.100:8080 max_fails=3 weight=1 fail_timeout=300s;</span><br><span class="line">        keepalive 256;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        </span><br><span class="line">        #client_max_body_size 64m;</span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">         </span><br><span class="line">        client_header_buffer_size 2m;</span><br><span class="line">        large_client_header_buffers 4 1m;        </span><br><span class="line"> </span><br><span class="line">        charset utf-8;</span><br><span class="line">        #</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://backend_tomcats;</span><br><span class="line">            proxy_set_header HOST $host:80;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Connection "";</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache's document root</span><br><span class="line">        # concurs with nginx's one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br><span class="line">    #    server_name  somename  alias  another.alias;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # HTTPS server</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       443 ssl;</span><br><span class="line">    #    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    #    ssl_certificate      cert.pem;</span><br><span class="line">    #    ssl_certificate_key  cert.key;</span><br><span class="line"></span><br><span class="line">    #    ssl_session_cache    shared:SSL:1m;</span><br><span class="line">    #    ssl_session_timeout  5m;</span><br><span class="line"></span><br><span class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</span><br><span class="line">    #    ssl_prefer_server_ciphers  on;</span><br><span class="line"></span><br><span class="line">    #    location / &#123;</span><br><span class="line">    #        root   html;</span><br><span class="line">    #        index  index.html index.htm;</span><br><span class="line">    #    &#125;</span><br><span class="line">    #&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问地址："><a href="/2018/03/13/nginx代理服务搭建/#访问地址：" class="headerlink" title="访问地址："></a>访问地址：</h3><ul>
<li><a href="http://192.168.0.100" target="_blank" rel="noopener">http://192.168.0.100</a></li>
</ul>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>lvs+keepalived+nginx服务搭建过程</title>
    <url>/2018/03/13/lvs-keepalived-nginx%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="准备环境"><a href="/2018/03/13/lvs-keepalived-nginx服务搭建过程/#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><table>
<thead>
<tr>
<th>服务</th>
<th>地址</th>
<th>环境</th>
</tr>
</thead>
<tbody>
<tr>
<td>web服务器1</td>
<td>192.168.0.7:80</td>
<td>tomcat,nginx,realserver.sh</td>
</tr>
<tr>
<td>web服务器2</td>
<td>192.168.0.16:80</td>
<td>tomcat,nginx,realserver.sh</td>
</tr>
<tr>
<td>master</td>
<td>192.168.0.100</td>
<td>keepalived</td>
</tr>
<tr>
<td>backup</td>
<td>192.168.0.101</td>
<td>keepalived</td>
</tr>
</tbody>
</table>
<ul>
<li>VIP:192.168.0.80</li>
<li>这里用的是keepalived的DR模式</li>
<li>两台服务器都是centos7虚拟机</li>
</ul>
<h3 id="分别安装环境-ipvsadm-keepalived"><a href="/2018/03/13/lvs-keepalived-nginx服务搭建过程/#分别安装环境-ipvsadm-keepalived" class="headerlink" title="分别安装环境,ipvsadm,keepalived"></a>分别安装环境,ipvsadm,keepalived</h3><p>1、安装环境依赖包,两台服务器都安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># yum install -y gcc gcc-c++ make pcre pcre-devel kernel-devel openssl-devel libnl-devel popt-devel popt-static</span><br></pre></td></tr></table></figure></p>
<p>2、安装 ipvsadm<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># wget http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.26.tar.gz</span><br><span class="line"># tar zxf ipvsadm-1.26.tar.gz</span><br><span class="line"># cd ipvsadm-1.26</span><br><span class="line"># make ; make install</span><br></pre></td></tr></table></figure></p>
<p>有系统有带的可以不安装<br>3、安装 keepalived<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tar xf keepalived-1.2.12.tar.gz</span><br><span class="line"># cd keepalived-1.2.12</span><br><span class="line"># ./configure --sysconf=/etc --sbindir=/usr/sbin/</span><br><span class="line"># make &amp;&amp; make install</span><br><span class="line"># ln -s /usr/local/sbin/keepalived /sbin/keepalived</span><br><span class="line"># chkconfig --add keepalived</span><br><span class="line"># chkconfig --level 2345 keepalived on</span><br></pre></td></tr></table></figure></p>
<ul>
<li>若/usr/src/kernels目录下没有内核目录，则需要安装内核开发包<br>yum install -y kernel-devel kernel-headers安装<br>yum install –y libnfnetlink-devel   (libnfnetlink-devel-1.0.1-4.el7.x86_64.rpm)</li>
<li>CentOS7跟CentOS6的头文件路径有差别，把最后一个参数去掉</li>
<li>CentOS6下面编译<br>./configure –sysconf=/etc –with-kernel-dir=/usr/src/kernels/2.6.32-504.23.4.el6.x86_64</li>
</ul>
<h3 id="配置keepalived的主从文件"><a href="/2018/03/13/lvs-keepalived-nginx服务搭建过程/#配置keepalived的主从文件" class="headerlink" title="配置keepalived的主从文件"></a>配置keepalived的主从文件</h3><ul>
<li>192.168.0.100(MASTER)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id MASTER</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER</span><br><span class="line">    interface eno16777984</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 100</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.0.80</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.0.80 80 &#123;</span><br><span class="line">    delay_loop 6</span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind DR</span><br><span class="line">    nat_mask 255.255.255.0 </span><br><span class="line">    persistence_timeout 5</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 192.168.0.16 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">            connect_port 80</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    real_server 192.168.0.7 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;    </span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">            connect_port 80</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>192.168.0.101(BACKUP)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"></span><br><span class="line">global_defs &#123;</span><br><span class="line">   router_id BACKUP</span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens160</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">    priority 80</span><br><span class="line">    advert_int 1</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.0.80</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">virtual_server 192.168.0.80 80 &#123;</span><br><span class="line">    delay_loop 6</span><br><span class="line">    lb_algo rr</span><br><span class="line">    lb_kind DR</span><br><span class="line">    nat_mask 255.255.255.0 </span><br><span class="line">    persistence_timeout 5</span><br><span class="line">    protocol TCP</span><br><span class="line"></span><br><span class="line">    real_server 192.168.0.16 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">            connect_port 80</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    real_server 192.168.0.7 80 &#123;</span><br><span class="line">        weight 1</span><br><span class="line">        TCP_CHECK &#123;</span><br><span class="line">            connect_timeout 3</span><br><span class="line">            nb_get_retry 3</span><br><span class="line">            delay_before_retry 3</span><br><span class="line">            connect_port 80</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为07与16两台服务器添加VIP"><a href="/2018/03/13/lvs-keepalived-nginx服务搭建过程/#为07与16两台服务器添加VIP" class="headerlink" title="为07与16两台服务器添加VIP"></a>为07与16两台服务器添加VIP</h3><p>脚本(realserver.sh)如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">VIP=&apos;192.168.0.80&apos;</span><br><span class="line"></span><br><span class="line">. /etc/init.d/functions</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">  start)</span><br><span class="line">    /sbin/ifconfig lo:0 $VIP broadcast $VIP netmask 255.255.255.255 up</span><br><span class="line">    echo &quot;1&quot; &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line">    echo &quot;2&quot; &gt; /proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line">    echo &quot;1&quot; &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">    echo &quot;2&quot; &gt; /proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">    echo &quot; LVS Real-Server Start Success&quot;</span><br><span class="line">      ;;</span><br><span class="line">    stop)</span><br><span class="line">     /sbin/ifconfig lo:0 down</span><br><span class="line">     echo &quot;0&quot; &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line">     echo &quot;0&quot; &gt; /proc/sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line">     echo &quot;0&quot; &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">     echo &quot;0&quot; &gt; /proc/sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">     echo &quot; LVS Real-Server Stop Success&quot;</span><br><span class="line">      ;;</span><br><span class="line">       *)</span><br><span class="line">     echo &quot;Usage: $0 ( start | stop )&quot;</span><br><span class="line">     exit 1</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p>
<h3 id="启动服务"><a href="/2018/03/13/lvs-keepalived-nginx服务搭建过程/#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>1、启动16与07两台nginx<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># service nginx start</span><br></pre></td></tr></table></figure></p>
<p>2、分别在16与07执行脚本realserver.sh<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ./realserver.sh</span><br></pre></td></tr></table></figure></p>
<p>启动后可以输入ifconfig看到<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lo:0: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 192.168.0.80  netmask 255.255.255.255</span><br><span class="line">        loop  txqueuelen 1  (Local Loopback)</span><br></pre></td></tr></table></figure></p>
<p>3、分别启动16与07的keepalived<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># service keepalived start</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@centoss1 home]# ipvsadm -ln</span><br><span class="line">IP Virtual Server version 1.2.1 (size=4096)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  192.168.0.80:80 rr persistent 5</span><br><span class="line">  -&gt; 192.168.0.7:80               Route   1      0          0         </span><br><span class="line">  -&gt; 192.168.0.16:80              Route   1      0          0</span><br></pre></td></tr></table></figure>
<p>4、访问服务<br><a href="http://192.168.0.80" target="_blank" rel="noopener">http://192.168.0.80</a></p>
<p>5、关掉两台服务器中的一个nginx<br>比如关掉16测试</p>
]]></content>
      <categories>
        <category>lvs</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>lvs</tag>
        <tag>keepalived</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel5.4集成dingoapi例子</title>
    <url>/2017/10/01/laravel5-4%E9%9B%86%E6%88%90dingoapi%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<h3 id="安装dingo-api"><a href="/2017/10/01/laravel5-4集成dingoapi例子/#安装dingo-api" class="headerlink" title="安装dingo api"></a>安装dingo api</h3><p> 在composer.json的reqiure添加如下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"dingo/api":"1.0.*@dev",</span><br></pre></td></tr></table></figure></p>
<p>然后执行<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">composer update</span><br></pre></td></tr></table></figure></p>
<h3 id="配置"><a href="/2017/10/01/laravel5-4集成dingoapi例子/#配置" class="headerlink" title="配置"></a>配置</h3><p>在config/app.php 注册服务提供者<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="string">'providers'</span> =&gt; [</span><br><span class="line">    ...</span><br><span class="line">    Dingo\Api\Provider\LaravelServiceProvider::class,</span><br><span class="line">    ...</span><br><span class="line">],</span><br></pre></td></tr></table></figure></p>
<p>生成配置文件config/api.php</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php artisan vendor:publish --provider="Dingo\Api\Provider\LaravelServiceProvider"</span><br></pre></td></tr></table></figure>
<p>设置.env</p>
<p>API_STANDARDS_TREE=vnd<br>API_SUBTYPE=myapp<br>API_PREFIX=api<br>API_VERSION=v1</p>
<p>创建UserController<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php artisan make:controller Api/V1/UserController</span><br></pre></td></tr></table></figure></p>
<p>修改app/Http/Controller/Api/V1/UserController</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Api</span>\<span class="title">V1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">User</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Controller</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> User::all();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">show</span><span class="params">($id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> User::findOrFail($id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在routes/api.php注册路由<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">$api = app(<span class="string">'Dingo\Api\Routing\Router'</span>);</span><br><span class="line">$api-&gt;version(<span class="string">'v1'</span>, [<span class="string">'namespace'</span> =&gt; <span class="string">'App\Http\Controllers\Api\V1'</span>], <span class="function"><span class="keyword">function</span> <span class="params">($api)</span> </span>&#123;</span><br><span class="line">    $api-&gt;get(<span class="string">'user/&#123;id&#125;'</span>, <span class="string">'UserController@show'</span>);</span><br><span class="line">    $api-&gt;get(<span class="string">'user'</span>, <span class="string">'UserController@index'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>查看路由列表<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php artisan api:routes</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
        <tag>dingoapi</tag>
      </tags>
  </entry>
  <entry>
    <title>objective-c[块]block</title>
    <url>/2018/04/15/objective-c-%E5%9D%97-block/</url>
    <content><![CDATA[<h3 id="块的语法"><a href="/2018/04/15/objective-c-块-block/#块的语法" class="headerlink" title="块的语法"></a>块的语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">returnType (^blockName)(parameterTypes) = ^returnType(parameters) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>注1: Block的声明与赋值只是保存了一段代码段,必须调用才能执行内部代码</li>
</ul>
<p>如下：<br>1、 int (^myBlock)(int); // 声明一个名为oneParamBlock的块，该块接收一个int型参数，返回值也是int型的<br>2、 void (^myBlock)(int,int); // 接收两个int型参数，无返回值<br>3、 void (^myBlock2)(int parm1, int parm2); // 声明中可以含有参数名称<br>4、 int (^myBlock)(void); // 没有参数需要写上void，不能省略</p>
<h3 id="块的定义"><a href="/2018/04/15/objective-c-块-block/#块的定义" class="headerlink" title="块的定义"></a>块的定义</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义属性，block属性可以用strong修饰，也可以用copy修饰 */</span>  </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">void</span>(^myBlock)();                   <span class="comment">//无参无返回值  </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">void</span>(^myBlock)(<span class="built_in">NSString</span> *);        <span class="comment">//带参数无返回值  </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *(^myBlock)(<span class="built_in">NSString</span> *);  <span class="comment">//带参数与返回值 </span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*block被当做方法的参数,格式：(block类型)参数名称  */</span></span><br><span class="line">- (<span class="keyword">void</span>)test:(<span class="keyword">void</span>(^)())testBlock                    <span class="comment">//无参无返回值  </span></span><br><span class="line">- (<span class="keyword">void</span>)test1:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *))testBlock         <span class="comment">//带参数无返回值  </span></span><br><span class="line">- (<span class="keyword">void</span>)test2:(<span class="built_in">NSString</span> *(^)(<span class="built_in">NSString</span> *))testBlock   <span class="comment">//带参数与返回值  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/*使用typedef定义block */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^myBlock)();                            <span class="comment">//以后就可以使用myBlock定义无参无返回值的block  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^myBlock1)(<span class="built_in">NSString</span> *);                 <span class="comment">//使用myBlock1定义参数类型为NSString的block  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSString</span> *(^myBlock2)(<span class="built_in">NSString</span> *);           <span class="comment">//使用myBlock2定义参数类型为NSString，返回值也为NSString的block  </span></span><br><span class="line"><span class="comment">//定义属性  </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) myBlock testBlock;  </span><br><span class="line"><span class="comment">//定义变量  </span></span><br><span class="line">myBlock testBlock = <span class="literal">nil</span>;  </span><br><span class="line"><span class="comment">//当做参数  </span></span><br><span class="line">- (<span class="keyword">void</span>)test:(myBlock)testBlock;</span><br></pre></td></tr></table></figure>
<h3 id="block的赋值"><a href="/2018/04/15/objective-c-块-block/#block的赋值" class="headerlink" title="block的赋值"></a>block的赋值</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">没有参数没有返回值</span><br><span class="line">myBlock testBlock = ^<span class="keyword">void</span>()&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"test"</span>);</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">没有返回值，<span class="keyword">void</span>可以省略</span><br><span class="line">myBlock testBlock1 = ^()&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"test1"</span>);</span><br><span class="line"> &#125;；</span><br><span class="line"></span><br><span class="line">没有参数，小括号也可以省略</span><br><span class="line">myBlock testBlock2 = ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"test2"</span>);</span><br><span class="line"> &#125;；</span><br><span class="line"></span><br><span class="line">有参数没有返回值</span><br><span class="line">myBlock1 testBlock = ^<span class="keyword">void</span>(<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">省略<span class="keyword">void</span></span><br><span class="line">myBlock1 testBlock = ^(<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">有参数有返回值</span><br><span class="line">myBlock2 testBlock = ^<span class="built_in">NSString</span> *(<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(str)</span><br><span class="line">     <span class="keyword">return</span> <span class="string">@"hi"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">有返回值时也可以省略返回值类型</span><br><span class="line"> myBlock2 testBlock2 = ^(<span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(str)</span><br><span class="line">     <span class="keyword">return</span> <span class="string">@"hi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明Block变量的同时进行赋值<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>(^myBlock)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> num)&#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="number">7</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有参数列表,在赋值时参数列表可以省略</span></span><br><span class="line"><span class="keyword">void</span>(^aVoidBlock)() = ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"I am a aVoidBlock"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="Block作为OC函数参数"><a href="/2018/04/15/objective-c-块-block/#Block作为OC函数参数" class="headerlink" title="Block作为OC函数参数"></a>Block作为OC函数参数</h3><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.定义一个形参为Block的OC函数</span></span><br><span class="line">- (<span class="keyword">void</span>)useBlockForOC:(<span class="keyword">int</span>(^)(<span class="keyword">int</span>, <span class="keyword">int</span>))aBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"result = %d"</span>, aBlock(<span class="number">300</span>,<span class="number">200</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.声明并赋值定义一个Block变量</span></span><br><span class="line"><span class="keyword">int</span>(^addBlock)(<span class="keyword">int</span>, <span class="keyword">int</span>) = ^(<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.以Block作为函数参数,把Block像对象一样传递</span></span><br><span class="line">[<span class="keyword">self</span> useBlockForOC:addBlock];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将第2点和第3点合并一起,以内联定义的Block作为函数参数</span></span><br><span class="line">[<span class="keyword">self</span> useBlockForOC:^(<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>objective-c</category>
      </categories>
      <tags>
        <tag>objective-c</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx的几种负载均衡</title>
    <url>/2019/05/30/nginx%E7%9A%84%E5%87%A0%E7%A7%8D%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h3 id="nginx的几种负载均衡"><a href="/2019/05/30/nginx的几种负载均衡/#nginx的几种负载均衡" class="headerlink" title="nginx的几种负载均衡"></a>nginx的几种负载均衡</h3><ul>
<li><p>（1）轮询(默认):每个请求按时间顺序逐一分配到不同的后端服务器;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream backend_tomcats &#123;</span><br><span class="line">        server xx.x.x.x:8080 max_fails=3 weight=1 fail_timeout=30s;</span><br><span class="line">        server xx.x.x.x:8080 max_fails=3 weight=1 fail_timeout=30s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>（2）ip_hash:每个请求按访问IP的hash结果分配，同一个IP客户端固定访问一个后端服务器。可以保证来自同一ip的请求被打到固定的机器上，可以解决session问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream backend_tomcats &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        server xx.x.x.x:8080 max_fails=3 weight=1 fail_timeout=30s;</span><br><span class="line">        server xx.x.x.x:8080 max_fails=3 weight=1 fail_timeout=30s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>这种方法，做负载均衡就没有意义，因为他会直接压到一台机，另一台没起到集群负载的作用，最好把session存到redis上</em></p>
</li>
<li><p>（3）url_hash:按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器。后台服务器为缓存的时候效率。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream backend_tomcats &#123;</span><br><span class="line">        server xx.x.x.x:8080 ;</span><br><span class="line">        server xx.x.x.x:8080 ;</span><br><span class="line">        hash $request_uri; </span><br><span class="line">        hash_method crc32; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>注意：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法。</em></p>
</li>
<li><p>(4) fair:这是比上面两个更加智能的负载均衡算法。<br>此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持 fair的，如果需要使用这种调度算法，必须下载Nginx的 upstream_fair模块</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream backend_tomcats &#123;</span><br><span class="line">        fair;</span><br><span class="line">        server xx.x.x.x:8080 max_fails=3 weight=1 fail_timeout=30s;</span><br><span class="line">        server xx.x.x.x:8080 max_fails=3 weight=1 fail_timeout=30s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>(5)least_conn：选取活跃连接数与权重weight的比值最小者为下一个处理请求的server</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">upstream backend_tomcats &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server xx.x.x.x:8080 max_fails=3 weight=1 fail_timeout=30s;</span><br><span class="line">        server xx.x.x.x:8080 max_fails=3 weight=1 fail_timeout=30s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><em>下面几个名词解释说明</em></p>
<p><strong>down</strong> 表示单前的server暂时不参与负载.</p>
<p><strong>weight</strong> 默认为1.weight越大，负载的权重就越大。</p>
<p><strong>max_fails</strong> ：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream 模块定义的错误.</p>
<p><strong>fail_timeout</strong> : max_fails次失败后，暂停的时间。</p>
<p><strong>backup</strong>： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</p>
<h3 id="nginx1-12-1-tar-gz安装"><a href="/2019/05/30/nginx的几种负载均衡/#nginx1-12-1-tar-gz安装" class="headerlink" title="nginx1.12.1.tar.gz安装"></a>nginx1.12.1.tar.gz安装</h3><p>先安装如下包：</p>
<p>cpp gcc gcc-c++ glibc-devel glibc-headers libstdc++ kernel-headers keyutils-lib-devel krb5-devel libmpc libselinux-devel libsepol-devel libverto-devel libcom_err-devel<br>zlib zlib-devel openssl openssl-devel pcre pcre-devel</p>
<p>下载upstream-fair包地址：<a href="https://github.com/gnosek/nginx-upstream-fair" target="_blank" rel="noopener">https://github.com/gnosek/nginx-upstream-fair</a></p>
<p>或者：链接: <a href="https://pan.baidu.com/s/1jT6LWM7nAyaswN1FUIJP7Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1jT6LWM7nAyaswN1FUIJP7Q</a> 提取码: dhky </p>
<p>更名为upstream放到/home目录下</p>
<p>安装命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-log-path=/var/log/nginx/access.log --http-proxy-temp-path=/var/lib/nginx/proxy --lock-path=/var/lock/nginx.lock --pid-path=/var/run/nginx.pid --with-debug --with-http_dav_module --with-http_flv_module --with-http_geoip_module --with-http_gzip_static_module --with-http_realip_module --with-http_stub_status_module --with-http_ssl_module --with-http_sub_module --with-ipv6 --with-mail --with-mail_ssl_module --add-module=/home/upstream/</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h3 id="nginx参数配置"><a href="/2019/05/30/nginx的几种负载均衡/#nginx参数配置" class="headerlink" title="nginx参数配置"></a>nginx参数配置</h3><p>附一个完整的nginx.conf的配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span>user  root;</span><br><span class="line">worker_processes  4;</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  204800;</span><br><span class="line">    multi_accept on;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    #页面缓存目录，注意目录权限要777</span><br><span class="line">    proxy_temp_path /home/domains/pascloud/nginx/proxy_temp;</span><br><span class="line">    proxy_cache_path /home/domains/pascloud/nginx/proxy_cache levels=1:2 keys_zone=cache_one:10240m inactive=10d max_size=2000m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line">    #</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_static on;  </span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    gzip_min_length 1400;</span><br><span class="line">    gzip_vary  on;</span><br><span class="line">    gzip_http_version 1.1;  </span><br><span class="line">    gzip_proxied expired no-cache no-store private auth;</span><br><span class="line">    gzip_types text/plain text/css text/xml text/javascript image/gif image/jpeg application/x-javascript application/xml;</span><br><span class="line">    gzip_disable "MSIE [1-6]\.(?!.*SV1)";</span><br><span class="line">    #</span><br><span class="line">    client_max_body_size 8m;</span><br><span class="line">    client_body_buffer_size 512k;</span><br><span class="line">    #</span><br><span class="line">    upstream backend_tomcats &#123;</span><br><span class="line">        #least_conn;</span><br><span class="line">        #ip_hash;</span><br><span class="line">        fair;</span><br><span class="line">	    server xxxx:8080 max_fails=1 weight=2 fail_timeout=20s;</span><br><span class="line">        server xxxx:8080 max_fails=1 weight=2 fail_timeout=20s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        </span><br><span class="line">         </span><br><span class="line">        client_header_buffer_size 2m;</span><br><span class="line">        large_client_header_buffers 4 1m;        </span><br><span class="line"> </span><br><span class="line">        charset utf-8;</span><br><span class="line">        #</span><br><span class="line"></span><br><span class="line">        access_log off;</span><br><span class="line">        error_log off;</span><br><span class="line">        location / &#123;</span><br><span class="line">            </span><br><span class="line">            proxy_pass http://backend_tomcats;</span><br><span class="line">            proxy_set_header HOST $host:80;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            #proxy_http_version 1.1;</span><br><span class="line">            #proxy_set_header Connection "";</span><br><span class="line">            proxy_next_upstream error timeout invalid_header http_500 http_503 http_404;</span><br><span class="line"></span><br><span class="line">            proxy_connect_timeout   300; </span><br><span class="line">            proxy_send_timeout      300; </span><br><span class="line">            proxy_read_timeout      600; </span><br><span class="line">            proxy_buffer_size       256k; </span><br><span class="line">            proxy_buffers           4 256k; </span><br><span class="line">            proxy_busy_buffers_size 256k; </span><br><span class="line">            proxy_temp_file_write_size 256k;</span><br><span class="line">            proxy_max_temp_file_size 128m;</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            proxy_cache cache_one ;</span><br><span class="line">            proxy_cache_valid 200 304 12h ;</span><br><span class="line">            proxy_cache_valid 301 302 1m ;</span><br><span class="line">            proxy_cache_valid any 1m ;</span><br><span class="line">            proxy_cache_key $host$uri$is_args$args;</span><br><span class="line">            #proxy_ignore_headers Set-Cookie Cache-Control;</span><br><span class="line">	        #proxy_hide_header Cache-Control;</span><br><span class="line">        &#125;</span><br><span class="line">        #静态文件分离</span><br><span class="line">        location ~* \.(gif|jpg|jpeg|png|js|css)$ &#123;         </span><br><span class="line">            root /home/domains/pascloud/ROOT/;</span><br><span class="line">	        access_log off;</span><br><span class="line">	        expires 10d;</span><br><span class="line">            break;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>rancher2安装</title>
    <url>/2019/06/18/rancher2%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="rancher安装"><a href="/2019/06/18/rancher2安装/#rancher安装" class="headerlink" title="rancher安装"></a>rancher安装</h3><h4 id="服务器"><a href="/2019/06/18/rancher2安装/#服务器" class="headerlink" title="服务器"></a>服务器</h4><ul>
<li>主：192.168.137.101</li>
<li>agent：192.168.137.100</li>
</ul>
<h4 id="准备"><a href="/2019/06/18/rancher2安装/#准备" class="headerlink" title="准备"></a>准备</h4><p>关掉swap</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure>
<p>设置selinux</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>
<p>或者/etc/selinux/config中设置为disabled</p>
<p>关掉防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable direwalld</span><br></pre></td></tr></table></figure>
<p>软件情况</p>
<p>docker:18+</p>
<p>rancher:2.2.4</p>
<h4 id="安装"><a href="/2019/06/18/rancher2安装/#安装" class="headerlink" title="安装"></a>安装</h4><p><strong>1、在192.168.137.101执行</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher</span><br></pre></td></tr></table></figure>
<p>成功后，在浏览器访问<a href="https://192.168.0.101，设置初始密码" target="_blank" rel="noopener">https://192.168.0.101，设置初始密码</a></p>
<p><img src="https://clyhs.github.io/images/rancher/01.png" alt="img"></p>
<p>下一步</p>
<p><img src="https://clyhs.github.io/images/rancher/02.png" alt="img"></p>
<p>下一步</p>
<p><img src="https://clyhs.github.io/images/rancher/03.png" alt="img"></p>
<p>选择右下角中文</p>
<p><img src="https://clyhs.github.io/images/rancher/04.png" alt="img"></p>
<p>添加集群，选择右下角custom，并滚动页面，在下面填定集群名称</p>
<p><img src="https://clyhs.github.io/images/rancher/05.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/rancher/06.png" alt="img"></p>
<p>下一步，勾选所有选项</p>
<p><img src="https://clyhs.github.io/images/rancher/07.png" alt="img"></p>
<p>并且可以看到以下：</p>
<p>复制以下命令在主机的SSH终端运行。这个是在agent执行的命令</p>
<p><strong>2、在192.168.137.100执行</strong>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run -d --privileged --restart=unless-stopped --net=host -v /etc/kubernetes:/etc/kubernetes -v /var/run:/var/run rancher/rancher-agent:v2.2.4 --server https://192.168.137.101 --token jpbmr8k27l7r7hxps5q9p6lxhzjpjk8sspqvx9flbb2rxlpslgcsg9 --ca-checksum ccba9db8ad0f6e204968ec2dc5f87de5fea16c05032f6f1c19e141b03f8edcf5 --etcd --controlplane --worker</span><br></pre></td></tr></table></figure>
<p>红色字体提示没有rancher/hyperkube:v1.13.5-rancher1镜像，连网不成功。</p>
<p>最好192.168.137.100是连网状态，因为加上agent节点，会从网上拉下镜像。</p>
<p>添加成功后如下：</p>
<p><img src="https://clyhs.github.io/images/rancher/10.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/rancher/11.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/rancher/12.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/rancher/13.png" alt="img"></p>
]]></content>
      <categories>
        <category>rancher</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>rancher</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7静默安装oracle11g</title>
    <url>/2022/08/10/oracle%E6%96%B0%E5%BB%BA%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="CentOS7静默安装oracle11g"><a href="/2022/08/10/oracle新建实例/#CentOS7静默安装oracle11g" class="headerlink" title="CentOS7静默安装oracle11g"></a>CentOS7静默安装oracle11g</h1><h2 id="1、配置"><a href="/2022/08/10/oracle新建实例/#1、配置" class="headerlink" title="1、配置"></a>1、配置</h2><h3 id="1-1、配置环境"><a href="/2022/08/10/oracle新建实例/#1-1、配置环境" class="headerlink" title="1.1、配置环境"></a>1.1、配置环境</h3><p>修改主机名<br>关闭selinux<br>略</p>
<h3 id="1-2、安装库"><a href="/2022/08/10/oracle新建实例/#1-2、安装库" class="headerlink" title="1.2、安装库"></a>1.2、安装库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install binutils compat-libcap1 compat-libstdc++-33 compat-libstdc++-33*i686 compat-libstdc++-33*.devel compat-libstdc++-33 compat-libstdc++-33*.devel gcc gcc-c++ glibc glibc*.i686 glibc-devel glibc-devel*.i686 ksh libaio libaio*.i686 libaio-devel libaio-devel*.devel libgcc libgcc*.i686 libstdc++ libstdc++*.i686 libstdc++-devel libstdc++-devel*.devel libXi libXi*.i686 libXtst libXtst*.i686 make sysstat unixODBC unixODBC*.i686 unixODBC-devel unixODBC-devel*.i686</span><br></pre></td></tr></table></figure>
<h3 id="1-3、配置用户"><a href="/2022/08/10/oracle新建实例/#1-3、配置用户" class="headerlink" title="1.3、配置用户"></a>1.3、配置用户</h3><p>创建oinstall和dba组<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd oinstall</span><br><span class="line">groupadd dba</span><br></pre></td></tr></table></figure></p>
<p>创建oracle用户<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd -g oinstall -G dba oracle</span><br></pre></td></tr></table></figure></p>
<p>设置oracle用户密码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd oracle</span><br></pre></td></tr></table></figure></p>
<h3 id="1-4、配置内核参数"><a href="/2022/08/10/oracle新建实例/#1-4、配置内核参数" class="headerlink" title="1.4、配置内核参数"></a>1.4、配置内核参数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@docker ~]# vim /etc/sysctl.conf </span><br><span class="line"></span><br><span class="line"># System default settings live in /usr/lib/sysctl.d/00-system.conf.</span><br><span class="line"># To override those settings, enter new settings here, or in an /etc/sysctl.d/&lt;name&gt;.conf file</span><br><span class="line">#</span><br><span class="line"># For more information, see sysctl.conf(5) and sysctl.d(5).</span><br><span class="line">fs.aio-max-nr = 1048576</span><br><span class="line">fs.file-max = 6815744</span><br><span class="line">kernel.shmall = 2097152</span><br><span class="line">kernel.shmmax = 536870912   #最低：536870912，最大值：比物理内存小1个字节的值，建议超过物理内存的一半</span><br><span class="line">kernel.shmmni = 4096</span><br><span class="line">kernel.sem = 250 32000 100 128</span><br><span class="line">net.ipv4.ip_local_port_range = 9000 65500</span><br><span class="line">net.core.rmem_default = 262144</span><br><span class="line">net.core.rmem_max = 4194304</span><br><span class="line">net.core.wmem_default = 262144</span><br><span class="line">net.core.wmem_max = 1048576</span><br></pre></td></tr></table></figure>
<p>执行<br>sysctl -p</p>
<h3 id="1-5-修改用户限制"><a href="/2022/08/10/oracle新建实例/#1-5-修改用户限制" class="headerlink" title="1.5 修改用户限制"></a>1.5 修改用户限制</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim  /etc/security/limits.conf</span><br><span class="line"></span><br><span class="line">#在末尾添加</span><br><span class="line">oracle soft nproc 2047</span><br><span class="line">oracle hard nproc 16384</span><br><span class="line">oracle soft nofile 1024</span><br><span class="line">oracle hard nofile 65536</span><br><span class="line">oracle soft stack 10240</span><br><span class="line">oracle hard stack 10240</span><br></pre></td></tr></table></figure>
<p>在/etc/pam.d/login 文件中，使用文本编辑器或vi命令增加或修改以下内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">session required /lib64/security/pam_limits.so</span><br><span class="line">session required pam_limits.so</span><br></pre></td></tr></table></figure></p>
<p>在/etc/profile 文件中，使用文本编辑器或vi命令增加或修改以下内容<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if [ $USER = &quot;oracle&quot; ]; then</span><br><span class="line">   if [ $SHELL = &quot;/bin/ksh&quot; ]; then</span><br><span class="line">       ulimit -p 16384</span><br><span class="line">       ulimit -n 65536</span><br><span class="line">    else</span><br><span class="line">       ulimit -u 16384 -n 65536</span><br><span class="line">   fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>source /etc/profile</p>
<h2 id="2-安装前"><a href="/2022/08/10/oracle新建实例/#2-安装前" class="headerlink" title="2 安装前"></a>2 安装前</h2><h3 id="2-1-创建目录"><a href="/2022/08/10/oracle新建实例/#2-1-创建目录" class="headerlink" title="2.1 创建目录"></a>2.1 创建目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p /home/data/app/</span><br><span class="line">chown -R oracle:oinstall /home/data/app/</span><br><span class="line">chmod -R 775 /home/data/app/</span><br></pre></td></tr></table></figure>
<h3 id="2-2-配置环境变量"><a href="/2022/08/10/oracle新建实例/#2-2-配置环境变量" class="headerlink" title="2.2 配置环境变量"></a>2.2 配置环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[oracle@docker ~]$ vim ~/.bash_profile </span><br><span class="line"></span><br><span class="line">export ORACLE_BASE=/home/data/app/oracle</span><br><span class="line">export ORACLE_SID=cpaasdb</span><br></pre></td></tr></table></figure>
<p>执行 source ~/.bash_profile<br>上传ORALCE软件到/home/data下。解压到/home/data/database</p>
<h3 id="2-3-复制响应文件模板"><a href="/2022/08/10/oracle新建实例/#2-3-复制响应文件模板" class="headerlink" title="2.3 复制响应文件模板"></a>2.3 复制响应文件模板</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /home/data/etc</span><br><span class="line">cp  /home/data/database/response/* /home/data/etc/</span><br><span class="line">[oracle@docker ~]$ ls /home/data/etc</span><br><span class="line">dbca.rsp  db_install.rsp  netca.rsp</span><br></pre></td></tr></table></figure>
<p>设置响应文件权限<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 700 /home/data/etc/*.rsp</span><br></pre></td></tr></table></figure></p>
<h2 id="3-安装"><a href="/2022/08/10/oracle新建实例/#3-安装" class="headerlink" title="3.安装"></a>3.安装</h2><h3 id="3-1静默安装"><a href="/2022/08/10/oracle新建实例/#3-1静默安装" class="headerlink" title="3.1静默安装"></a>3.1静默安装</h3><p>su - oracle<br>修改安装Oracle软件的响应文件/home/data/etc/db_install.rsp<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">oracle.install.option=INSTALL_DB_SWONLY     // 安装类型</span><br><span class="line">ORACLE_HOSTNAME=centosdb        // 主机名称（hostname查询）</span><br><span class="line">UNIX_GROUP_NAME=oinstall     // 安装组</span><br><span class="line">INVENTORY_LOCATION=/home/data/app/oracle/oraInventory   //INVENTORY目录（不填就是默认值）</span><br><span class="line">SELECTED_LANGUAGES=en,zh_CN,zh_TW // 选择语言</span><br><span class="line">ORACLE_HOME=/home/data/app/oracle/product/11.2.0/dbhome_1    //oracle_home</span><br><span class="line">ORACLE_BASE=/home/data/app/oracle     //oracle_base</span><br><span class="line">oracle.install.db.InstallEdition=EE 　　　　// oracle版本</span><br><span class="line">oracle.install.db.isCustomInstall=true 　　//自定义安装，否，使用默认组件</span><br><span class="line">oracle.install.db.DBA_GROUP=dba /　　/ dba用户组</span><br><span class="line">oracle.install.db.OPER_GROUP=oinstall // oper用户组</span><br><span class="line">oracle.install.db.config.starterdb.type= //数据库类型</span><br><span class="line">oracle.install.db.config.starterdb.globalDBName=cpaasdb //globalDBName</span><br><span class="line">oracle.install.db.config.starterdb.SID=cpaasdb      //SID</span><br><span class="line">oracle.install.db.config.starterdb.memoryLimit=81920 //自动管理内存的内存(M)</span><br><span class="line">oracle.install.db.config.starterdb.password.ALL=oracle //设定所有数据库用户使用同一个密码</span><br><span class="line">SECURITY_UPDATES_VIA_MYORACLESUPPORT=false         //（手动写了false）</span><br><span class="line">DECLINE_SECURITY_UPDATES=true 　　//设置安全更新（貌似是有bug，这个一定要选true，否则会无限提醒邮件地址有问题，终止安装。PS：不管地址对不对）</span><br></pre></td></tr></table></figure></p>
<p>开始安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[oracle@docker database]$ /home/data/database/runInstaller -silent -responseFile /home/data/etc/db_install.rsp</span><br></pre></td></tr></table></figure></p>
<p>查看日志<br>tail -f /home/data/app/oracle/inventory/logs/installActions2016-08-31_06-56-29PM.log<br>出现类似如下提示表示安装完成：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------------------------------------------------------------------</span><br><span class="line">The following configuration scripts need to be executed as the &quot;root&quot; user.</span><br><span class="line">#!/bin/sh</span><br><span class="line">#Root scripts to run</span><br><span class="line"></span><br><span class="line">/u01/app/oraInventory/orainstRoot.sh  #不同的地址根据自己的实际</span><br><span class="line">/u01/app/oracle/product/11.2.0/db_1/root.sh</span><br><span class="line">To execute the configuration scripts:</span><br><span class="line">1. Open a terminal window</span><br><span class="line">2. Log in as &quot;root&quot;</span><br><span class="line">3. Run the scripts</span><br><span class="line">4. Return to this window and hit &quot;Enter&quot; key to continue</span><br><span class="line"></span><br><span class="line">Successfully Setup Software.</span><br></pre></td></tr></table></figure></p>
<p>使用root用户执行脚本,<br>su - root<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/u01/app/oraInventory/orainstRoot.sh </span><br><span class="line">/u01/app/oracle/product/11.2.0/db_1/root.sh</span><br></pre></td></tr></table></figure></p>
<p>注：不同的地址根据自己的实际</p>
<h3 id="3-2-增加或修改oracle的环境变量"><a href="/2022/08/10/oracle新建实例/#3-2-增加或修改oracle的环境变量" class="headerlink" title="3.2 增加或修改oracle的环境变量"></a>3.2 增加或修改oracle的环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su  - oracle</span><br><span class="line">vim ~/.bash_profile</span><br><span class="line">export ORACLE_HOSTNAME=centosdb</span><br><span class="line">export ORACLE_BASE=/home/data/app/oracle</span><br><span class="line">export ORACLE_HOME=$ORACLE_BASE/product/11.2.0/dbhome_1</span><br><span class="line">export ORACLE_SID=cpaasdb</span><br><span class="line">export PATH=.:$ORACLE_HOME/bin:$ORACLE_HOME/OPatch:$ORACLE_HOME/jdk/bin:$PATH</span><br><span class="line">export LC_ALL=&quot;en_US&quot;</span><br><span class="line">export LANG=&quot;en_US&quot;</span><br><span class="line">export NLS_LANG=&quot;AMERICAN_AMERICA.ZHS16GBK&quot;</span><br><span class="line">export NLS_DATE_FORMAT=&quot;YYYY-MM-DD HH24:MI:SS&quot;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-配置监听程序"><a href="/2022/08/10/oracle新建实例/#3-3-配置监听程序" class="headerlink" title="3.3 配置监听程序"></a>3.3 配置监听程序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[oracle@docker ~]$ netca /silent /responsefile /home/data/etc/netca.rsp</span><br><span class="line"></span><br><span class="line">Parsing command line arguments:</span><br><span class="line">Parameter &quot;silent&quot; = true</span><br><span class="line">Parameter &quot;responsefile&quot; = /home/data/etc/netca.rsp</span><br><span class="line">Done parsing command line arguments.</span><br><span class="line">Oracle Net Services Configuration:</span><br><span class="line">Profile configuration complete.</span><br><span class="line">Oracle Net Listener Startup:</span><br><span class="line">Running Listener Control:</span><br><span class="line">/u01/app/oracle/product/11.2.0/db_1/bin/lsnrctl start LISTENER</span><br><span class="line">Listener Control complete.</span><br><span class="line">Listener started successfully.</span><br><span class="line">Listener configuration complete.</span><br><span class="line">Oracle Net Services configuration successful. The exit code is 0</span><br></pre></td></tr></table></figure>
<h3 id="3-4-启动监控程序"><a href="/2022/08/10/oracle新建实例/#3-4-启动监控程序" class="headerlink" title="3.4 启动监控程序"></a>3.4 启动监控程序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsnrctl start</span><br></pre></td></tr></table></figure>
<h2 id="4-静默dbca建库"><a href="/2022/08/10/oracle新建实例/#4-静默dbca建库" class="headerlink" title="4 静默dbca建库"></a>4 静默dbca建库</h2><h3 id="4-1、复制一份文件"><a href="/2022/08/10/oracle新建实例/#4-1、复制一份文件" class="headerlink" title="4.1、复制一份文件"></a>4.1、复制一份文件</h3><p>cp /home/data/etc/dbca.rsp /home/data/etc/dbca_xxx.rsp</p>
<p>修改dbca_xxx.rsp 的cpaasdb为cpaasxxx</p>
<p>切换到ORALCE用户</p>
<p>su - oracle<br>执行以下命令<br>dbca -silent -responseFile /home/data/etc/dbca_xxx.rsp<br>如下：<br>Copying database files<br>1% complete<br>3% complete<br>11% complete<br>18% complete<br>26% complete<br>37% complete<br>Creating and starting Oracle instance<br>40% complete<br>45% complete<br>50% complete<br>55% complete<br>56% complete<br>60% complete<br>62% complete<br>Completing Database Creation<br>66% complete<br>70% complete<br>73% complete<br>85% complete<br>96% complete<br>100% complete<br>Look at the log file “/home/data/app/oracle/cfgtoollogs/dbca/cpaasxxx/cpaasxxx.log” for further details.</p>
<p>完成后<br>添加用户<br>export ORACLE_SID=cpaasxxx<br>sqlplus / as sysdba</p>
<blockquote>
<p>create user cpaasxxx identified by cpaasxxx;<br>grant dba,connect,resource to cpaasxxx;</p>
</blockquote>
<h2 id="5-导入导出"><a href="/2022/08/10/oracle新建实例/#5-导入导出" class="headerlink" title="5 导入导出"></a>5 导入导出</h2><p>exp <a href="/2022/08/10/oracle新建实例/mailto:system/123456@213.234.12.32" target="_blank" rel="noopener">system/123456@213.234.12.32</a>/mydb file=D:\example.dmp<br>imp <a href="/2022/08/10/oracle新建实例/mailto:system/123456@213.234.12.32" target="_blank" rel="noopener">system/123456@213.234.12.32</a>/mydb file=D:\example.dmp full=y ignore=y</p>
<h3 id="6-oracle"><a href="/2022/08/10/oracle新建实例/#6-oracle" class="headerlink" title="6 oracle"></a>6 oracle</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su - oracle</span><br><span class="line">lsnrctl start</span><br><span class="line">sqlplus /nolog</span><br><span class="line">conn / as sysdba;</span><br><span class="line">startup</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>redis中过期key的maxmemory-policy回收策略</title>
    <url>/2019/06/11/redis%E4%B8%AD%E8%BF%87%E6%9C%9Fkey%E7%9A%84maxmemory-policy%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h3 id="redis内存问题"><a href="/2019/06/11/redis中过期key的maxmemory-policy回收策略/#redis内存问题" class="headerlink" title="redis内存问题"></a>redis内存问题</h3><p>Redis内存太大，会造成redis挂掉</p>
<h4 id="最大内存maxmemory"><a href="/2019/06/11/redis中过期key的maxmemory-policy回收策略/#最大内存maxmemory" class="headerlink" title="最大内存maxmemory"></a>最大内存maxmemory</h4><p>maxmemory设置最大内存，达到最大内存设置后，redis根据maxmemory-policy配置的策略来清理数据 释放空间</p>
<h4 id="六种maxmemory-policy"><a href="/2019/06/11/redis中过期key的maxmemory-policy回收策略/#六种maxmemory-policy" class="headerlink" title="六种maxmemory-policy"></a>六种maxmemory-policy</h4><ul>
<li>noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）</li>
<li>allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。</li>
<li>volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放</li>
<li>allkeys-random: 回收随机的键使得新添加的数据有空间存放。</li>
<li>volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。</li>
<li>volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。</li>
</ul>
<h4 id="设置方式"><a href="/2019/06/11/redis中过期key的maxmemory-policy回收策略/#设置方式" class="headerlink" title="设置方式"></a>设置方式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config set maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure>
<p>设置最大的内存<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config set maxmemory 12884901888  # 12*1024*1024*1024 12G</span><br><span class="line">CONFIG SET maxmemory 12288MB      # 12*1024</span><br></pre></td></tr></table></figure></p>
<p><strong>另外可以通过–bigkeys</strong>来查看最大key<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6300 --bigkeys</span><br><span class="line"><span class="meta">&gt;</span> ttl key  #查看key的过期时间</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis乐观锁之应用－秒杀抢购</title>
    <url>/2017/06/05/redis%E4%B9%90%E8%A7%82%E9%94%81%E4%B9%8B%E5%BA%94%E7%94%A8%EF%BC%8D%E7%A7%92%E6%9D%80%E6%8A%A2%E8%B4%AD/</url>
    <content><![CDATA[<h2 id="乐观锁"><a href="/2017/06/05/redis乐观锁之应用－秒杀抢购/#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>基于数据版本（version）的记录机制实现的。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个”version”字段来实现读取出数据时，将此版本号一同读出，之后更新时，对此版本号加1。此时，将提交数据的版本号与数据库表对应记录的当前版本号进行比对，如果提交的数据版本号大于数据库当前版本号，则予以更新，否则认为是过期数据。<br>redis中可以使用watch命令会监视给定的key，当exec时候如果监视的key从调用watch后发生过变化，则整个事务会失败</p>
<h2 id="redis事务"><a href="/2017/06/05/redis乐观锁之应用－秒杀抢购/#redis事务" class="headerlink" title="redis事务"></a>redis事务</h2><p>Redis中的事务(transaction)是一组命令的集合。事务同命令一样都是Redis最小的执行单位，一个事务中的命令要么都执行，要么都不执行。Redis事务的实现需要用到 MULTI 和 EXEC 两个命令，事务开始的时候先向Redis服务器发送 MULTI 命令，然后依次发送需要在本次事务中处理的命令，最后再发送 EXEC 命令表示事务命令结束。Redis的事务是下面4个命令来实现<br>1.multi，开启Redis的事务，置客户端为事务态。<br>2.exec，提交事务，执行从multi到此命令前的命令队列，置客户端为非事务态。<br>3.discard，取消事务，置客户端为非事务态。<br>4.watch,监视键值对，作用时如果事务提交exec时发现监视的监视对发生变化，事务将被取消。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.distribute.lock.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis乐观锁实例 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linbingwen</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptimisticLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		 <span class="keyword">long</span> starTime=System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		 initPrduct();</span><br><span class="line">		 initClient();</span><br><span class="line">		 printResult();</span><br><span class="line">		 </span><br><span class="line">		<span class="keyword">long</span> endTime=System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">long</span> Time=endTime-starTime;</span><br><span class="line">		System.out.println(<span class="string">"程序运行时间： "</span>+Time+<span class="string">"ms"</span>);   </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 输出结果</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Jedis jedis = RedisUtil.getInstance().getJedis();</span><br><span class="line">		Set&lt;String&gt; set = jedis.smembers(<span class="string">"clientList"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (String value : set) &#123;</span><br><span class="line">			System.out.println(<span class="string">"第"</span> + i++ + <span class="string">"个抢到商品，"</span>+value + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		RedisUtil.returnResource(jedis);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 初始化顾客开始抢商品</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">		<span class="keyword">int</span> clientNum = <span class="number">10000</span>;<span class="comment">// 模拟客户数目</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientNum; i++) &#123;</span><br><span class="line">			cachedThreadPool.execute(<span class="keyword">new</span> ClientThread(i));</span><br><span class="line">		&#125;</span><br><span class="line">		cachedThreadPool.shutdown();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </span><br><span class="line">	            <span class="keyword">if</span>(cachedThreadPool.isTerminated())&#123;  </span><br><span class="line">	                System.out.println(<span class="string">"所有的线程都结束了！"</span>);  </span><br><span class="line">	                <span class="keyword">break</span>;  </span><br><span class="line">	            &#125;  </span><br><span class="line">	            <span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;    </span><br><span class="line">	        &#125;  </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 初始化商品个数</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initPrduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> prdNum = <span class="number">100</span>;<span class="comment">// 商品个数</span></span><br><span class="line">		String key = <span class="string">"prdNum"</span>;</span><br><span class="line">		String clientList = <span class="string">"clientList"</span>;<span class="comment">// 抢购到商品的顾客列表</span></span><br><span class="line">		Jedis jedis = RedisUtil.getInstance().getJedis();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (jedis.exists(key)) &#123;</span><br><span class="line">			jedis.del(key);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (jedis.exists(clientList)) &#123;</span><br><span class="line">			jedis.del(clientList);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		jedis.set(key, String.valueOf(prdNum));<span class="comment">// 初始化</span></span><br><span class="line">		RedisUtil.returnResource(jedis);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顾客线程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> linbingwen</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">	String key = <span class="string">"prdNum"</span>;<span class="comment">// 商品主键</span></span><br><span class="line">	String clientList = <span class="string">"clientList"</span>;<span class="comment">//// 抢购到商品的顾客列表主键</span></span><br><span class="line">	String clientName;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		clientName = <span class="string">"编号="</span> + num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep((<span class="keyword">int</span>)(Math.random()*<span class="number">5000</span>));<span class="comment">// 随机睡眠一下</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"顾客:"</span> + clientName + <span class="string">"开始抢商品"</span>);</span><br><span class="line">			jedis = RedisUtil.getInstance().getJedis();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				jedis.watch(key);</span><br><span class="line">				<span class="keyword">int</span> prdNum = Integer.parseInt(jedis.get(key));<span class="comment">// 当前商品个数</span></span><br><span class="line">				<span class="keyword">if</span> (prdNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					Transaction transaction = jedis.multi();</span><br><span class="line">					transaction.set(key, String.valueOf(prdNum - <span class="number">1</span>));</span><br><span class="line">					List&lt;Object&gt; result = transaction.exec();</span><br><span class="line">					<span class="keyword">if</span> (result == <span class="keyword">null</span> || result.isEmpty()) &#123;</span><br><span class="line">						System.out.println(<span class="string">"悲剧了，顾客:"</span> + clientName + <span class="string">"没有抢到商品"</span>);<span class="comment">// 可能是watch-key被外部修改，或者是数据操作被驳回</span></span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						jedis.sadd(clientList, clientName);<span class="comment">// 抢到商品记录一下</span></span><br><span class="line">						System.out.println(<span class="string">"好高兴，顾客:"</span> + clientName + <span class="string">"抢到商品"</span>);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					System.out.println(<span class="string">"悲剧了，库存为0，顾客:"</span> + clientName + <span class="string">"没有抢到商品"</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				jedis.unwatch();</span><br><span class="line">				RedisUtil.returnResource(jedis);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis内存分析工具rdb</title>
    <url>/2019/06/11/redis%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7rdb/</url>
    <content><![CDATA[<h3 id="rdb"><a href="/2019/06/11/redis内存分析工具rdb/#rdb" class="headerlink" title="rdb"></a>rdb</h3><p>redis-rdb-tools是由Python写的用来分析Redis的rdb快照文件用的工具，它可以把rdb快照文件生成json文件或者生成报表用来分析Redis的使用详情、使用标准的diff工具比较两个dump文件，总之是比较实用的工具，至于安装可以通过Python的pip来安装</p>
<h4 id="安装"><a href="/2019/06/11/redis内存分析工具rdb/#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install python-pip python-redis</span><br><span class="line"></span><br><span class="line">正在解决依赖关系</span><br><span class="line"><span class="meta">--&gt;</span> 正在检查事务</span><br><span class="line"><span class="meta">---&gt;</span> 软件包 python2-pip.noarch.0.8.1.2-8.el7 将被 安装</span><br><span class="line"><span class="meta">---&gt;</span> 软件包 python2-redis.noarch.0.2.10.6-1.el7 将被 安装</span><br><span class="line"></span><br><span class="line">pip install rdbtools</span><br></pre></td></tr></table></figure>
<p>rdb常用的几个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-h，--help                         显示此帮助信息并退出</span><br><span class="line">-c FILE, --command=FILE            要执行的命令，转出的类型。有效的命令是json(转成json)，diff（差异比对），justkeys（仅有key），justkeyvals（仅有value），memory（内存报告）， protocol（导成添加指令）</span><br><span class="line"></span><br><span class="line">-f FILE, --file=FILE               文件输出文件</span><br><span class="line">-n DBS, --db=DBS                   DBS数据库号码。可以提供多个数据库。如果未指定，则将包括所有数据库。</span><br><span class="line">-k KEYS, --key=KEYS                显示出的Redis的key。这可以是一个正则表达式</span><br><span class="line">-o NOT_KEYS, --not-key=NOT_KEYS    显示忽略的key。这可以是一个正则表达式</span><br><span class="line">-t TYPES, --type=TYPES             显示出数据类型，key的数据类型string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型），如果没有指定，全部数据类型将被返回</span><br><span class="line"></span><br><span class="line">-b BYTES, --bytes=BYTES            将内存输出限制为大于或等于的key，单位字节</span><br><span class="line">-l LARGEST, --largest=LARGEST      将内存输出限制为只有前N个key（按大小）</span><br><span class="line">-e ESCAPE, --escape=ESCAPE         将字符串转义为编码：raw（默认），print，utf8或base64。</span><br></pre></td></tr></table></figure>
<h4 id="运用"><a href="/2019/06/11/redis内存分析工具rdb/#运用" class="headerlink" title="运用"></a>运用</h4><p>把匹配到的key的key和value用json的格式打印</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example : rdb --command json -k &quot;user.*&quot; /var/redis/6379/dump.rdb</span><br></pre></td></tr></table></figure>
<p>把Redis的rdb内存分析报告生成csv文件，可以使用awk等相关工具分析，也可以导入数据库用以分析</p>
<p>rdb -c memory dump.rdb &gt; memory.csv</p>
<p><strong>创建SQL</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `memory` (</span><br><span class="line">  `database` int(128) DEFAULT NULL,</span><br><span class="line">  `type` varchar(128) DEFAULT NULL,</span><br><span class="line">  `KEY` varchar(128) DEFAULT NULL,</span><br><span class="line">  `size_in_bytes` bigint(20) DEFAULT NULL,</span><br><span class="line">  `encoding` varchar(128) DEFAULT NULL,</span><br><span class="line">  `num_elements` bigint(20) DEFAULT NULL,</span><br><span class="line">  `len_largest_element` varchar(128) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`KEY`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>将memory.csv导入数据库中，数据如下：</p>
<table>
<thead>
<tr>
<th>database</th>
<th>type</th>
<th>key</th>
<th>size_in_bytes</th>
<th>encoding</th>
<th>num_elements</th>
<th>len_largest_element</th>
<th>expiry</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>string</td>
<td>dn1.jgyjhgl</td>
<td>41016</td>
<td>string</td>
<td>38035</td>
<td>38035</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>string</td>
<td>dn0.hydkjxgzhzcx</td>
<td>14400</td>
<td>string</td>
<td>12712</td>
<td>12712</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>string</td>
<td>dn0.zxllgl.para</td>
<td>16448</td>
<td>string</td>
<td>15143</td>
<td>15143</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>string</td>
<td>dn0.zhjstzdr2</td>
<td>16440</td>
<td>string</td>
<td>16081</td>
<td>16081</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>string</td>
<td>dn1.zhsthyrjrlye.para</td>
<td>10304</td>
<td>string</td>
<td>8365</td>
<td>8365</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>string</td>
<td>dn0.cdkqxlrfx</td>
<td>20536</td>
<td>string</td>
<td>19333</td>
<td>19333</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>string</td>
<td>dn1.eckhjxfpdr</td>
<td>14392</td>
<td>string</td>
<td>13945</td>
<td>13945</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>string</td>
<td>dn0.bldkqsjxcx.para</td>
<td>16448</td>
<td>string</td>
<td>14736</td>
<td>14736</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的持久化策略</title>
    <url>/2019/06/11/redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h3 id="redis持久化"><a href="/2019/06/11/redis的持久化策略/#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h3><p>Redis 有两种持久化方案，RDB （Redis DataBase）和 AOF （Append Only File）</p>
<h4 id="rdb方案"><a href="/2019/06/11/redis的持久化策略/#rdb方案" class="headerlink" title="rdb方案"></a>rdb方案</h4><p>RDB 是 Redis 默认的持久化方案。在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。</p>
<p><em>在redis.conf中</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>   save ""</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>
<p>上面的意思是：</p>
<p><em>900秒内有1个更改，300秒内有10个更改以及60秒内有10000个更改，则将内存中的数据快照写入磁盘</em>。</p>
<p><em>若不想用RDB方案，可以把 save “” 的注释打开，下面三个注释。</em></p>
<p>RDB文件一般采用默认的 dump.rdb</p>
<p><em>在redis.conf中</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dbfilename dump.rdb   #</span><br><span class="line">rdbcompression yes    #配置存储至本地数据库时是否压缩数据，默认为yes</span><br></pre></td></tr></table></figure>
<p>redis的恢复</p>
<p>将dump.rdb 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可。</p>
<p><strong>优缺点：</strong></p>
<p>优点：<br>1 适合大规模的数据恢复。<br>2 如果业务对数据完整性和一致性要求不高，RDB是很好的选择。</p>
<p>缺点：<br>1 数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。<br>2 备份时占用内存，因为Redis 在备份时会独立创建一个子进程，将数据写入到一个临时文件（此时内存中的数据是原来的两倍），最后再将临时文件替换之前的备份文件。<br>所以Redis 的持久化和数据的恢复要选择在夜深人静的时候执行是比较合理的。</p>
<h4 id="aof方案"><a href="/2019/06/11/redis的持久化策略/#aof方案" class="headerlink" title="aof方案"></a>aof方案</h4><p>AOF ：Redis 默认不开启。它的出现是为了弥补RDB的不足（数据的不一致性），所以它采用日志的形式来记录每个<strong>写操作</strong>，并<strong>追加</strong>到文件中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">appendonly yes                             #开启需要手动把no改为yes</span><br><span class="line">appendfilename "appendonly.aof"            #指定本地数据库文件名，默认值为 appendonly.aof</span><br><span class="line"><span class="meta">#</span> appendfsync always</span><br><span class="line">appendfsync everysec                       #出厂默认推荐，每秒异步记录一次（默认值）     </span><br><span class="line"><span class="meta">#</span> appendfsync no</span><br><span class="line"><span class="meta">#</span>配置重写触发机制</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>
<p><em>根据配置文件触发，可以是每次执行触发，可以是每秒触发，可以不同步。</em></p>
<p><strong>数据恢复</strong></p>
<p>将appendonly.aof 文件拷贝到redis的安装目录的bin目录下，重启redis服务即可。但在实际开发中，可能因为某些原因导致appendonly.aof 文件格式异常，从而导致数据还原失败，可以通过命令redis-check-aof –fix appendonly.aof 进行修复</p>
<p>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure>
<p><strong>优缺点：</strong></p>
<p>优点：数据的完整性和一致性更高<br>缺点：因为AOF记录的内容多，文件会越来越大，数据恢复也会越来越慢。</p>
<p><em>参考：<a href="https://www.cnblogs.com/itdragon/p/7906481.html" target="_blank" rel="noopener">https://www.cnblogs.com/itdragon/p/7906481.html</a></em></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 高可用方案</title>
    <url>/2019/02/28/redis%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="1-主从配制模式-哨兵监控"><a href="/2019/02/28/redis高可用方案/#1-主从配制模式-哨兵监控" class="headerlink" title="1.主从配制模式+哨兵监控"></a>1.主从配制模式+哨兵监控</h3><h4 id="1-1、Redis主从模式配置"><a href="/2019/02/28/redis高可用方案/#1-1、Redis主从模式配置" class="headerlink" title="1.1、Redis主从模式配置"></a>1.1、Redis主从模式配置</h4><p>Redis的主从模式配置是非常简单的，要求两个节点，如下</p>
<p>主节点（master）:192.168.0.16:6379</p>
<p>从节点（slave）:192.168.0.7:6379</p>
<p><em>注意：在生产上这样的配置，没有意义，达不到双活，因为如果无论master节点还是slave节点挂了，我们都要手动启动来让他继续恢复工作。如果想要达到自动恢复，比如master挂掉了，在slave节点中选一个节点自动更换成master，redis在2.4之后出现了sentinel（哨兵监控），下面来看下（1.2）哨兵监控的机制：</em></p>
<h4 id="1-2、哨兵监控（Sentinel）"><a href="/2019/02/28/redis高可用方案/#1-2、哨兵监控（Sentinel）" class="headerlink" title="1.2、哨兵监控（Sentinel）"></a>1.2、哨兵监控（Sentinel）</h4><p>Sentinel是Redis的高可用性（HA）解决方案，由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进行下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p>
<p>基本原理是：心跳机制+投票裁决</p>
<p>（1）监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。</p>
<p>（2）提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。</p>
<p>（3）自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器</p>
<h4 id="1-3、哨兵机制的原理图"><a href="/2019/02/28/redis高可用方案/#1-3、哨兵机制的原理图" class="headerlink" title="1.3、哨兵机制的原理图"></a>1.3、哨兵机制的原理图</h4><p>当集群正常时</p>
<p><img src="https://clyhs.github.io/images/redis/redis01.png" alt="img"></p>
<p>当一个节点发生故障时，哨兵监控系统会从新选择一个新节点，做为主节点，如图</p>
<p><img src="https://clyhs.github.io/images/redis/redis02.png" alt="img"></p>
<h4 id="1-4、哨兵监控的服务器要求"><a href="/2019/02/28/redis高可用方案/#1-4、哨兵监控的服务器要求" class="headerlink" title="1.4、哨兵监控的服务器要求"></a>1.4、哨兵监控的服务器要求</h4><p>（1）、redis主要配置至少要一主一从，从可以多个，但是主只能一个</p>
<p>（2）、哨兵监控系统，可以一个，也可以多个</p>
<h3 id="2-分布式方案"><a href="/2019/02/28/redis高可用方案/#2-分布式方案" class="headerlink" title="2.分布式方案"></a>2.分布式方案</h3><h4 id="2-1、redis分布式配置"><a href="/2019/02/28/redis高可用方案/#2-1、redis分布式配置" class="headerlink" title="2.1、redis分布式配置"></a>2.1、redis分布式配置</h4><p>一般redis分布式要求三主三从，分布式与哨兵监控的差别在于，有多个主节点，每个主节点都需要从节点。最少要三个节点存活</p>
<p>主节点（master1）:192.168.0.16:6379</p>
<p>主节点（master2）:192.168.0.16:6378</p>
<p>主节点（master3）:192.168.0.16:6377</p>
<p>从节点（slave1）:192.168.0.7:6379</p>
<p>从节点（slave2）:192.168.0.7:6378</p>
<p>从节点（slave3）:192.168.0.7:6377</p>
<h4 id="2-2、分布式的原理图"><a href="/2019/02/28/redis高可用方案/#2-2、分布式的原理图" class="headerlink" title="2.2、分布式的原理图"></a>2.2、分布式的原理图</h4><p>当两台虚拟机正常时</p>
<p><img src="https://clyhs.github.io/images/redis/redis03.png" alt="img"></p>
<p>当一有台虚拟机发生故障，如图</p>
<p><img src="https://clyhs.github.io/images/redis/redis04.png" alt="img"></p>
<h4 id="2-3、服务器要求"><a href="/2019/02/28/redis高可用方案/#2-3、服务器要求" class="headerlink" title="2.3、服务器要求"></a>2.3、服务器要求</h4><p>至少两台虚拟机，每台三个节点。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>shipyard编译入门</title>
    <url>/2017/04/10/shipyard%E7%BC%96%E8%AF%91%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="shipyard"><a href="/2017/04/10/shipyard编译入门/#shipyard" class="headerlink" title="shipyard"></a>shipyard</h1><h2 id="shipyard简介"><a href="/2017/04/10/shipyard编译入门/#shipyard简介" class="headerlink" title="shipyard简介"></a>shipyard简介</h2><p>Shipyard是一款开源的图形化的Docker管理工具</p>
<hr>
<h3 id="环境要求"><a href="/2017/04/10/shipyard编译入门/#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><p>所以整个项目需要的环境如下:<code>centos7</code></p>
<ul>
<li>go环境</li>
<li>godep工具</li>
<li>nvm</li>
<li>bower</li>
<li>node.js</li>
</ul>
<h3 id="获取shipyard源码"><a href="/2017/04/10/shipyard编译入门/#获取shipyard源码" class="headerlink" title="获取shipyard源码"></a>获取shipyard源码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd $GOPATH/src/github.com/you-username/</span><br><span class="line"># git clone https://github.com/shipyard/shipyard.git</span><br></pre></td></tr></table></figure>
<h3 id="liteide"><a href="/2017/04/10/shipyard编译入门/#liteide" class="headerlink" title="liteide"></a>liteide</h3><p>通过LiteIDE或者其它工具打开源码，进行BUILD，提示相关的缺少的依赖需要手动下载到本地<br>比如：提示缺 github.com/xxx/xxx<br>手动下载<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">＃ go get github.com/xxx/xxx</span><br></pre></td></tr></table></figure></p>
<p>总共有10个左右依赖下载，直到BUILD通过</p>
<h3 id="进入shipyard的controller"><a href="/2017/04/10/shipyard编译入门/#进入shipyard的controller" class="headerlink" title="进入shipyard的controller"></a>进入shipyard的controller</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># godep go build-a -tags “netgo static_build” -installsuffix netgo</span><br></pre></td></tr></table></figure>
<h3 id="UI编译"><a href="/2017/04/10/shipyard编译入门/#UI编译" class="headerlink" title="UI编译"></a>UI编译</h3><p>进入到controller/static目录，然后直接输入如下命令回车即可<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bower -s install–allow-root -p | xargs echo &gt; /dev/null</span><br></pre></td></tr></table></figure></p>
<p>编译完成之后会在static目录下生成一个bower_components目录</p>
<h3 id="构建本地docker镜像"><a href="/2017/04/10/shipyard编译入门/#构建本地docker镜像" class="headerlink" title="构建本地docker镜像"></a>构建本地docker镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># docker build –t shipclub/shipyard .</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>shipyard</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>shipyard</tag>
      </tags>
  </entry>
  <entry>
    <title>shipyard集群部署</title>
    <url>/2017/04/10/shipyard%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="准备服务器centos7"><a href="/2017/04/10/shipyard集群部署/#准备服务器centos7" class="headerlink" title="准备服务器centos7"></a>准备服务器centos7</h3><table>
<thead>
<tr>
<th>服务器</th>
<th>IP</th>
</tr>
</thead>
<tbody>
<tr>
<td>master</td>
<td>192.168.0.100</td>
</tr>
<tr>
<td>slave01</td>
<td>192.168.0.101</td>
</tr>
<tr>
<td>slave02</td>
<td>192.168.0.102</td>
</tr>
</tbody>
</table>
<h3 id="修改HOST"><a href="/2017/04/10/shipyard集群部署/#修改HOST" class="headerlink" title="修改HOST"></a>修改HOST</h3><p>192.168.0.100  master<br>192.168.0.101  slave01<br>192.168.0.102  slave02</p>
<h3 id="关掉防火墙"><a href="/2017/04/10/shipyard集群部署/#关掉防火墙" class="headerlink" title="关掉防火墙"></a>关掉防火墙</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ service iptables stop</span><br><span class="line">$ service network restart </span><br><span class="line">$ systemctl stop firewalld.service</span><br><span class="line">$ systemctl disable firewalld.service</span><br><span class="line">$ sysctl net.ipv6.conf.all.disable_ipv6=1</span><br><span class="line"></span><br><span class="line">$ iptables -P INPUT ACCEPT</span><br><span class="line">$ iptables -P OUTPUT ACCEPT</span><br><span class="line">$ iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure>
<h3 id="master"><a href="/2017/04/10/shipyard集群部署/#master" class="headerlink" title="master"></a>master</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker pull swarm </span><br><span class="line">$ docker pull shipyard/shipyard</span><br><span class="line">$ docker pull rethinkdb</span><br><span class="line">$ docker pull microbox/etcd</span><br><span class="line">$ docker pull ehazlett/curl </span><br><span class="line">$ docker pull shipyard/docker-proxy</span><br><span class="line"></span><br><span class="line">$ docker run -ti -d --restart=always --name shipyard-rethinkdb rethinkdb</span><br><span class="line"></span><br><span class="line">$ docker run -ti -d -p 4001:4001 -p 7001:7001 --restart=always --name shipyard-discovery microbox/etcd -name discovery</span><br><span class="line"></span><br><span class="line">$ docker run -ti -d -p 2375:2375 --hostname=$HOSTNAME --restart=always --name shipyard-proxy -v /var/run/docker.sock:/var/run/docker.sock -e PORT=2375 shipyard/docker-proxy:latest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ docker run -ti -d --restart=always --name shipyard-swarm-manager swarm:latest manage --host tcp://0.0.0.0:3375 etcd://192.168.0.16:4001</span><br><span class="line"></span><br><span class="line">$ docker run -ti -d --restart=always --name shipyard-swarm-agent swarm:latest join --addr 192.168.0.16:2375 etcd://192.168.0.16:4001</span><br><span class="line"></span><br><span class="line">$ docker run -ti -d --restart=always \</span><br><span class="line">    --name shipyard-controller \</span><br><span class="line">    --link shipyard-rethinkdb:rethinkdb \</span><br><span class="line">    --link shipyard-swarm-manager:swarm \</span><br><span class="line">    -p 6969:8080 \</span><br><span class="line">    shipyard/shipyard:latest \</span><br><span class="line">    server \</span><br><span class="line">    -d tcp://swarm:3375</span><br></pre></td></tr></table></figure>
<h3 id="slave01-02"><a href="/2017/04/10/shipyard集群部署/#slave01-02" class="headerlink" title="slave01/02"></a>slave01/02</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker  pull microbox/etcd</span><br><span class="line">$ docker  pull shipyard/docker-proxy</span><br><span class="line">$ docker  pull swarm </span><br><span class="line">$ docker  pull alpine</span><br><span class="line"></span><br><span class="line">$ curl -sSL https://shipyard-project.com/deploy &gt; docker.sh</span><br><span class="line">$ export ACTION=node DISCOVERY=etcd://192.168.0.16:4001 &amp;&amp; bash docker.sh</span><br><span class="line">如果是用ZK作为注册中心</span><br><span class="line">$ export ACTION=node DISCOVERY=zk://192.168.0.16:2181 &amp;&amp; bash docker.sh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>shipyard</category>
      </categories>
      <tags>
        <tag>shipyard</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat堆一直涨解决方法</title>
    <url>/2019/05/30/tomcat%E5%A0%86%E4%B8%80%E7%9B%B4%E6%B6%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="loadrunner压测tomcat"><a href="/2019/05/30/tomcat堆一直涨解决方法/#loadrunner压测tomcat" class="headerlink" title="loadrunner压测tomcat"></a>loadrunner压测tomcat</h3><p>在24小时压测过程中，发现tomcat的堆一直在涨，从2G到8G再到16G，压2小时过后，堆就满了，无法释放</p>
<h4 id="方法一：tomcat参数调优"><a href="/2019/05/30/tomcat堆一直涨解决方法/#方法一：tomcat参数调优" class="headerlink" title="方法一：tomcat参数调优"></a>方法一：tomcat参数调优</h4><p>tomcat的优化如下：</p>
<ul>
<li>(1)采用cms垃圾回收</li>
</ul>
<p>catalina.sh</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS="-server -showversion -Xms2g -Xmx16g -Xmn1g -XX:PermSize=256m -</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -d64 -XX:CICompilerCount=8 -XX:+UseCompressedOops"</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -XX:SurvivorRatio=4 -XX:TargetSurvivorRatio=90"</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -XX:ReservedCodeCacheSize=256m -XX:-UseAdaptiveSizePolicy"</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -Duser.timezone=Asia/Shanghai -XX:-DontCompileHugeMethods"</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -Xss1024k -XX:+AggressiveOpts -XX:+UseBiasedLocking"</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -XX:MaxTenuringThreshold=31 -XX:+CMSParallelRemarkEnabled "</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -XX:GCTimeRatio=19 -XX:CMSFullGCsBeforeCompaction=0 -XX:+UseCMSCompactAtFullCollection  -XX:LargePageSizeInBytes=256m -XX:+UseFastAccessorMethods"</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=50 -Djava.awt.headless=true"</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -XX:+UseGCOverheadLimit -XX:AllocatePrefetchDistance=256 -XX:AllocatePrefetchStyle=1"</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:MaxGCPauseMillis=200"</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -XX:SoftRefLRUPolicyMSPerMB=0"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>JAVA_OPTS="$JAVA_OPTS -Dcom.sun.management.jmxremote.port=1090"</span><br><span class="line"><span class="meta">#</span>JAVA_OPTS="$JAVA_OPTS -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false"   </span><br><span class="line"><span class="meta">#</span>JAVA_OPTS="$JAVA_OPTS -Djava.util.logging.manager=org.apache.juli.ClassLoaderLogManager" </span><br><span class="line"><span class="meta">#</span>JAVA_OPTS="$JAVA_OPTS -Djava.util.logging.config.file=$CATALINA_HOME\conf\logging.properties"</span><br></pre></td></tr></table></figure>
<p>server.xml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;Executor name="tomcatThreadPool" namePrefix="catalina-exec-" </span><br><span class="line">        maxThreads="800" maxIdleTime="60000" </span><br><span class="line">        minSpareThreads="100"/&gt;</span><br><span class="line">        </span><br><span class="line">&lt;Connector executor="tomcatThreadPool"   port="8170" protocol="org.apache.coyote.http11.Http11NioProtocol"</span><br><span class="line">               connectionTimeout="20000"</span><br><span class="line">               compression="on"  </span><br><span class="line">               compressionMinSize="2048" </span><br><span class="line">               noCompressionUserAgents="gozilla, traviata"  </span><br><span class="line">               compressableMimeType="text/html,application/xhtml+xml,application/xml,text/xml,text/javascript,text/css,text/plain,application/x-</span><br><span class="line">javascript,application/javascript,text/xhtml,text/json,application/json,application/x-www-form-urlencoded,text/javaScript"  </span><br><span class="line">               useSendfile="false"</span><br><span class="line">               redirectPort="8443" /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>(2)采用G1回收</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS="$JAVA_OPTS -XX:+UseG1GC -XX:InitiatingHeapOccupancyPercent=50 -XX:MaxGCPauseMillis=200"</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -XX:ParallelGCThreads=8 -XX:ConcGCThreads=2 -XX:NewRatio=2 -XX:SurvivorRatio=8"</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -XX:TargetSurvivorRatio=50 -XX:InitialTenuringThreshold=7 -XX:MaxTenuringThreshold=15"</span><br><span class="line">JAVA_OPTS="$JAVA_OPTS -XX:G1ReservePercent=10 -XX:GCTimeRatio=19 -XX:+UnlockDiagnosticVMOptions"</span><br></pre></td></tr></table></figure>
<p><em>结果无论是cms回收还是g1回收都是2小时过后，堆就满了，可以定位系统内存泄漏，或者系统有问题，通过system.gc()方法强制回收是没有意义的，因为，用代码调用，只是通知jvm回收，但是jvm回不回收是自己决定，代码只起到通知作用而已。</em></p>
<h4 id="方法二：分析堆内存"><a href="/2019/05/30/tomcat堆一直涨解决方法/#方法二：分析堆内存" class="headerlink" title="方法二：分析堆内存"></a>方法二：分析堆内存</h4><p>分析工具包括：jvisualvm.exe 和eclipse MAT等，eclipse MAT只需要在ecllipse装mat插件</p>
<p>在linux通过jps查看tomcat的pid，如：10045</p>
<p>导入堆文件命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jmap -dump:format=b,file=/home/heap.hprof  10045</span><br></pre></td></tr></table></figure>
<p>图1：</p>
<p><img src="https://clyhs.github.io/images/tomcat/dump02.png" alt="img"></p>
<p>图2：</p>
<p><img src="https://clyhs.github.io/images/tomcat/dump03.png" alt="img"></p>
<p>图3：</p>
<p><img src="https://clyhs.github.io/images/tomcat/dump04.png" alt="img"></p>
<p>可以看到org.crazycake.shiro.SessionInMemory</p>
<p>原来是session一直存放在内存，查了一下shiro-redis的源码，可以通过参数设置，使session不存放在内存，只存放到redis缓存</p>
<p>配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisSessionDAO"</span> <span class="attr">class</span>=<span class="string">"org.crazycake.shiro.RedisSessionDAO"</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"redisManager"</span> <span class="attr">ref</span>=<span class="string">"redisManager"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionInMemoryEnabled"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">	    <span class="comment">&lt;!-- optional properties</span></span><br><span class="line"><span class="comment">	    &lt;property name="expire" value="-2"/&gt;</span></span><br><span class="line"><span class="comment">	    &lt;property name="keyPrefix" value="shiro:session:" /&gt;</span></span><br><span class="line"><span class="comment">	    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>再看下tomcat的监控：</p>
<p>如图：</p>
<p><img src="https://clyhs.github.io/images/tomcat/dump01.png" alt="img"></p>
<p>再用loadrunner压测，堆终于不增长。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat使用keytool配置https</title>
    <url>/2017/08/11/tomcat%E4%BD%BF%E7%94%A8keytool%E9%85%8D%E7%BD%AEhttps/</url>
    <content><![CDATA[<h2 id="一、生成证书"><a href="/2017/08/11/tomcat使用keytool配置https/#一、生成证书" class="headerlink" title="一、生成证书"></a>一、生成证书</h2><p>1、<strong>生成服务器证书</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -genkey -v -alias tomcat -keyalg RSA -keystore d:\tomcat.keystore -validity 36500</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/java/1.png" alt="img"></p>
<p>2、<strong>生成客户端证书</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -genkey -v -alias mclient -keyalg RSA -storetype PKCS12 -keystore d:\mclient.p12</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/java/2.png" alt="img"></p>
<p>3、<strong>让服务器信任客户端证书</strong></p>
<p>(1)由于不能直接将PKCS12格式的证书库导入，必须先把客户端证书导出为一个单独的CER文件，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -export -alias mclient -keystore d:\mclient.p12 -storetype PKCS12 -storepass 123456 -rfc -file d:\mclient.cer</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/java/3.png" alt="img"></p>
<p>(2)将该文件导入到服务器的证书库，添加为一个信任证书使用命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -import -v -file d:\mclient.cer –keystore d:\tomcat.keystore</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/java/4.png" alt="img"></p>
<p>(3)通过 list 命令查看服务器的证书库，可以看到两个证书，一个是服务器证书，一个是受信任的客户端证书：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -list -keystore tomcat.keystore</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/java/5.png" alt="img"></p>
<p>4、<strong>让客户端信任服务器证书</strong></p>
<p>把服务器证书导出为一个单独的CER文件提供给客户端，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -keystore d:\tomcat.keystore -export -alias tomcat -file d:\tomcat.cer</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/java/6.png" alt="img"></p>
<p>5、<strong>经过上面操作，生成如下证书：</strong></p>
<p><img src="https://clyhs.github.io/images/java/7.png" alt="img"></p>
<p>其中 tomcat.cer 提供给客户端，tomcat.keystore供服务器使用</p>
<h2 id="二、证书使用"><a href="/2017/08/11/tomcat使用keytool配置https/#二、证书使用" class="headerlink" title="二、证书使用"></a>二、证书使用</h2><p>1、<strong>服务器tomcat的配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot; </span><br><span class="line">      maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot; </span><br><span class="line">      clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; </span><br><span class="line">      keystoreFile=&quot;conf/cer/tomcat.keystore&quot; keystorePass=&quot;123456&quot; </span><br><span class="line">      truststoreFile=&quot;conf/cer/tomcat.keystore&quot; truststorePass=&quot;123456&quot; /&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">https://localhost:8443</span><br></pre></td></tr></table></figure>
<ul>
<li><p>修改tomcat的web.xml，强制http跳转到https</p>
<p>后面加上这样一段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;login-config&gt;    </span><br><span class="line">    &lt;!-- Authorization setting for SSL --&gt;    </span><br><span class="line">    &lt;auth-method&gt;CLIENT-CERT&lt;/auth-method&gt;    </span><br><span class="line">    &lt;realm-name&gt;Client Cert Users-only Area&lt;/realm-name&gt;    </span><br><span class="line">&lt;/login-config&gt;    </span><br><span class="line">&lt;security-constraint&gt;    </span><br><span class="line">    &lt;!-- Authorization setting for SSL --&gt;    </span><br><span class="line">    &lt;web-resource-collection &gt;    </span><br><span class="line">        &lt;web-resource-name &gt;SSL&lt;/web-resource-name&gt;    </span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    </span><br><span class="line">    &lt;/web-resource-collection&gt;    </span><br><span class="line">    &lt;user-data-constraint&gt;    </span><br><span class="line">        &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;    </span><br><span class="line">    &lt;/user-data-constraint&gt;    </span><br><span class="line">&lt;/security-constraint&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>2、 <strong>导入服务器公钥证书（tomcat.cer）</strong></p>
<p>由于是自签名的证书，为避免每次都提示不安全。这里双击tomcat.cer安装服务器证书。</p>
<p>注意：将证书填入到“受信任的根证书颁发机构”</p>
<p><img src="https://clyhs.github.io/images/java/8.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/java/9.png" alt="img"></p>
]]></content>
      <categories>
        <category>https</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>swift3.0 闭包</title>
    <url>/2018/04/15/swift3-0-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<h3 id="swift3-0闭包"><a href="/2018/04/15/swift3-0-闭包/#swift3-0闭包" class="headerlink" title="swift3.0闭包"></a>swift3.0闭包</h3><p>语法表达式<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">一般形式：</span><br><span class="line">&#123;</span><br><span class="line">      (parameters) -&gt; returnType <span class="keyword">in</span></span><br><span class="line">             statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这里的参数(parameters)，可以是in-out(输入输出参数)，但不能设定默认值。如果是可变参数，必须放在最后一位，不然编译器报错。元组也可以作为参数或者返回值。</li>
<li>“in”关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。即由in引入函数</li>
<li>例子</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一般形式</span></span><br><span class="line"><span class="keyword">let</span> calAdd:(<span class="type">Int</span>,<span class="type">Int</span>)-&gt;(<span class="type">Int</span>) = &#123;</span><br><span class="line">    (a:<span class="type">Int</span>,b:<span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(calAdd(<span class="number">100</span>,<span class="number">150</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Swift可以根据闭包上下文推断参数和返回值的类型，所以上面的例子可以简化如下</span></span><br><span class="line"><span class="keyword">let</span> calAdd2:(<span class="type">Int</span>,<span class="type">Int</span>)-&gt;(<span class="type">Int</span>) = &#123;</span><br><span class="line">    a,b <span class="keyword">in</span>  <span class="comment">//也可以写成(a,b) in</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(calAdd2(<span class="number">150</span>,<span class="number">100</span>))</span><br><span class="line"><span class="comment">//上面省略了返回箭头和参数及返回值类型，以及参数周围的括号。当然你也可以加括号，为了好看点，看的清楚点。(a,b)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//单行表达式闭包可以隐式返回，如下，省略return</span></span><br><span class="line"><span class="keyword">let</span> calAdd3:(<span class="type">Int</span>,<span class="type">Int</span>)-&gt;(<span class="type">Int</span>) = &#123;(a,b) <span class="keyword">in</span> a + b&#125;</span><br><span class="line"><span class="built_in">print</span>(calAdd3(<span class="number">50</span>,<span class="number">200</span>))</span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果闭包没有参数，可以直接省略“in”</span></span><br><span class="line"><span class="keyword">let</span> calAdd4:()-&gt;<span class="type">Int</span> = &#123;<span class="keyword">return</span> <span class="number">100</span> + <span class="number">150</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"....\(calAdd4())"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//这个写法，我随便写的。打印出“我是250”</span></span><br><span class="line"><span class="comment">//这个是既没有参数也没返回值，所以把return和in都省略了</span></span><br><span class="line"><span class="keyword">let</span> calAdd5:()-&gt;<span class="type">Void</span> = &#123;<span class="built_in">print</span>(<span class="string">"我是250"</span>)&#125;</span><br><span class="line">calAdd5()</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包类型是由参数类型和返回值类型决定，和函数是一样的。比如上面前三种写法的闭包的闭包类型就是(Int,Int)-&gt;(Int),后面的类型分别是()-&gt;Int和()-&gt;Void。分析下上面的代码：let calAdd：(add类型)。这里的add类型就是闭包类型 (Int,Int)-&gt;(Int)。意思就是声明一个calAdd常量，其类型是个闭包类型。</li>
<li>“=”右边是一个代码块，即闭包的具体实现，相当于给左边的add常量赋值。兄弟们，是不是感觉很熟悉了，有点像OC中的block代码块。</li>
</ul>
<h3 id="起别名"><a href="/2018/04/15/swift3-0-闭包/#起别名" class="headerlink" title="起别名"></a>起别名</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">AddBlock</span> = (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; (<span class="type">Int</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="type">Add</span>:<span class="type">AddBlock</span> = &#123;</span><br><span class="line">    (<span class="built_in">c</span>,d) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">c</span> + d</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="type">Result</span> = <span class="type">Add</span>(<span class="number">100</span>,<span class="number">150</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Result = \(Result)"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="尾随闭包"><a href="/2018/04/15/swift3-0-闭包/#尾随闭包" class="headerlink" title="尾随闭包"></a>尾随闭包</h3><p>若将闭包作为函数最后一个参数，可以省略参数标签,然后将闭包表达式写在函数调用括号后面<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testFunction</span><span class="params">(testBlock: <span class="params">()</span></span></span>-&gt;<span class="type">Void</span>)&#123;</span><br><span class="line">    <span class="comment">//这里需要传进来的闭包类型是无参数和无返回值的</span></span><br><span class="line">    testBlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正常写法</span></span><br><span class="line">testFunction(testBlock: &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"正常写法"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//尾随闭包写法</span></span><br><span class="line">testFunction()&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"尾随闭包写法"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以把括号去掉，也是尾随闭包写法。推荐写法</span></span><br><span class="line">testFunction &#123; </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"去掉括号的尾随闭包写法"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="值捕获"><a href="/2018/04/15/swift3-0-闭包/#值捕获" class="headerlink" title="值捕获"></a>值捕获</h3><p>闭包可以在其被定义的上下文中捕获常量或变量。Swift中，可以捕获值的闭包的最简单形式是嵌套函数，也就是定义在其他函数的函数体内的函数。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">captureValue</span><span class="params">(sums amount:Int)</span></span> -&gt; ()-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">incrementer</span><span class="params">()</span></span>-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">        total += amount</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> incrementer</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(captureValue(sums: <span class="number">10</span>)())</span><br><span class="line"><span class="built_in">print</span>(captureValue(sums: <span class="number">10</span>)())</span><br><span class="line"><span class="built_in">print</span>(captureValue(sums: <span class="number">10</span>)())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">captureValue2</span><span class="params">(sums amount:Int)</span></span> -&gt; ()-&gt;<span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> <span class="type">AddBlock</span>:()-&gt;<span class="type">Int</span> = &#123;</span><br><span class="line">        total += amount</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">AddBlock</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> testBlock = captureValue2(sums: <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(testBlock())</span><br><span class="line"><span class="built_in">print</span>(testBlock())</span><br><span class="line"><span class="built_in">print</span>(testBlock())</span><br></pre></td></tr></table></figure></p>
<h3 id="逃逸闭包"><a href="/2018/04/15/swift3-0-闭包/#逃逸闭包" class="headerlink" title="逃逸闭包"></a>逃逸闭包</h3><p>当一个闭包作为参数传到一个函数中，需要这个闭包在函数返回之后才被执行，我们就称该闭包从函数种逃逸。一般如果闭包在函数体内涉及到异步操作，但函数却是很快就会执行完毕并返回的，闭包必须要逃逸掉，以便异步操作的回调。<br>逃逸闭包一般用于异步函数的回调，比如网络请求成功的回调和失败的回调。语法：在函数的闭包行参前加关键字“@escaping”。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(some: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>)&#123;</span><br><span class="line">    <span class="comment">//延时操作，注意这里的单位是秒</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//1秒后操作</span></span><br><span class="line">        some()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"函数体"</span>)</span><br><span class="line">&#125;</span><br><span class="line">doSomething &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"逃逸闭包"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//例2</span></span><br><span class="line"><span class="keyword">var</span> comletionHandle: ()-&gt;<span class="type">String</span> = &#123;<span class="string">"约吗?"</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething2</span><span class="params">(some: @escaping <span class="params">()</span></span></span>-&gt;<span class="type">String</span>)&#123;</span><br><span class="line">    comletionHandle = some</span><br><span class="line">&#125;</span><br><span class="line">doSomething2 &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"叔叔，我们不约"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(comletionHandle())</span><br><span class="line"> </span><br><span class="line"><span class="comment">//将一个闭包标记为@escaping意味着你必须在闭包中显式的引用self。</span></span><br><span class="line"><span class="comment">//其实@escaping和self都是在提醒你，这是一个逃逸闭包，</span></span><br><span class="line"><span class="comment">//别误操作导致了循环引用！而非逃逸包可以隐式引用self。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//例子如下</span></span><br><span class="line"><span class="keyword">var</span> completionHandlers: [() -&gt; <span class="type">Void</span>] = []</span><br><span class="line"><span class="comment">//逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithEscapingClosure</span><span class="params">(completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    completionHandlers.append(completionHandler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非逃逸</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunctionWithNonescapingClosure</span><span class="params">(closure: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">        someFunctionWithEscapingClosure &#123; <span class="keyword">self</span>.x = <span class="number">100</span> &#125;</span><br><span class="line">        someFunctionWithNonescapingClosure &#123; x = <span class="number">200</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="自动闭包"><a href="/2018/04/15/swift3-0-闭包/#自动闭包" class="headerlink" title="自动闭包"></a>自动闭包</h3><p>顾名思义，自动闭包是一种自动创建的闭包，封装一堆表达式在自动闭包中，然后将自动闭包作为参数传给函数。而自动闭包是不接受任何参数的，但可以返回自动闭包中表达式产生的值。<br>自动闭包让你能够延迟求值，直到调用这个闭包，闭包代码块才会被执行。说白了，就是语法简洁了，有点懒加载的意思。<br><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"I"</span>,<span class="string">"have"</span>,<span class="string">"a"</span>,<span class="string">"apple"</span>]</span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">count</span>)</span><br><span class="line"><span class="comment">//打印出"4"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> removeBlock = &#123;array.remove(at: <span class="number">3</span>)&#125;<span class="comment">//测试了下，这里代码超过一行，返回值失效。</span></span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">count</span>)</span><br><span class="line"><span class="comment">//打印出"4"</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">"执行代码块移除\(removeBlock())"</span>)</span><br><span class="line"><span class="comment">//打印出"执行代码块移除apple" 这里自动闭包返回了apple值</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(array.<span class="built_in">count</span>)</span><br><span class="line"><span class="comment">//打印出"3"</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>swift3.0</category>
      </categories>
      <tags>
        <tag>swift3.0</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro redis session共享</title>
    <url>/2019/02/16/shiro-redis-session%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h3 id="引入依赖包"><a href="/2019/02/16/shiro-redis-session共享/#引入依赖包" class="headerlink" title="引入依赖包"></a>引入依赖包</h3><p>在pom文件引入如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.data&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.6.0.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-session&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.0.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;shiro-core&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;shiro-web&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.2.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.crazycake&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;shiro-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h3 id="配置spring-context-xml"><a href="/2019/02/16/shiro-redis-session共享/#配置spring-context-xml" class="headerlink" title="配置spring-context.xml"></a>配置spring-context.xml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--单机版--&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">&lt;bean id=&quot;redisManager&quot; class=&quot;org.crazycake.shiro.RedisManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;host&quot; value=&quot;192.168.0.7:6379&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--分布式--&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">&lt;bean id=&quot;redisManager&quot; class=&quot;org.crazycake.shiro.RedisClusterManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;host&quot; value=&quot;192.168.0.16:8001,192.168.0.16:8002,192.168.0.16:8003,192.168.0.7:8004,192.168.0.7:8005,192.168.0.7:8006&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--高可用--&gt;</span><br><span class="line">&lt;bean id=&quot;redisManager&quot; class=&quot;org.crazycake.shiro.RedisSentinelManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;host&quot; value=&quot;192.168.0.7:26000,192.168.0.16:26001,192.168.0.16:26002&quot;/&gt;</span><br><span class="line">    &lt;!--  &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;--&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">&lt;bean id=&quot;redisCacheManager&quot; class=&quot;org.crazycake.shiro.RedisCacheManager&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;redisManager&quot; ref=&quot;redisManager&quot; /&gt;</span><br><span class="line">	&lt;!-- optional properties</span><br><span class="line">	&lt;property name=&quot;expire&quot; value=&quot;1800&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;keyPrefix&quot; value=&quot;shiro:cache:&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;principalIdFieldName&quot; value=&quot;id&quot; /&gt;</span><br><span class="line">	--&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;credentialsMatcher&quot; class=&quot;org.apache.shiro.authc.credential.HashedCredentialsMatcher&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;hashAlgorithmName&quot; value=&quot;md5&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;hashIterations&quot; value=&quot;2&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;storedCredentialsHexEncoded&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;customRealm&quot; class=&quot;com.pas.cloud.module.shiro.CustomRealm&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;cachingEnabled&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;authenticationCachingEnabled&quot; value=&quot;false&quot; /&gt;</span><br><span class="line">	&lt;!-- </span><br><span class="line">	&lt;property name=&quot;credentialsMatcher&quot; ref=&quot;credentialsMatcher&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;cachingEnabled&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;authenticationCachingEnabled&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;authenticationCacheName&quot; value=&quot;authenticationCache&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;authorizationCachingEnabled&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;authorizationCacheName&quot; value=&quot;authorizationCache&quot; /&gt; --&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;redisSessionDAO&quot; class=&quot;org.crazycake.shiro.RedisSessionDAO&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;redisManager&quot; ref=&quot;redisManager&quot; /&gt;</span><br><span class="line">	&lt;!-- optional properties</span><br><span class="line">	&lt;property name=&quot;expire&quot; value=&quot;-2&quot;/&gt;</span><br><span class="line">	&lt;property name=&quot;keyPrefix&quot; value=&quot;shiro:session:&quot; /&gt;</span><br><span class="line">	--&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- sessionIdCookie的实现,用于重写覆盖容器默认的JSESSIONID --&gt;</span><br><span class="line">&lt;bean id=&quot;sessionIdCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;</span><br><span class="line">	&lt;!-- cookie的name,对应的默认是 JSESSIONID --&gt;</span><br><span class="line">	&lt;constructor-arg name=&quot;name&quot; value=&quot;SHAREJSESSIONID&quot; /&gt;</span><br><span class="line">	&lt;!-- jsessionId的path为 / 用于多个系统共享jsessionId --&gt;</span><br><span class="line">	&lt;property name=&quot;path&quot; value=&quot;/&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;httpOnly&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- sessionManager --&gt;</span><br><span class="line">&lt;!-- session管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;sessionManager&quot;</span><br><span class="line">	class=&quot;org.apache.shiro.web.session.mgt.DefaultWebSessionManager&quot;&gt;</span><br><span class="line">	&lt;!-- 设置全局会话超时时间，默认30分钟(1800000) --&gt;</span><br><span class="line">	&lt;property name=&quot;globalSessionTimeout&quot; value=&quot;1800000&quot; /&gt;</span><br><span class="line">	&lt;!-- 是否在会话过期后会调用SessionDAO的delete方法删除会话 默认true --&gt;</span><br><span class="line">	&lt;property name=&quot;deleteInvalidSessions&quot; value=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 会话验证器调度时间 --&gt;</span><br><span class="line">	&lt;property name=&quot;sessionValidationInterval&quot; value=&quot;1800000&quot; /&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- session存储的实现 --&gt;</span><br><span class="line">	&lt;property name=&quot;sessionDAO&quot; ref=&quot;redisSessionDAO&quot; /&gt;</span><br><span class="line">	&lt;!-- sessionIdCookie的实现,用于重写覆盖容器默认的JSESSIONID --&gt;</span><br><span class="line">	&lt;property name=&quot;sessionIdCookie&quot; ref=&quot;sessionIdCookie&quot; /&gt;</span><br><span class="line">	&lt;!-- 定时检查失效的session --&gt;</span><br><span class="line">	&lt;property name=&quot;sessionValidationSchedulerEnabled&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- securityManager安全管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;realm&quot; ref=&quot;customRealm&quot; /&gt;</span><br><span class="line">	&lt;!-- ehcahe缓存shiro自带 &lt;property name=&quot;cacheManager&quot; ref=&quot;shiroEhcacheManager&quot;&gt;&lt;/property&gt; --&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- redis缓存 --&gt;</span><br><span class="line">	&lt;property name=&quot;cacheManager&quot; ref=&quot;redisCacheManager&quot; /&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- sessionManager --&gt;</span><br><span class="line">	&lt;property name=&quot;sessionManager&quot; ref=&quot;sessionManager&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean</span><br><span class="line">class=&quot;org.springframework.beans.factory.config.MethodInvokingFactoryBean&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;staticMethod&quot;</span><br><span class="line">			value=&quot;org.apache.shiro.SecurityUtils.setSecurityManager&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;arguments&quot; ref=&quot;securityManager&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 记住我cookie --&gt;</span><br><span class="line">&lt;bean id=&quot;rememberMeCookie&quot; class=&quot;org.apache.shiro.web.servlet.SimpleCookie&quot;&gt;</span><br><span class="line">	&lt;!-- rememberMe是cookie的名字 --&gt;</span><br><span class="line">	&lt;constructor-arg value=&quot;rememberMe&quot; /&gt;</span><br><span class="line">	&lt;!-- 记住我cookie生效时间30天 --&gt;</span><br><span class="line">	&lt;property name=&quot;maxAge&quot; value=&quot;2592000&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- rememberMeManager管理器，写cookie，取出cookie生成用户信息 --&gt;</span><br><span class="line">&lt;bean id=&quot;rememberMeManager&quot; class=&quot;org.apache.shiro.web.mgt.CookieRememberMeManager&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;cookie&quot; ref=&quot;rememberMeCookie&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;shiroManager&quot; class=&quot;com.pas.cloud.module.shiro.ShiroManagerImpl&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;xtcdService&quot; ref=&quot;xtcdService&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;logoutFilter&quot; class=&quot;org.apache.shiro.web.filter.authc.LogoutFilter&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;redirectUrl&quot; value=&quot;/system/loginPage.html&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置shiro的过滤器工厂类，id- shiroFilter要和我们在web.xml中配置的过滤器一致 --&gt;</span><br><span class="line">&lt;!--  </span><br><span class="line">&lt;bean id=&quot;shiroFilter&quot; class=&quot;org.apache.shiro.spring.web.ShiroFilterFactoryBean&quot;&gt;--&gt;</span><br><span class="line">&lt;bean id=&quot;shiroFilter&quot; class=&quot;com.pas.cloud.module.shiro.PasShiroFilterFactoryBean&quot;&gt;</span><br><span class="line">	&lt;property name=&quot;securityManager&quot; ref=&quot;securityManager&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;loginUrl&quot; value=&quot;/system/loginPage.html&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;successUrl&quot; value=&quot;/system/index.html&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;unauthorizedUrl&quot; value=&quot;/unauth.jsp&quot; /&gt;</span><br><span class="line">	&lt;property name=&quot;filterChainDefinitions&quot; value=&quot;#&#123;shiroManager.loadFilterChainDefinitions()&#125;&quot; /&gt;</span><br><span class="line">&lt;!-- &lt;property name=&quot;filterChainDefinitions&quot;&gt; &lt;value&gt; /system/loginPage= </span><br><span class="line">anon /system/login = anon /system/loginout= logout /system/index=authc,perms[system:index] </span><br><span class="line">/module/user/add =authc,perms[module:user:add] /module/user/index = authc,perms[module:user:index] </span><br><span class="line">/module/user/del =authc,perms[module:user:del] /module/xtcd/index = authc, </span><br><span class="line">perms[module:xtcd:index] /module/** = authc &lt;/value&gt; &lt;/property&gt; --&gt;</span><br><span class="line">	&lt;property name=&quot;filters&quot;&gt;</span><br><span class="line">		&lt;map&gt;</span><br><span class="line">			&lt;entry key=&quot;logout&quot; value-ref=&quot;logoutFilter&quot; /&gt;</span><br><span class="line">		&lt;/map&gt;</span><br><span class="line">	&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;lifecycleBeanPostProcessor&quot; class=&quot;org.apache.shiro.spring.LifecycleBeanPostProcessor&quot; /&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>window redis 高可用部署</title>
    <url>/2019/02/28/window%20redis%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h3 id="一、redis-cluster部署"><a href="/2019/02/28/window redis高可用部署/#一、redis-cluster部署" class="headerlink" title="一、redis cluster部署"></a>一、redis cluster部署</h3><h4 id="1-下载Redis-x64-3-2-100-zip"><a href="/2019/02/28/window redis高可用部署/#1-下载Redis-x64-3-2-100-zip" class="headerlink" title="1.下载Redis-x64-3.2.100.zip"></a>1.下载Redis-x64-3.2.100.zip</h4><p>下载地址：   <a href="https://github.com/MSOpenTech/redis/releases/" target="_blank" rel="noopener">https://github.com/MSOpenTech/redis/releases/</a><br>解压到d盘，如 d:/redis<br>建目录d:/Redis/logs 日志目录</p>
<h4 id="2-新建脚本"><a href="/2019/02/28/window redis高可用部署/#2-新建脚本" class="headerlink" title="2.新建脚本"></a>2.新建脚本</h4><p>d:/Redis/redis.7000.conf </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 7000      </span><br><span class="line">loglevel notice    </span><br><span class="line">logfile &quot;D:/Redis/logs/redis7000_log.txt&quot;       </span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.7000.aof&quot;   </span><br><span class="line">cluster-enabled yes                                    </span><br><span class="line">cluster-config-file nodes.7000.conf</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line">cluster-slave-validity-factor 10</span><br><span class="line">cluster-migration-barrier 1</span><br><span class="line">cluster-require-full-coverage yes</span><br></pre></td></tr></table></figure>
<p><em>复制6份，修改成不同端口</em></p>
<p>d:/Redis/redis.7001.conf<br>d:/Redis/redis.7002.conf<br>d:/Redis/redis.7003.conf<br>d:/Redis/redis.7004.conf<br>d:/Redis/redis.7005.conf</p>
<h4 id="3-安装服务"><a href="/2019/02/28/window redis高可用部署/#3-安装服务" class="headerlink" title="3.安装服务"></a>3.安装服务</h4><p>D:/Redis/redis-server.exe –service-install D:/Redis/redis.7000.conf –service-name redis7000<br>D:/Redis/redis-server.exe –service-install D:/Redis/redis.7001.conf –service-name redis7001<br>D:/Redis/redis-server.exe –service-install D:/Redis/redis.7002.conf –service-name redis7002<br>D:/Redis/redis-server.exe –service-install D:/Redis/redis.7003.conf –service-name redis7003<br>D:/Redis/redis-server.exe –service-install D:/Redis/redis.7004.conf –service-name redis7004<br>D:/Redis/redis-server.exe –service-install D:/Redis/redis.7005.conf –service-name redis7005</p>
<h4 id="4-启动服务"><a href="/2019/02/28/window redis高可用部署/#4-启动服务" class="headerlink" title="4.启动服务"></a>4.启动服务</h4><p>D:/Redis/redis-server.exe –service-start –service-name Redis7000<br>D:/Redis/redis-server.exe –service-start –service-name Redis7001<br>D:/Redis/redis-server.exe –service-start –service-name Redis7002<br>D:/Redis/redis-server.exe –service-start –service-name Redis7003<br>D:/Redis/redis-server.exe –service-start –service-name Redis7004<br>D:/Redis/redis-server.exe –service-start –service-name Redis7005</p>
<h4 id="5-下载ruby"><a href="/2019/02/28/window redis高可用部署/#5-下载ruby" class="headerlink" title="5.下载ruby"></a>5.下载ruby</h4><p><a href="http://dl.bintray.com/oneclick/rubyinstaller/rubyinstaller-2.2.4-x64.exe" target="_blank" rel="noopener">http://dl.bintray.com/oneclick/rubyinstaller/rubyinstaller-2.2.4-x64.exe</a><br>安装到 d:/ruby</p>
<h4 id="6-下载驱动"><a href="/2019/02/28/window redis高可用部署/#6-下载驱动" class="headerlink" title="6.下载驱动"></a>6.下载驱动</h4><p>redis-3.2.2.gem<br>到d:/ruby/redis-3.2.2.gem<br>下载地址：<a href="https://rubygems.org/gems/redis/versions/3.2.2" target="_blank" rel="noopener">https://rubygems.org/gems/redis/versions/3.2.2</a> 点下载<br>安装 gem install –local d:\ruby\redis-3.2.2.gem</p>
<h4 id="7-下载创建集群脚本redis-trib-rb"><a href="/2019/02/28/window redis高可用部署/#7-下载创建集群脚本redis-trib-rb" class="headerlink" title="7.下载创建集群脚本redis-trib.rb"></a>7.下载创建集群脚本redis-trib.rb</h4><p><a href="https://raw.githubusercontent.com/MSOpenTech/redis/3.0/src/redis-trib.rb" target="_blank" rel="noopener">https://raw.githubusercontent.com/MSOpenTech/redis/3.0/src/redis-trib.rb</a><br>d:/Redis/redis-trib.rb</p>
<h4 id="8-创建集群"><a href="/2019/02/28/window redis高可用部署/#8-创建集群" class="headerlink" title="8.创建集群"></a>8.创建集群</h4><p>redis-trib.rb create –replicas 0 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005<br> 当出现提示时，需要手动输入yes，输入后，当出现以下内容，说明已经创建了Redis集群</p>
<h4 id="9-检验是否真的创建成功"><a href="/2019/02/28/window redis高可用部署/#9-检验是否真的创建成功" class="headerlink" title="9.检验是否真的创建成功"></a>9.检验是否真的创建成功</h4><p>输入以下命令：</p>
<p>redis-trib.rb check 127.0.0.1:7000</p>
<p>使用Redis客户端Redis-cli.exe来查看数据记录数，以及集群相关信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:/Redis/redis-cli.exe -c -p 7000</span><br><span class="line">&gt; dbsize</span><br></pre></td></tr></table></figure>
<h4 id="10-查看集群的信息："><a href="/2019/02/28/window redis高可用部署/#10-查看集群的信息：" class="headerlink" title="10.查看集群的信息："></a>10.查看集群的信息：</h4><p>输入cluster info可以从客户端的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster info</span><br></pre></td></tr></table></figure>
<h3 id="二、redis-sentinel模式"><a href="/2019/02/28/window redis高可用部署/#二、redis-sentinel模式" class="headerlink" title="二、redis sentinel模式"></a>二、redis sentinel模式</h3><h4 id="1-新建脚本"><a href="/2019/02/28/window redis高可用部署/#1-新建脚本" class="headerlink" title="1.新建脚本"></a>1.新建脚本</h4><p>D:/Redis/redis.master.8001.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 8001</span><br><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>D:/Redis/redis.slave1.8002.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 8002</span><br><span class="line">bind 127.0.0.1</span><br><span class="line">slaveof 127.0.0.1 8001</span><br></pre></td></tr></table></figure>
<p>D:/Redis/redis.slave2.8003.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 8003</span><br><span class="line">bind 127.0.0.1</span><br><span class="line">slaveof 127.0.0.1 8001</span><br></pre></td></tr></table></figure>
<h4 id="2-安装服务"><a href="/2019/02/28/window redis高可用部署/#2-安装服务" class="headerlink" title="2.安装服务"></a>2.安装服务</h4><p>D:/Redis/redis-server.exe –service-install D:/Redis/redis.master.8001.conf –service-name redismaster</p>
<p>D:/Redis/redis-server.exe –service-install D:/Redis/redis.slave1.8002.conf –service-name redisslave1</p>
<p>D:/Redis/redis-server.exe –service-install D:/Redis/redis.slave2.8003.conf –service-name redisslave2</p>
<h4 id="3-分别启动"><a href="/2019/02/28/window redis高可用部署/#3-分别启动" class="headerlink" title="3.分别启动"></a>3.分别启动</h4><p>D:/Redis/redis-server.exe –service-start –service-name redismaster<br>D:/Redis/redis-server.exe –service-start –service-name redisslave1<br>D:/Redis/redis-server.exe –service-start –service-name redisslave2</p>
<h4 id="4-配置sentinel"><a href="/2019/02/28/window redis高可用部署/#4-配置sentinel" class="headerlink" title="4.配置sentinel"></a>4.配置sentinel</h4><p>创建sentinel1.conf，sentinel2.conf，sentinel3.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 26001</span><br><span class="line">protected-mode no</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 8001 2 </span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line">sentinel failover-timeout mymaster 15000</span><br></pre></td></tr></table></figure>
<p>端口分别为26001，26002，26003</p>
<p>安装服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D:/Redis/redis-server.exe --service-install D:/Redis/sentinel1.conf --sentinel --service-name redissentienl26001</span><br><span class="line">D:/Redis/redis-server.exe --service-install D:/Redis/sentinel2.conf --sentinel --service-name redissentienl26002</span><br><span class="line">D:/Redis/redis-server.exe --service-install D:/Redis/sentinel3.conf --sentinel --service-name redissentienl26003</span><br></pre></td></tr></table></figure>
<h4 id="5-查检验证"><a href="/2019/02/28/window redis高可用部署/#5-查检验证" class="headerlink" title="5.查检验证"></a>5.查检验证</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 26001</span><br><span class="line">&gt; info sentinel</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper原理</title>
    <url>/2017/04/08/zookeeper%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="zookeeper入门"><a href="/2017/04/08/zookeeper原理/#zookeeper入门" class="headerlink" title="zookeeper入门"></a>zookeeper入门</h1><h2 id="zookeeper简介"><a href="/2017/04/08/zookeeper原理/#zookeeper简介" class="headerlink" title="zookeeper简介"></a>zookeeper简介</h2><p>ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户  </p>
<h3 id="Zookpeeper的基本架构"><a href="/2017/04/08/zookeeper原理/#Zookpeeper的基本架构" class="headerlink" title="Zookpeeper的基本架构"></a>Zookpeeper的基本架构</h3><p><img src="https://clyhs.github.io/images/zookeeper/zookeeper01.jpg" alt="img"></p>
<h3 id="Zookeeper数据模型"><a href="/2017/04/08/zookeeper原理/#Zookeeper数据模型" class="headerlink" title="Zookeeper数据模型"></a>Zookeeper数据模型</h3><p>ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每个ZNode都可以通过其路径唯一标识，比如上图中第三层的第一个ZNode, 它的路径是/app1/c1。在每个ZNode上可存储少量数据。如图：</p>
<p><img src="https://clyhs.github.io/images/zookeeper/zookeeper-tree.jpg" width="400px"></p>
<h3 id="Zookeeper-特点"><a href="/2017/04/08/zookeeper原理/#Zookeeper-特点" class="headerlink" title="Zookeeper 特点"></a>Zookeeper 特点</h3><ul>
<li>顺序一致性：按照客户端发送请求的顺序更新数据。</li>
<li>原子性：更新要么成功，要么失败，不会出现部分更新。</li>
<li>单一性 ：无论客户端连接哪个server，都会看到同一个视图。</li>
<li>可靠性：一旦数据更新成功，将一直保持，直到新的更新。</li>
<li>及时性：客户端会在一个确定的时间内得到最新的数据。</li>
</ul>
<h3 id="ZooKeeper典型应用场景"><a href="/2017/04/08/zookeeper原理/#ZooKeeper典型应用场景" class="headerlink" title="ZooKeeper典型应用场景"></a>ZooKeeper典型应用场景</h3><ul>
<li><p>数据发布与订阅 （我的业务用到这个特性，后面会有详细介绍）<br>应用配置集中到节点上，应用启动时主动获取，并在节点上注册一个watcher，每次配置更新都会通知到应用。</p>
</li>
<li><p>名空间服务<br>分布式命名服务，创建一个节点后，节点的路径就是全局唯一的，可以作为全局名称使用。</p>
</li>
<li><p>分布式通知/协调<br>不同的系统都监听同一个节点，一旦有了更新，另一个系统能够收到通知。</p>
</li>
<li><p>分布式锁<br>Zookeeper能保证数据的强一致性，用户任何时候都可以相信集群中每个节点的数据都是相同的。一个用户创建一个节点作为锁，另一个用户检测该节点，如果存在，代表别的用户已经锁住，如果不存在，则可以创建一个节点，代表拥有一个锁。</p>
</li>
<li><p>集群管理<br>每个加入集群的机器都创建一个节点，写入自己的状态。监控父节点的用户会受到通知，进行相应的处理。离开时删除节点，监控父节点的用户同样会收到通知。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>全栈技术图谱</title>
    <url>/2019/07/15/%E5%85%A8%E6%A0%88%E6%8A%80%E6%9C%AF%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<h3 id="全栈技术图谱"><a href="/2019/07/15/全栈技术图谱/#全栈技术图谱" class="headerlink" title="全栈技术图谱"></a>全栈技术图谱</h3><p><img src="https://clyhs.github.io/images/java/all.png" alt="img"></p>
]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>全栈</tag>
      </tags>
  </entry>
  <entry>
    <title>laravel5.4集成dingoapi的转化器(Transformer)</title>
    <url>/2017/10/01/laravel5-4%E9%9B%86%E6%88%90dingoapi%E7%9A%84%E8%BD%AC%E5%8C%96%E5%99%A8-Transformer/</url>
    <content><![CDATA[<h3 id="dingo-api响应"><a href="/2017/10/01/laravel5-4集成dingoapi的转化器-Transformer/#dingo-api响应" class="headerlink" title="dingo/api响应"></a>dingo/api响应</h3><p>我们可以自定义一个控制器继承系统的Controller控制器，并在我们自定义的控制器里引入命名空间，我们后续创建的控制器都继承自我们自定义的这一个基控制器<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">php artisan make:controller Api/V1/BaseController</span><br></pre></td></tr></table></figure></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Api</span>\<span class="title">V1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Dingo</span>\<span class="title">Api</span>\<span class="title">Routing</span>\<span class="title">Helpers</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Requests</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">use</span> <span class="title">Helpers</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dingo-api转化器"><a href="/2017/10/01/laravel5-4集成dingoapi的转化器-Transformer/#dingo-api转化器" class="headerlink" title="dingo/api转化器"></a>dingo/api转化器</h3><p>有些时候我们需要返回用户数据，在web端开发我们可以直接传递一个对象，但在api开发中则是需要把对象转化为标准的json格式响应给客户端。其实我们也可以自己根据对象的属性拼接一个数组，并响应给客户端，但是dingo/api给我们提供了更便捷的方式，也就是转化器(Transformer)。</p>
<p>自定义转化器需要继承TransformerAbstract类，并至少实现transform方法。例如下面是一个User模型的转化：<br>在App\Http\Controllers目录下手动新建Transformers<br>还有UserTransformer.php，代码如下<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Transformers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">User</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Requests</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">League</span>\<span class="title">Fractal</span>\<span class="title">TransformerAbstract</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserTransformer</span> <span class="keyword">extends</span> <span class="title">TransformerAbstract</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">transform</span><span class="params">(User $user)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">'id'</span> =&gt; $user-&gt;id,</span><br><span class="line">            <span class="string">'name'</span> =&gt; $user-&gt;name,</span><br><span class="line">            <span class="string">'email'</span> =&gt; $user-&gt;email,</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>编写UserApiController.php</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Api</span>\<span class="title">V1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">User</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Transformers</span>\<span class="title">UserTransformer</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserApiController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span><span class="params">($id)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $user = User::findOrFail($id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;item($user, <span class="keyword">new</span> UserTransformer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改routers/api.php</strong><br>添加：<strong>$api-&gt;get(‘user2/{id}’, ‘UserApiController@getUserInfo’);</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$api-&gt;version(<span class="string">'v1'</span>, [<span class="string">'namespace'</span> =&gt; <span class="string">'App\Http\Controllers\Api\V1'</span>], <span class="function"><span class="keyword">function</span> <span class="params">($api)</span> </span>&#123;</span><br><span class="line">    $api-&gt;get(<span class="string">'user/&#123;id&#125;'</span>, <span class="string">'UserController@show'</span>);</span><br><span class="line">    $api-&gt;get(<span class="string">'user'</span>, <span class="string">'UserController@index'</span>);</span><br><span class="line">    $api-&gt;get(<span class="string">'user2/&#123;id&#125;'</span>, <span class="string">'UserApiController@getUserInfo'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>laravel</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
        <tag>dingoapi</tag>
      </tags>
  </entry>
  <entry>
    <title>了解java的RMI</title>
    <url>/2017/04/10/%E4%BA%86%E8%A7%A3java%E7%9A%84RMI/</url>
    <content><![CDATA[<h1 id="java-RMI"><a href="/2017/04/10/了解java的RMI/#java-RMI" class="headerlink" title="java RMI"></a>java RMI</h1><p>Java RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java 虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法。</p>
<h2 id="Java-RMI概念"><a href="/2017/04/10/了解java的RMI/#Java-RMI概念" class="headerlink" title="Java RMI概念"></a>Java RMI概念</h2><p>在Java中，只要一个类继承了<code>java.rmi.Remote</code>接口，即可成为存在于服务器端的远程对象，供客户端访问并提供一定的服务。JavaDoc描述：Remote 接口用于标识其方法可以从非本地虚拟机上调用的接口。任何远程对象都必须直接或间接实现此接口。只有在“远程接口”（扩展 <code>java.rmi.Remote</code> 的接口）中指定的这些方法才可远程使用。</p>
<h3 id="编写一个RMI的步骤"><a href="/2017/04/10/了解java的RMI/#编写一个RMI的步骤" class="headerlink" title="编写一个RMI的步骤"></a>编写一个RMI的步骤</h3><ol>
<li>定义一个远程接口，此接口需要继承Remote</li>
<li>开发远程接口的实现类</li>
<li>创建一个server并把远程对象注册到端口</li>
<li>创建一个client查找远程对象，调用远程方法</li>
</ol>
<p>####一个Hello Word的远程调用实例<br>定义一个远程接口</p>
<p>编写RMI应用的第一步就是先定义远程接口。远程接口必须继承<code>java.rmi.Remote</code>接口，并且声明自己的远程方法。为了处理远程方法发生的各种异常，每一个远程方法必须抛出一个<code>java.rmi.RemoteException</code>异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RemoteHelloWord</span> <span class="keyword">extends</span> <span class="title">Remote</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个远程接口只定义了一个远程方法 sayHello()，远程方法在调用的时候有可能失败比如发生网络问题或者server挂掉，此时远程方法会抛出RemoteException异常。<br>开发接口的实现类</p>
<p>开发接口的实现类，即具体的远程对象，在远程对象中实现远程接口中定义的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteHelloWordImpl</span>  <span class="keyword">implements</span> <span class="title">RemoteHelloWord</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Word!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个Server并把对象注册到端口</p>
<p>在server端只需要做两件事：</p>
<ol>
<li>创建并导出远程对象</li>
<li>用Java RMI registry 注册远程对象</li>
</ol>
<p>下面是一个server端的程序：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIServer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RemoteHelloWord hello=<span class="keyword">new</span> RemoteHelloWordImpl();</span><br><span class="line">        RemoteHelloWord stub=(RemoteHelloWord)UnicastRemoteObject.exportObject(hello, <span class="number">9999</span>);</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Registry registry=LocateRegistry.getRegistry();</span><br><span class="line">        registry.bind(<span class="string">"helloword"</span>, stub);</span><br><span class="line">        System.out.println(<span class="string">"绑定成功!"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AlreadyBoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建一个client查找远程对象，调用远程方法<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">              Registry registry = LocateRegistry.getRegistry(<span class="string">"localhost"</span>);</span><br><span class="line">              RemoteHelloWord hello = (RemoteHelloWord) registry.lookup( <span class="string">"helloword"</span>);</span><br><span class="line">              String ret = hello.sayHello();</span><br><span class="line">              System. out.println( ret);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotBoundException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>启动server，然后在启动client，控制台打印：<br><code>Hello Word!</code></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat ssl</title>
    <url>/2017/08/11/tomcat%20ssl/</url>
    <content><![CDATA[<h2 id="tomcat-ssl"><a href="/2017/08/11/tomcat ssl/#tomcat-ssl" class="headerlink" title="tomcat ssl"></a>tomcat ssl</h2><p>https分为单项认证和双向认证。</p>
<p>一般https页面上的访问都是单项认证，服务端发送数字证书给客户端，客户单方面验证。而服务端不做验证。</p>
<p>而双向认证，需要双方都有证书，然后发送给对方进行验证。一般用于企业应用对接。</p>
<p>1、<strong>单项认证</strong></p>
<p>服务端创建密钥对及密钥库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -genkey -alias tomcat -keypass 123456 -keyalg RSA -keysize 2048 -validity 365 -storetype JKS -keystore D:/ssl/keystore.jks -storepass 123456</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/java/ssl1.png" alt="img"></p>
<p>看一下密钥库里的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -list -v -keystore D:/ssl/keystore.jks</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/java/ssl2.png" alt="img"></p>
<ul>
<li>tomcat7</li>
</ul>
<p>conf/server.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;</span><br><span class="line">               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;</span><br><span class="line">               keystoreFile=&quot;D:/ssl/keystore.jks&quot;</span><br><span class="line">               keystorePass=&quot;123456&quot;</span><br><span class="line">               truststoreFile=&quot;D:/ssl/keystore.jks&quot;</span><br><span class="line">               truststorePass=&quot;123456&quot;</span><br><span class="line">               clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>注意：clientAuth=”false”，这个参数值如果为true为双向认证，false为单项认证，我们用false。</p>
<ul>
<li>tomcat8.5</li>
</ul>
<p>conf/server.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span><br><span class="line">           maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot;&gt;</span><br><span class="line">		&lt;SSLHostConfig&gt;</span><br><span class="line">			&lt;Certificate certificateKeystoreFile=&quot;d:/ssl/keystore.jks&quot;</span><br><span class="line">		   certificateKeystorePassword=&quot;123456&quot;</span><br><span class="line">						 type=&quot;RSA&quot; /&gt;</span><br><span class="line">		&lt;/SSLHostConfig&gt;</span><br><span class="line">	&lt;/Connector&gt;</span><br></pre></td></tr></table></figure>
<p>2、<strong>双向认证：</strong></p>
<p>我们上边生成了服务端证书，并发送给客户端进行了验证。</p>
<p>(1)为方便导入浏览器，生成p12格式的密钥库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -genkey -alias client -keypass 123456 -keyalg RSA -keysize 2048 -validity 365 -storetype PKCS12 -keystore D:/ssl/client.p12 -storepass 123456</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/java/ssl3.png" alt="img"></p>
<p>(3)然后可以看一下证书库里的密钥对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -list -v -storetype PKCS12 -keystore D:/ssl/client.p12</span><br></pre></td></tr></table></figure>
<p>(4)导出客户端证书。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -export -alias client -keystore D:/ssl/client.p12 -storetype PKCS12 -keypass 123456 -file D:/ssl/client.cer</span><br></pre></td></tr></table></figure>
<p>(5)把客户端证书添加到服务端的密钥库中并添加信任。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -import -alias client -v -file D:/ssl/client.cer -keystore D:/ssl/keystore.jks -storepass 123456</span><br></pre></td></tr></table></figure>
<p>(6)然后把客户端的密钥库client.p12导入到浏览器的证书管理中，放到个人下。【重要】如果你不导入这个文件是访问不到的。</p>
<p><img src="https://clyhs.github.io/images/java/ssl4.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/java/ssl5.png" alt="img"></p>
<p><img src="https://clyhs.github.io/images/java/ssl6.png" alt="img"></p>
<ul>
<li><p>tomcat7</p>
<p>将tomcat的server.xml中https配置参数clientAuth=”false”改成true，双向认证。不然还是单向认证的，没有意义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;</span><br><span class="line">               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;</span><br><span class="line">               keystoreFile=&quot;D:/ssl/keystore.jks&quot;</span><br><span class="line">               keystorePass=&quot;123456&quot;</span><br><span class="line">               truststoreFile=&quot;D:/ssl/keystore.jks&quot;</span><br><span class="line">               truststorePass=&quot;123456&quot;</span><br><span class="line">               clientAuth=&quot;true&quot; sslProtocol=&quot;TLS&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>3、<strong>模拟CA实现对服务器证书的认证</strong></p>
<p>CA认证，是这个机构的根证书已经存在于浏览器中的【受信任的根证书颁发机构】，浏览器信任他，所以不会出现该证书不安全的提示。</p>
<p>（1）首先服务端需要生成一个带证书及主体信息的签名申请文件csr格式，CA需要用来制作签名证书。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -certreq -keyalg RSA -alias tomcat -sigalg SHA256withRSA -keystore D:/ssl/keystore.jks -file D:/ssl/serverreq.csr</span><br></pre></td></tr></table></figure>
<p>（2）CA也是有自己的密钥对和密钥库的，创建好。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -genkey -alias rootca -keypass 123456 -keyalg RSA -keysize 2048 -validity 365 -storetype JKS -keystore D:/ssl/castore.jks -storepass 123456</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/java/ssl7.png" alt="img"></p>
<p>（3）CA库有了，然后CA用自己的私钥对服务端申请签名文件中的证书进行签名操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -gencert -alias rootca -keystore D:/ssl/castore.jks -infile D:/ssl/serverreq.csr -outfile D:/ssl/signedserver.cer</span><br></pre></td></tr></table></figure>
<p>然后我们看一下，发布者是CA</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -printcert -file D:/ssl/signedserver.cer</span><br></pre></td></tr></table></figure>
<p><img src="https://clyhs.github.io/images/java/ssl8.png" alt="img"></p>
<p>（4）我们将CA库的证书导出来，这就是上边这个signedserver.cer的根证书。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -export -alias rootca -keystore D:/ssl/castore.jks -storetype JKS -keypass 123456 -file D:/ssl/rootca.cer</span><br></pre></td></tr></table></figure>
<p>（5）服务端导入根证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -import -v -alias rootca -file D:/ssl/rootca.cer  -keystore D:/ssl/keystore.jks</span><br></pre></td></tr></table></figure>
<p>（6）服务端导入签名证书覆盖原证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -import -v -alias tomcat -file D:/ssl/signedserver.cer  -keystore D:/ssl/keystore.jks</span><br></pre></td></tr></table></figure>
<p>（7）来看一下服务端的库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -list -v -keystore D:/ssl/keystore.jks</span><br></pre></td></tr></table></figure>
<p>这里边一共有三条信息：</p>
<p>　　（1）rootca证书信息</p>
<p>　　（2）刚刚导入的覆盖的别名叫tomcat的签名证书</p>
<p>　　（3）上一篇做的双向认证导入的客户端证书。</p>
<p>（7）把根证书rootca.cer发送给客户端，安装到浏览器中的【受信任的根证书颁发机构】。</p>
<p>4、<strong>模拟的CA密钥库对客户端证书也进行签名颁发</strong></p>
<p>一个客户端和服务端对接就需要把这个客户端的证书拿来导入到服务端的密钥库中。那么很多客户端要对接，就要多次导入。</p>
<p>可以这样，让客户端发送证书的csr文件给我们，我们用模拟的CA密钥库对客户端证书也进行签名颁发。</p>
<p>然后把签名后的证书发送给他，让他自己导入到自己的客户端密钥库里【也需要先导入根证书，再导入签名证书】。</p>
<p>这样的话https交互时，</p>
<p>服务端发送签名证书给客户端：客户端能用安装在浏览器中的【受信任的颁发机构】中的rootca.cer根证书进行验证。</p>
<p>客户端发送签名证书给服务端：服务端也能用信任的库里的rootca根证书对客户端发来签名证书进行校验。</p>
<p>为了清晰点，从头开始做，就不展示图片了。</p>
<p><strong>服务端：</strong></p>
<p>1.创建CA库，用于对证书签名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -genkey -alias rootca -keypass 123456 -keyalg RSA -keysize 2048 -validity 365 -storetype JKS -keystore D:/ssl/castore.jks -storepass 123456</span><br></pre></td></tr></table></figure>
<p>2.创建服务端密钥库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -genkey -alias tomcat -keypass 123456 -keyalg RSA -keysize 2048 -validity 365 -storetype JKS -keystore D:/ssl/keystore.jks -storepass 123456 -ext san=ip:127.0.0.1,dns:localhost</span><br></pre></td></tr></table></figure>
<p>3.创建服务端证书签名请求文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -certreq -keyalg RSA -alias tomcat -sigalg SHA256withRSA -keystore D:/ssl/keystore.jks -file D:/ssl/serverreq.csr</span><br></pre></td></tr></table></figure>
<p>4.CA库对服务端证书进行签名，生成一个证书文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -gencert -alias rootca -keystore D:/ssl/castore.jks -infile D:/ssl/serverreq.csr -outfile D:/ssl/signedserver.cer</span><br></pre></td></tr></table></figure>
<p>5.从CA库导出rootca根证书</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -export -alias rootca -keystore D:/ssl/castore.jks -storetype JKS -keypass 123456 -file D:/ssl/rootca.cer</span><br></pre></td></tr></table></figure>
<p>6.将rootca导入到服务端密钥库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -import -v -alias rootca -file D:/ssl/rootca.cer  -keystore D:/ssl/keystore.jks</span><br></pre></td></tr></table></figure>
<p>7.将服务端签名证书导入到服务端的密钥库，覆盖原证书。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -import -v -alias tomcat -file D:/ssl/signedserver.cer  -keystore D:/ssl/keystore.jks</span><br></pre></td></tr></table></figure>
<p>8.tomcat的server.xml添加配置【clientAutl=true，双向认证】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;</span><br><span class="line">               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;</span><br><span class="line">               keystoreFile=&quot;D:/ssl/keystore.jks&quot;</span><br><span class="line">               keystorePass=&quot;123456&quot;</span><br><span class="line">               truststoreFile=&quot;D:/ssl/keystore.jks&quot;</span><br><span class="line">               truststorePass=&quot;123456&quot;</span><br><span class="line">               clientAuth=&quot;true&quot; sslProtocol=&quot;TLS&quot; sslEnabledProtocols=&quot;TLSv1,TLSv1.1,TLSv1.2&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p><strong>客户端：</strong></p>
<p>1.创建客户端密钥库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -genkey -alias client -keypass 123456 -keyalg RSA -keysize 2048 -validity 365 -storetype JKS -keystore D:/ssl/client.jks -storepass 123456 -ext san=ip:127.0.0.1</span><br></pre></td></tr></table></figure>
<p>2.创建客户端证书签名请求文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -certreq -keyalg RSA -alias client -sigalg SHA256withRSA -keystore D:/ssl/client.jks -file D:/ssl/clientreq.csr</span><br></pre></td></tr></table></figure>
<p>3.把客户端证书签名请求文件clientreq.csr发送给服务端，服务端的模拟CA密钥库对证书进行签名，生成一个证书文件<strong>【以下这条是服务端执行】</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -gencert -alias rootca -keystore D:/ssl/castore.jks -infile D:/ssl/clientreq.csr -outfile D:/ssl/signedclient.cer</span><br></pre></td></tr></table></figure>
<p>4.服务端把生成的客户端签名文件signedclient.cer和根证书rootca.cer发送给客户，客户端导入密钥库。还是先导入根证书，再导入签名证书。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -import -v -alias rootca -file D:/ssl/rootca.cer  -keystore D:/ssl/client.jks</span><br><span class="line">keytool -import -v -alias client -file D:/ssl/signedclient.cer  -keystore D:/ssl/client.jks</span><br></pre></td></tr></table></figure>
<p>5.浏览器不支持jks，所以把客户端的jks库转为p12格式库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore D:/ssl/client.jks -srcstoretype JKS -deststoretype PKCS12 -destkeystore D:/ssl/client.p12</span><br></pre></td></tr></table></figure>
<p>6.将客户端密钥库client.p12导入到浏览器-证书-个人</p>
<p>7.将rootca.cer导入到浏览器-证书-受信任的证书颁发机构</p>
<p>启动tomcat，访问成功</p>
]]></content>
      <categories>
        <category>ssl</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>悲观锁与乐观锁</title>
    <url>/2017/06/01/%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/</url>
    <content><![CDATA[<h1 id="悲观锁"><a href="/2017/06/01/悲观锁与乐观锁/#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<h2 id="实现方式："><a href="/2017/06/01/悲观锁与乐观锁/#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h2><p>大多在数据库层面实现加锁操作，JDBC方式：在JDBC中使用悲观锁，需要使用select for update语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> * <span class="keyword">from</span> <span class="keyword">Account</span> </span><br><span class="line"><span class="keyword">where</span> ...(<span class="keyword">where</span> condition).. <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>
<h1 id="乐观锁"><a href="/2017/06/01/悲观锁与乐观锁/#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>
<h2 id="实现方式：-1"><a href="/2017/06/01/悲观锁与乐观锁/#实现方式：-1" class="headerlink" title="实现方式："></a>实现方式：</h2><p>大多是基于数据版本（Version）记录机制实现，何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。</p>
<p>读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Update</span> <span class="keyword">Account</span> <span class="keyword">set</span> <span class="keyword">version</span> = <span class="keyword">version</span>+<span class="number">1.</span>....(another <span class="keyword">field</span>) </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">version</span> =?...(another contidition)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>在docker环境下安装部署zabbix</title>
    <url>/2017/10/27/%E5%9C%A8docker%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2zabbix/</url>
    <content><![CDATA[<h3 id="安装MYSQL"><a href="/2017/10/27/在docker环境下安装部署zabbix/#安装MYSQL" class="headerlink" title="安装MYSQL"></a>安装MYSQL</h3><p>此步略</p>
<h3 id="安装zabbix-zabbix-server-mysql"><a href="/2017/10/27/在docker环境下安装部署zabbix/#安装zabbix-zabbix-server-mysql" class="headerlink" title="安装zabbix/zabbix-server-mysql"></a>安装zabbix/zabbix-server-mysql</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> docker pull zabbix/zabbix-server-mysql</span><br><span class="line"><span class="meta">#</span> docker run --name some-zabbix-server-mysql  -p 10051:10051 --net=host -e DB_SERVER_HOST="192.168.0.16" -e DB_SERVER_PORT=3306 -e MYSQL_USER="root" -e MYSQL_PASSWORD="123456" -d zabbix/zabbix-server-mysql</span><br></pre></td></tr></table></figure>
<h3 id="安装zabbix-zabbix-web-apache-mysql"><a href="/2017/10/27/在docker环境下安装部署zabbix/#安装zabbix-zabbix-web-apache-mysql" class="headerlink" title="安装zabbix/zabbix-web-apache-mysql"></a>安装zabbix/zabbix-web-apache-mysql</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> docker pull zabbix/zabbix-web-apache-mysql</span><br><span class="line"><span class="meta">#</span> docker run --name some-zabbix-web-apache-mysql -p 8188:80  -e DB_SERVER_HOST="192.168.0.16" -e DB_SERVER_PORT=3306 -e MYSQL_USER="root" -e MYSQL_PASSWORD="123456" -e ZBX_SERVER_HOST="192.168.0.16" -e TZ="Asia/Shanghai" -d zabbix/zabbix-web-apache-mysql</span><br></pre></td></tr></table></figure>
<h3 id="安装zabbix-zabbix-agent"><a href="/2017/10/27/在docker环境下安装部署zabbix/#安装zabbix-zabbix-agent" class="headerlink" title="安装zabbix/zabbix-agent"></a>安装zabbix/zabbix-agent</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> docker pull zabbix/zabbix-agent</span><br><span class="line"><span class="meta">#</span> docker run --name some-zabbix-agent -p 10050:10050 -e ZBX_HOSTNAME="192.168.0.16" -e ZBX_SERVER_HOST="192.168.0.16" -e ZBX_SERVER_PORT=10051 -d zabbix/zabbix-agent</span><br></pre></td></tr></table></figure>
<h3 id="访问WEB"><a href="/2017/10/27/在docker环境下安装部署zabbix/#访问WEB" class="headerlink" title="访问WEB"></a>访问WEB</h3><p>帐号密码：Admin/zabbix<br>地址：<a href="http://192.168.0.16:8188" target="_blank" rel="noopener">http://192.168.0.16:8188</a><br><img src="https://clyhs.github.io/images/zabbix/zabbix01.png" alt="img"></p>
<h3 id="配置"><a href="/2017/10/27/在docker环境下安装部署zabbix/#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="https://clyhs.github.io/images/zabbix/zabbix02.png" alt="img"><br><img src="https://clyhs.github.io/images/zabbix/zabbix03.png" alt="img"><br><img src="https://clyhs.github.io/images/zabbix/zabbix04.png" alt="img"></p>
]]></content>
      <categories>
        <category>zabbix</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>前端提高并发量的优化过程</title>
    <url>/2018/03/15/%E5%89%8D%E7%AB%AF%E6%8F%90%E9%AB%98%E5%B9%B6%E5%8F%91%E9%87%8F%E7%9A%84%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="优化步骤"><a href="/2018/03/15/前端提高并发量的优化过程/#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h3><ul>
<li>前端JS文件静态压缩</li>
<li>tomcat动态压缩传输</li>
<li>使用nginx做负载均衡</li>
<li>服务器优化sysctl.conf</li>
</ul>
<h4 id="前端JS文件静态压缩"><a href="/2018/03/15/前端提高并发量的优化过程/#前端JS文件静态压缩" class="headerlink" title="前端JS文件静态压缩"></a>前端JS文件静态压缩</h4><h5 id="gzip静态压缩"><a href="/2018/03/15/前端提高并发量的优化过程/#gzip静态压缩" class="headerlink" title="gzip静态压缩"></a>gzip静态压缩</h5><p>把js压缩成 xxx.js.gz然后改成xxx.gzjs<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># gzip jquery-1.7.1.js</span><br></pre></td></tr></table></figure></p>
<p>压缩后 jquery-1.7.1.js.gz 改名 jquery-1.7.1.gzjs</p>
<h5 id="在web应用里面增加过滤器"><a href="/2018/03/15/前端提高并发量的优化过程/#在web应用里面增加过滤器" class="headerlink" title="在web应用里面增加过滤器"></a>在web应用里面增加过滤器</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.pas.cloud.filters;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddHeaderFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">	Map headers = <span class="keyword">new</span> HashMap();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res,</span></span></span><br><span class="line"><span class="function"><span class="params">			FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(req <span class="keyword">instanceof</span> HttpServletRequest) &#123;</span><br><span class="line">			doFilter((HttpServletRequest)req, (HttpServletResponse)res, chain);</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			chain.doFilter(req, res);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(Iterator it = headers.entrySet().iterator();it.hasNext();) &#123;</span><br><span class="line">				Map.Entry entry = (Map.Entry)it.next();</span><br><span class="line">				response.addHeader((String)entry.getKey(),(String)entry.getValue());</span><br><span class="line">			&#125;</span><br><span class="line">			chain.doFilter(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		String headersStr = config.getInitParameter(<span class="string">"headers"</span>);</span><br><span class="line">		String[] headers = headersStr.split(<span class="string">","</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headers.length; i++) &#123;</span><br><span class="line">			String[] temp = headers[i].split(<span class="string">"="</span>);</span><br><span class="line">			<span class="keyword">this</span>.headers.put(temp[<span class="number">0</span>].trim(), temp[<span class="number">1</span>].trim());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在web应用的web-xml添加过滤器"><a href="/2018/03/15/前端提高并发量的优化过程/#在web应用的web-xml添加过滤器" class="headerlink" title="在web应用的web.xml添加过滤器"></a>在web应用的web.xml添加过滤器</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">	&lt;filter-name&gt;AddHeaderFilter&lt;/filter-name&gt;</span><br><span class="line">	&lt;filter-class&gt;</span><br><span class="line">		com.pas.cloud.filters.AddHeaderFilter</span><br><span class="line">	&lt;/filter-class&gt;</span><br><span class="line">	&lt;init-param&gt;</span><br><span class="line">		&lt;param-name&gt;headers&lt;/param-name&gt;</span><br><span class="line">		&lt;param-value&gt;Content-Encoding=gzip&lt;/param-value&gt;</span><br><span class="line">	&lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">	&lt;filter-name&gt;AddHeaderFilter&lt;/filter-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;*.gzjs&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure>
<h5 id="web应用的js引用改为"><a href="/2018/03/15/前端提高并发量的优化过程/#web应用的js引用改为" class="headerlink" title="web应用的js引用改为"></a>web应用的js引用改为</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/smart/lib/jquery-1.7.1.gzjs&quot;  charset=&apos;utf-8&apos;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="tomcat动态压缩传输"><a href="/2018/03/15/前端提高并发量的优化过程/#tomcat动态压缩传输" class="headerlink" title="tomcat动态压缩传输"></a>tomcat动态压缩传输</h4><p>server.xml如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;Server port=&quot;8175&quot; shutdown=&quot;SHUTDOWN&quot;&gt;</span><br><span class="line">  &lt;!-- Security listener. Documentation at /docs/config/listeners.html</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.security.SecurityListener&quot; /&gt;</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;!--APR library loader. Documentation at /docs/apr.html --&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.core.AprLifecycleListener&quot; SSLEngine=&quot;on&quot; /&gt;</span><br><span class="line">  &lt;!--Initialize Jasper prior to webapps are loaded. Documentation at /docs/jasper-howto.html --&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.core.JasperListener&quot; /&gt;</span><br><span class="line">  &lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot; /&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot; /&gt;</span><br><span class="line">  &lt;Listener className=&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- Global JNDI resources</span><br><span class="line">       Documentation at /docs/jndi-resources-howto.html</span><br><span class="line">  --&gt;</span><br><span class="line">  &lt;GlobalNamingResources&gt;</span><br><span class="line">    &lt;!-- Editable user database that can also be used by</span><br><span class="line">         UserDatabaseRealm to authenticate users</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;Resource name=&quot;UserDatabase&quot; auth=&quot;Container&quot;</span><br><span class="line">              type=&quot;org.apache.catalina.UserDatabase&quot;</span><br><span class="line">              description=&quot;User database that can be updated and saved&quot;</span><br><span class="line">              factory=&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span><br><span class="line">              pathname=&quot;conf/tomcat-users.xml&quot; /&gt;</span><br><span class="line">  &lt;/GlobalNamingResources&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- A &quot;Service&quot; is a collection of one or more &quot;Connectors&quot; that share</span><br><span class="line">       a single &quot;Container&quot; Note:  A &quot;Service&quot; is not itself a &quot;Container&quot;,</span><br><span class="line">       so you may not define subcomponents such as &quot;Valves&quot; at this level.</span><br><span class="line">       Documentation at /docs/config/service.html</span><br><span class="line">   --&gt;</span><br><span class="line">  &lt;Service name=&quot;Catalina&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--The connectors can use a shared executor, you can define one or more named thread pools--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    &lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot;</span><br><span class="line">        maxThreads=&quot;150&quot; minSpareThreads=&quot;4&quot;/&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">	&lt;Executor name=&quot;tomcatThreadPool&quot; namePrefix=&quot;catalina-exec-&quot; </span><br><span class="line">        maxThreads=&quot;1000&quot; maxIdleTime=&quot;60000&quot; </span><br><span class="line">        minSpareThreads=&quot;20&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- A &quot;Connector&quot; represents an endpoint by which requests are received</span><br><span class="line">         and responses are returned. Documentation at :</span><br><span class="line">         Java HTTP Connector: /docs/config/http.html (blocking &amp; non-blocking)</span><br><span class="line">         Java AJP  Connector: /docs/config/ajp.html</span><br><span class="line">         APR (HTTP/AJP) Connector: /docs/apr.html</span><br><span class="line">         Define a non-SSL HTTP/1.1 Connector on port 8080</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;Connector executor=&quot;tomcatThreadPool&quot; port=&quot;8170&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">               connectionTimeout=&quot;20000&quot;</span><br><span class="line">               compression=&quot;on&quot;  </span><br><span class="line">               compressionMinSize=&quot;2048&quot; </span><br><span class="line">               noCompressionUserAgents=&quot;gozilla, traviata&quot;  </span><br><span class="line">               compressableMimeType=&quot;text/html,application/xhtml+xml,application/xml,text/xml,text/javascript,text/css,text/plain,application/x-</span><br><span class="line">javascript,application/javascript,text/xhtml,text/json,application/json,application/x-www-form-urlencoded,text/javaScript&quot;  </span><br><span class="line">               useSendfile=&quot;false&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot; /&gt;</span><br><span class="line">    &lt;!-- A &quot;Connector&quot; using the shared thread pool--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    &lt;Connector executor=&quot;tomcatThreadPool&quot;</span><br><span class="line">               port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;</span><br><span class="line">               connectionTimeout=&quot;20000&quot;</span><br><span class="line">               redirectPort=&quot;8443&quot; /&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;!-- Define a SSL HTTP/1.1 Connector on port 8443</span><br><span class="line">         This connector uses the JSSE configuration, when using APR, the</span><br><span class="line">         connector should be using the OpenSSL style configuration</span><br><span class="line">         described in the APR documentation --&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    &lt;Connector port=&quot;8443&quot; protocol=&quot;HTTP/1.1&quot; SSLEnabled=&quot;true&quot;</span><br><span class="line">               maxThreads=&quot;150&quot; scheme=&quot;https&quot; secure=&quot;true&quot;</span><br><span class="line">               clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; /&gt;</span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Define an AJP 1.3 Connector on port 8009 --&gt;</span><br><span class="line">    &lt;Connector port=&quot;8179&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- An Engine represents the entry point (within Catalina) that processes</span><br><span class="line">         every request.  The Engine implementation for Tomcat stand alone</span><br><span class="line">         analyzes the HTTP headers included with the request, and passes them</span><br><span class="line">         on to the appropriate Host (virtual host).</span><br><span class="line">         Documentation at /docs/config/engine.html --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- You should set jvmRoute to support load-balancing via AJP ie :</span><br><span class="line">    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot; jvmRoute=&quot;jvm1&quot;&gt;</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--For clustering, please take a look at documentation at:</span><br><span class="line">          /docs/cluster-howto.html  (simple how to)</span><br><span class="line">          /docs/config/cluster.html (reference documentation) --&gt;</span><br><span class="line">      &lt;!--</span><br><span class="line">      &lt;Cluster className=&quot;org.apache.catalina.ha.tcp.SimpleTcpCluster&quot;/&gt;</span><br><span class="line">      --&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- Use the LockOutRealm to prevent attempts to guess user passwords</span><br><span class="line">           via a brute-force attack --&gt;</span><br><span class="line">      &lt;Realm className=&quot;org.apache.catalina.realm.LockOutRealm&quot;&gt;</span><br><span class="line">        &lt;!-- This Realm uses the UserDatabase configured in the global JNDI</span><br><span class="line">             resources under the key &quot;UserDatabase&quot;.  Any edits</span><br><span class="line">             that are performed against this UserDatabase are immediately</span><br><span class="line">             available for use by the Realm.  --&gt;</span><br><span class="line">        &lt;Realm className=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;</span><br><span class="line">               resourceName=&quot;UserDatabase&quot;/&gt;</span><br><span class="line">      &lt;/Realm&gt;</span><br><span class="line"></span><br><span class="line">      &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot;</span><br><span class="line">            unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- SingleSignOn valve, share authentication between web applications</span><br><span class="line">             Documentation at: /docs/config/valve.html --&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">        &lt;Valve className=&quot;org.apache.catalina.authenticator.SingleSignOn&quot; /&gt;</span><br><span class="line">        --&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- Access log processes all example.</span><br><span class="line">             Documentation at: /docs/config/valve.html</span><br><span class="line">             Note: The pattern used is equivalent to using pattern=&quot;common&quot; --&gt;</span><br><span class="line">        &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;logs&quot;</span><br><span class="line">               prefix=&quot;localhost_access_log.&quot; suffix=&quot;.txt&quot;</span><br><span class="line">               pattern=&quot;%h %l %u %t &amp;quot;%r&amp;quot; %s %b&quot; /&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/Host&gt;</span><br><span class="line">    &lt;/Engine&gt;</span><br><span class="line">  &lt;/Service&gt;</span><br><span class="line">&lt;/Server&gt;</span><br></pre></td></tr></table></figure>
<h4 id="使用nginx做负载均衡"><a href="/2018/03/15/前端提高并发量的优化过程/#使用nginx做负载均衡" class="headerlink" title="使用nginx做负载均衡"></a>使用nginx做负载均衡</h4><ul>
<li>nginx版本nginx-1.2.7.tar.gz</li>
<li>地址：<a href="http://nginx.org/download/nginx-1.2.7.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.2.7.tar.gz</a> </li>
</ul>
<h5 id="安装upstream-fair模块"><a href="/2018/03/15/前端提高并发量的优化过程/#安装upstream-fair模块" class="headerlink" title="安装upstream-fair模块"></a>安装upstream-fair模块</h5><ul>
<li>下载：upstream-fair </li>
<li>地址：<a href="http://wcoserver.googlecode.com/files/gnosek-nginx-upstream-fair-2131c73.tar.gz" target="_blank" rel="noopener">http://wcoserver.googlecode.com/files/gnosek-nginx-upstream-fair-2131c73.tar.gz</a></li>
<li>解压后重命名 mv gnosek-nginx-upstream-fair-2131c73 upstream (后面编译nginx要用到这个地址)</li>
</ul>
<h5 id="编译nginx"><a href="/2018/03/15/前端提高并发量的优化过程/#编译nginx" class="headerlink" title="编译nginx"></a>编译nginx</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span> cd nginx-1.2.7/</span><br><span class="line"><span class="meta">#</span> ./configure --prefix=/etc/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi --http-log-path=/var/log/nginx/access.log --http-proxy-temp-path=/var/lib/nginx/proxy --lock-path=/var/lock/nginx.lock --pid-path=/var/run/nginx.pid --with-debug --with-http_dav_module --with-http_flv_module --with-http_geoip_module --with-http_gzip_static_module --with-http_realip_module --with-http_stub_status_module --with-http_ssl_module --with-http_sub_module --with-ipv6 --with-mail --with-mail_ssl_module --add-module=/home/uname/upstream/</span><br><span class="line"><span class="meta">#</span> make</span><br><span class="line"><span class="meta">#</span> make install</span><br></pre></td></tr></table></figure>
<h5 id="配置nginx-conf"><a href="/2018/03/15/前端提高并发量的优化过程/#配置nginx-conf" class="headerlink" title="配置nginx.conf"></a>配置nginx.conf</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#user  nobody;</span><br><span class="line">worker_processes  8;</span><br><span class="line"></span><br><span class="line">#error_log  logs/error.log;</span><br><span class="line">#error_log  logs/error.log  notice;</span><br><span class="line">#error_log  logs/error.log  info;</span><br><span class="line"></span><br><span class="line">#pid        logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  2048;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs/access.log  main;</span><br><span class="line">    #client_header_buffer_size 1024K;</span><br><span class="line">    #large_client_header_buffers 4 1024K;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    proxy_connect_timeout   30; </span><br><span class="line">    proxy_send_timeout      30; </span><br><span class="line">    proxy_read_timeout      30; </span><br><span class="line">    proxy_buffer_size       16k; </span><br><span class="line">    proxy_buffers           4 64k; </span><br><span class="line">    proxy_busy_buffers_size 128k; </span><br><span class="line">    proxy_temp_file_write_size 128k;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    #keepalive_timeout  0;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    #gzip  on;</span><br><span class="line">    #</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_static on;  </span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    gzip_min_length 1400;</span><br><span class="line">    gzip_vary  on;</span><br><span class="line">    gzip_http_version 1.1;  </span><br><span class="line">    gzip_proxied expired no-cache no-store private auth;</span><br><span class="line">    gzip_types text/plain text/css text/xml text/javascript image/gif image/jpeg application/x-javascript application/xml;</span><br><span class="line">    gzip_disable &quot;MSIE [1-6]\.(?!.*SV1)&quot;;</span><br><span class="line">    #</span><br><span class="line">    client_max_body_size 8m;</span><br><span class="line">    client_body_buffer_size 512k;</span><br><span class="line">    #</span><br><span class="line">    upstream backend_tomcats &#123;</span><br><span class="line">        server 192.168.0.7:8170 max_fails=3 weight=3 fail_timeout=30s;</span><br><span class="line">        server 192.168.0.7:8270 max_fails=3 weight=1 fail_timeout=30s;</span><br><span class="line">        server 192.168.0.16:8170 max_fails=3 weight=3 fail_timeout=30s;</span><br><span class="line">        server 192.168.0.141:8170 max_fails=3 weight=2 fail_timeout=30s;</span><br><span class="line">        fair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        </span><br><span class="line">        #client_max_body_size 64m;</span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs/host.access.log  main;</span><br><span class="line">         </span><br><span class="line">        client_header_buffer_size 2m;</span><br><span class="line">        large_client_header_buffers 4 1m;        </span><br><span class="line"> </span><br><span class="line">        charset utf-8;</span><br><span class="line">        #</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://backend_tomcats;</span><br><span class="line">            proxy_set_header HOST $host:80;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Connection &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">        #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page /50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    proxy_pass   http://127.0.0.1;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span><br><span class="line">        #</span><br><span class="line">        #location ~ \.php$ &#123;</span><br><span class="line">        #    root           html;</span><br><span class="line">        #    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">        #    fastcgi_index  index.php;</span><br><span class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span><br><span class="line">        #    include        fastcgi_params;</span><br><span class="line">        #&#125;</span><br><span class="line"></span><br><span class="line">        # deny access to .htaccess files, if Apache&apos;s document root</span><br><span class="line">        # concurs with nginx&apos;s one</span><br><span class="line">        #</span><br><span class="line">        #location ~ /\.ht &#123;</span><br><span class="line">        #    deny  all;</span><br><span class="line">        #&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="服务器优化sysctl-conf"><a href="/2018/03/15/前端提高并发量的优化过程/#服务器优化sysctl-conf" class="headerlink" title="服务器优化sysctl.conf"></a>服务器优化sysctl.conf</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#关闭ipv6</span><br><span class="line"></span><br><span class="line">net.ipv6.conf.all.disable_ipv6 = 1</span><br><span class="line"></span><br><span class="line">net.ipv6.conf.default.disable_ipv6 = 1</span><br><span class="line"></span><br><span class="line"># 避免放大攻击</span><br><span class="line"></span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br><span class="line"></span><br><span class="line"># 开启恶意icmp错误消息保护</span><br><span class="line"></span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</span><br><span class="line"></span><br><span class="line">#关闭路由转发</span><br><span class="line"></span><br><span class="line">net.ipv4.ip_forward = 0</span><br><span class="line"></span><br><span class="line">net.ipv4.conf.all.send_redirects = 0</span><br><span class="line"></span><br><span class="line">net.ipv4.conf.default.send_redirects = 0</span><br><span class="line"></span><br><span class="line">#开启反向路径过滤</span><br><span class="line"></span><br><span class="line">net.ipv4.conf.all.rp_filter = 1</span><br><span class="line"></span><br><span class="line">net.ipv4.conf.default.rp_filter = 1</span><br><span class="line"></span><br><span class="line">#处理无源路由的包</span><br><span class="line"></span><br><span class="line">net.ipv4.conf.all.accept_source_route = 0</span><br><span class="line"></span><br><span class="line">net.ipv4.conf.default.accept_source_route = 0</span><br><span class="line"></span><br><span class="line">#关闭sysrq功能</span><br><span class="line"></span><br><span class="line">kernel.sysrq = 0</span><br><span class="line"></span><br><span class="line">#core文件名中添加pid作为扩展名</span><br><span class="line"></span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line"></span><br><span class="line"># 开启SYN洪水攻击保护</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"></span><br><span class="line">#修改消息队列长度</span><br><span class="line"></span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line"></span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line"></span><br><span class="line">#设置最大内存共享段大小bytes</span><br><span class="line"></span><br><span class="line">kernel.shmmax = 68719476736</span><br><span class="line"></span><br><span class="line">kernel.shmall = 4294967296</span><br><span class="line"></span><br><span class="line">#timewait的数量，默认180000</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 6000</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_sack = 1</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_window_scaling = 1</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_rmem = 4096        87380   4194304</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_wmem = 4096        16384   4194304</span><br><span class="line"></span><br><span class="line">net.core.wmem_default = 8388608</span><br><span class="line"></span><br><span class="line">net.core.rmem_default = 8388608</span><br><span class="line"></span><br><span class="line">net.core.rmem_max = 16777216</span><br><span class="line"></span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line"></span><br><span class="line">#每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目</span><br><span class="line"></span><br><span class="line">net.core.netdev_max_backlog = 262144</span><br><span class="line"></span><br><span class="line">#限制仅仅是为了防止简单的DoS 攻击</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_orphans = 3276800</span><br><span class="line"></span><br><span class="line">#未收到客户端确认信息的连接请求的最大值</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 262144</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br><span class="line"></span><br><span class="line">#内核放弃建立连接之前发送SYNACK 包的数量</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_synack_retries = 1</span><br><span class="line"></span><br><span class="line">#内核放弃建立连接之前发送SYN 包的数量</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_syn_retries = 1</span><br><span class="line"></span><br><span class="line">#启用timewait 快速回收</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line"></span><br><span class="line">#开启重用。允许将TIME-WAIT sockets 重新用于新的TCP 连接</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_mem = 94500000 915000000 927000000</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_fin_timeout = 1</span><br><span class="line"></span><br><span class="line">#当keepalive 起用的时候，TCP 发送keepalive 消息的频度。缺省是2 小时</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_keepalive_time = 30</span><br><span class="line"></span><br><span class="line">#允许系统打开的端口范围</span><br><span class="line"></span><br><span class="line">net.ipv4.ip_local_port_range = 1024    65000</span><br><span class="line"></span><br><span class="line">#修改防火墙表大小，默认65536</span><br><span class="line"></span><br><span class="line">#net.netfilter.nf_conntrack_max=655350</span><br><span class="line"></span><br><span class="line">#net.netfilter.nf_conntrack_tcp_timeout_established=1200</span><br><span class="line"></span><br><span class="line"># 确保无人能修改路由表</span><br><span class="line"></span><br><span class="line">net.ipv4.conf.all.accept_redirects = 0</span><br><span class="line"></span><br><span class="line">net.ipv4.conf.default.accept_redirects = 0</span><br><span class="line"></span><br><span class="line">net.ipv4.conf.all.secure_redirects = 0</span><br><span class="line"></span><br><span class="line">net.ipv4.conf.default.secure_redirects = 0</span><br></pre></td></tr></table></figure>
<p>执行sysctl -p使参数生效，永久生效。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建ELK实时日志分析系统</title>
    <url>/2017/05/08/%E6%90%AD%E5%BB%BAELK%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="什么是ELK"><a href="/2017/05/08/搭建ELK实时日志分析系统/#什么是ELK" class="headerlink" title="什么是ELK"></a>什么是ELK</h1><p>开源实时日志分析 ELK 由 ElasticSearch 、 Logstash 和 Kiabana 三个开源工具组成</p>
<ul>
<li><p>Elasticsearch 是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制， restful 风格接口，多数据源，自动搜索负载等。</p>
</li>
<li><p>Logstash 是一个完全开源的工具，他可以对你的日志进行收集、分析，并将其存储供以后使用（如，搜索）。</p>
</li>
<li><p>kibana 也是一个开源和免费的工具，他 Kibana 可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。</p>
</li>
</ul>
<h2 id="部署"><a href="/2017/05/08/搭建ELK实时日志分析系统/#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="服务器"><a href="/2017/05/08/搭建ELK实时日志分析系统/#服务器" class="headerlink" title="服务器"></a>服务器</h3><blockquote>
<p>IP: 192.168.0.16<br>jdk: 1.8<br>os: centos7 64<br>hostname: centoss1.pascloud.com</p>
</blockquote>
<p>安装包：</p>
<ol>
<li>elasticsearch-5.4.0.rpm</li>
<li>kibana-5.4.0-x86_64.rpm</li>
<li>logstash-5.4.0.rpm</li>
<li>filebeat-5.4.0-x86_64.rpm</li>
</ol>
<h3 id="安装elasticsearch"><a href="/2017/05/08/搭建ELK实时日志分析系统/#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> rpm -ivh elasticsearch-5.4.0.rpm</span><br></pre></td></tr></table></figure>
<p>修改 <em>/etc/elasticsearch/elasticsearch.yml</em><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> network.host: 192.168.0.16</span><br></pre></td></tr></table></figure></p>
<p>启动：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> sudo systemctl daemon-reload</span><br><span class="line"><span class="meta">$</span> sudo systemctl enable elasticsearch.service</span><br><span class="line"><span class="meta">$</span> sudo systemctl start elasticsearch.service</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> curl -X GET http://localhost:9200/</span><br></pre></td></tr></table></figure></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "name" : "XMfXZ3K",</span><br><span class="line">  "cluster_name" : "elasticsearch",</span><br><span class="line">  "cluster_uuid" : "xYql63WZTs6J2vOVukCLlQ",</span><br><span class="line">  "version" : &#123;</span><br><span class="line">    "number" : "5.4.0",</span><br><span class="line">    "build_hash" : "780f8c4",</span><br><span class="line">    "build_date" : "2017-04-28T17:43:27.229Z",</span><br><span class="line">    "build_snapshot" : false,</span><br><span class="line">    "lucene_version" : "6.5.0"</span><br><span class="line">  &#125;,</span><br><span class="line">  "tagline" : "You Know, for Search"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="安装kibana"><a href="/2017/05/08/搭建ELK实时日志分析系统/#安装kibana" class="headerlink" title="安装kibana"></a>安装kibana</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> rpm -ivh kibana-5.4.0-x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>修改/etc/kibana/kibana.xml<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> vi /etc/kibana/kibana.xml</span><br><span class="line"></span><br><span class="line">server.port: 5601</span><br><span class="line">server.host: "192.168.0.16"</span><br><span class="line">server.name: "centoss1.pascloud.com"</span><br><span class="line">elasticsearch.url: "http://localhost:9200"</span><br></pre></td></tr></table></figure></p>
<p>启动：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> systemctl start kibana</span><br><span class="line"><span class="meta">$</span> netstat -tunpl | grep 5601</span><br></pre></td></tr></table></figure></p>
<p>访问：<a href="http://192.168.0.16:5601" target="_blank" rel="noopener">http://192.168.0.16:5601</a></p>
<h3 id="安装logstash"><a href="/2017/05/08/搭建ELK实时日志分析系统/#安装logstash" class="headerlink" title="安装logstash"></a>安装logstash</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> rpm -ivh logstash-5.4.0.rpm</span><br></pre></td></tr></table></figure>
<p>生成SSL证书<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> cd /etc/pki/tls</span><br><span class="line"><span class="meta">$</span> openssl req -subj '/CN=centoss1.pascloud.com/' -x509 -days 3650 -batch -nodes -newkey rsa:2048 -keyout private/logstash-forwarder.key -out certs/logstash-forwarder.crt</span><br></pre></td></tr></table></figure></p>
<p>创建一个01-logstash-initial.conf 文件<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/logstash/conf.d/01-logstash-initial.conf &lt;&lt; EOF</span><br><span class="line">input &#123;</span><br><span class="line">  beats &#123;</span><br><span class="line">    port =&gt; 5044</span><br><span class="line">    ssl =&gt; true</span><br><span class="line">    type =&gt; "logs"</span><br><span class="line">    ssl_certificate =&gt; "/etc/pki/tls/certs/logstash-forwarder.crt"</span><br><span class="line">    ssl_key =&gt; "/etc/pki/tls/private/logstash-forwarder.key"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filter &#123;</span><br><span class="line">  if [type] == "syslog" &#123;</span><br><span class="line">    grok &#123;</span><br><span class="line">      match =&gt; &#123; "message" =&gt; "%&#123;SYSLOGTIMESTAMP:syslog_timestamp&#125; %&#123;SYSLOGHOST:syslog_hostname&#125; %&#123;DATA:syslog_program&#125;(?:\[%&#123;POSINT:syslog_pid&#125;\])?: %&#123;GREEDYDATA:syslog_message&#125;" &#125;</span><br><span class="line">      add_field =&gt; [ "received_at", "%&#123;@timestamp&#125;" ]</span><br><span class="line">      add_field =&gt; [ "received_from", "%&#123;host&#125;" ]</span><br><span class="line">    &#125;</span><br><span class="line">    syslog_pri &#123; &#125;</span><br><span class="line">    date &#123;</span><br><span class="line">      match =&gt; [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  elasticsearch &#123; hosts =&gt; ["192.168.0.16:9200"] &#125;</span><br><span class="line">  stdout &#123; codec =&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p>
<p>验证：<em>01-logstash-initial.conf </em><br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> /usr/share/logstash/bin/logstash -f /etc/logstash/conf.d/01-logstash-initial.conf</span><br></pre></td></tr></table></figure></p>
<p>启动：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> systemctl start logstash</span><br><span class="line"><span class="meta">$</span> netstat -tunpl | grep 5044</span><br></pre></td></tr></table></figure></p>
<h3 id="安装收集日志客户端：filebeat"><a href="/2017/05/08/搭建ELK实时日志分析系统/#安装收集日志客户端：filebeat" class="headerlink" title="安装收集日志客户端：filebeat"></a>安装收集日志客户端：filebeat</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> rpm -ivh filebeat-5.4.0-x86_64.rpm</span><br></pre></td></tr></table></figure>
<p>修改 /etc/filebeat/filebate.yml<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- input_type: log</span><br><span class="line"><span class="meta">  #</span> Paths that should be crawled and fetched. Glob based paths.</span><br><span class="line">  paths:</span><br><span class="line">    ＃新增 指定到需要的日志文件</span><br><span class="line">    - /usr/logs/stdout.log</span><br><span class="line">    - /var/log/*.log</span><br><span class="line"></span><br><span class="line">output.elasticsearch:</span><br><span class="line"><span class="meta">  #</span> Array of hosts to connect to.</span><br><span class="line">  hosts: ["192.168.0.16:9200"]</span><br><span class="line">  </span><br><span class="line">output.logstash:</span><br><span class="line"><span class="meta">  #</span> The Logstash hosts</span><br><span class="line">  hosts: ["centoss1.pascloud.com:5044"]</span><br><span class="line">  ssl.certificate_authorities: ["/etc/pki/tls/certs/logstash-forwarder.crt"]</span><br></pre></td></tr></table></figure></p>
<p>启动：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> systemctl start filebeat</span><br></pre></td></tr></table></figure></p>
<p>访问<a href="http://192.168.0.16:5601" target="_blank" rel="noopener">http://192.168.0.16:5601</a><br><img src="https://clyhs.github.io/images/elk/elk01.png" alt="img"></p>
]]></content>
      <categories>
        <category>elk</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>elasticseach</tag>
      </tags>
  </entry>
  <entry>
    <title>简单了解RPC</title>
    <url>/2017/04/10/%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3RPC/</url>
    <content><![CDATA[<h1 id="RPC"><a href="/2017/04/10/简单了解RPC/#RPC" class="headerlink" title="RPC"></a>RPC</h1><p>RPC，全称为Remote Procedure Call，即远程过程调用，它是一个计算机通信协议。它允许像调用本地服务一样调用远程服务。它可以有不同的实现方式。如RMI(远程方法调用)、Hessian、Http invoker等。另外，RPC是与语言无关的<br><img src="https://clyhs.github.io/images/java/rpc01.png" alt="img"><br>如上图所示，假设Computer1在调用sayHi()方法，对于Computer1而言调用sayHi()方法就像调用本地方法一样，调用 –&gt;返回。但从后续调用可以看出Computer1调用的是Computer2中的sayHi()方法，RPC屏蔽了底层的实现细节，让调用者无需关注网络通信，数据传输等细节。</p>
<h2 id="RPC框架的实现"><a href="/2017/04/10/简单了解RPC/#RPC框架的实现" class="headerlink" title="RPC框架的实现"></a>RPC框架的实现</h2><p>上面介绍了RPC的核心原理：RPC能够让本地应用简单、高效地调用服务器中的过程（服务）。它主要应用在分布式系统。如Hadoop中的IPC组件。但怎样实现一个RPC框架呢？</p>
<p>从下面几个方面思考，仅供参考：</p>
<ol>
<li><p>通信模型：假设通信的为A机器与B机器，A与B之间有通信模型，在Java中一般基于BIO或NIO；。</p>
</li>
<li><p>过程（服务）定位：使用给定的通信方式，与确定IP与端口及方法名称确定具体的过程或方法；</p>
</li>
<li><p>远程代理对象：本地调用的方法(服务)其实是远程方法的本地代理，因此可能需要一个远程代理对象，对于Java而言，远程代理对象可以使用Java的动态对象实现，封装了调用远程方法调用；</p>
</li>
<li><p>序列化，将对象名称、方法名称、参数等对象信息进行网络传输需要转换成二进制传输，这里可能需要不同的序列化技术方案。如:protobuf，Arvo等。</p>
</li>
</ol>
<h3 id="Java实现RPC框架"><a href="/2017/04/10/简单了解RPC/#Java实现RPC框架" class="headerlink" title="Java实现RPC框架"></a>Java实现RPC框架</h3><h4 id="1-实现技术方案"><a href="/2017/04/10/简单了解RPC/#1-实现技术方案" class="headerlink" title="1.实现技术方案"></a>1.实现技术方案</h4><p>下面使用比较原始的方案实现RPC框架，采用Socket通信、动态代理与反射与Java原生的序列化。</p>
<h4 id="2-RPC框架架构"><a href="/2017/04/10/简单了解RPC/#2-RPC框架架构" class="headerlink" title="2.RPC框架架构"></a>2.RPC框架架构</h4><h4 id="3-RPC架构分为三部分："><a href="/2017/04/10/简单了解RPC/#3-RPC架构分为三部分：" class="headerlink" title="3.RPC架构分为三部分："></a>3.RPC架构分为三部分：</h4><p>1）服务提供者，运行在服务器端，提供服务接口定义与服务实现类。<br>2）服务中心，运行在服务器端，负责将本地服务发布成远程服务，管理远程服务，提供给服务消费者使用。<br>3）服务消费者，运行在客户端，通过远程代理对象调用远程服务。</p>
<p>####3.具体实现</p>
<p>服务提供者接口定义与实现，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHi</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHi</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hi, "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务中心代码实现，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class serviceInterface, Class impl)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务中心实现类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceCenter</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, Class&gt; serviceRegistry = <span class="keyword">new</span> HashMap&lt;String, Class&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isRunning = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServiceCenter</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isRunning = <span class="keyword">false</span>;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket();</span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">        System.out.println(<span class="string">"start server"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// 1.监听客户端的TCP连接，接到TCP连接后将其封装成task，由线程池执行</span></span><br><span class="line">                executor.execute(<span class="keyword">new</span> ServiceTask(server.accept()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            server.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Class serviceInterface, Class impl)</span> </span>&#123;</span><br><span class="line">        serviceRegistry.put(serviceInterface.getName(), impl);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isRunning;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Socket clent = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceTask</span><span class="params">(Socket client)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clent = client;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ObjectInputStream input = <span class="keyword">null</span>;</span><br><span class="line">            ObjectOutputStream output = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 2.将客户端发送的码流反序列化成对象，反射调用服务实现者，获取执行结果</span></span><br><span class="line">                input = <span class="keyword">new</span> ObjectInputStream(clent.getInputStream());</span><br><span class="line">                String serviceName = input.readUTF();</span><br><span class="line">                String methodName = input.readUTF();</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) input.readObject();</span><br><span class="line">                Object[] arguments = (Object[]) input.readObject();</span><br><span class="line">                Class serviceClass = serviceRegistry.get(serviceName);</span><br><span class="line">                <span class="keyword">if</span> (serviceClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(serviceName + <span class="string">" not found"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Method method = serviceClass.getMethod(methodName, parameterTypes);</span><br><span class="line">                Object result = method.invoke(serviceClass.newInstance(), arguments);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 3.将执行结果反序列化，通过socket发送给客户端</span></span><br><span class="line">                output = <span class="keyword">new</span> ObjectOutputStream(clent.getOutputStream());</span><br><span class="line">                output.writeObject(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (output != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        output.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (input != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        input.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (clent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        clent.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>客户端的远程代理对象：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCClient</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getRemoteProxyObj</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; serviceInterface, <span class="keyword">final</span> InetSocketAddress addr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.将本地的接口调用转换成JDK的动态代理，在动态代理中实现接口的远程调用</span></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(serviceInterface.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;serviceInterface&#125;,</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">                        ObjectOutputStream output = <span class="keyword">null</span>;</span><br><span class="line">                        ObjectInputStream input = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 2.创建Socket客户端，根据指定地址连接远程服务提供者</span></span><br><span class="line">                            socket = <span class="keyword">new</span> Socket();</span><br><span class="line">                            socket.connect(addr);</span><br><span class="line"> </span><br><span class="line">                            <span class="comment">// 3.将远程服务调用所需的接口类、方法名、参数列表等编码后发送给服务提供者</span></span><br><span class="line">                            output = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">                            output.writeUTF(serviceInterface.getName());</span><br><span class="line">                            output.writeUTF(method.getName());</span><br><span class="line">                            output.writeObject(method.getParameterTypes());</span><br><span class="line">                            output.writeObject(args);</span><br><span class="line"> </span><br><span class="line">                            <span class="comment">// 4.同步阻塞等待服务器返回应答，获取应答后返回</span></span><br><span class="line">                            input = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">                            <span class="keyword">return</span> input.readObject();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) socket.close();</span><br><span class="line">                            <span class="keyword">if</span> (output != <span class="keyword">null</span>) output.close();</span><br><span class="line">                            <span class="keyword">if</span> (input != <span class="keyword">null</span>) input.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCTest</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Server serviceServer = <span class="keyword">new</span> ServiceCenter(<span class="number">8088</span>);</span><br><span class="line">                    serviceServer.register(HelloService.class, HelloServiceImpl.class);</span><br><span class="line">                    serviceServer.start();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        HelloService service = RPCClient.getRemoteProxyObj(HelloService.class, <span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8088</span>));</span><br><span class="line">        System.out.println(service.sayHi(<span class="string">"test"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>###总结<br> RPC本质为消息处理模型，RPC屏蔽了底层不同主机间的通信细节，让进程调用远程的服务就像是本地的服务一样。</p>
<p>###可以改进的地方<br>这里实现的简单RPC框架是使用Java语言开发，与Java语言高度耦合，并且通信方式采用的Socket是基于BIO实现的，IO效率不高，还有Java原生的序列化机制占内存太多，运行效率也不高。可以考虑从下面几种方法改进。</p>
<ol>
<li>可以采用基于JSON数据传输的RPC框架；</li>
<li>可以使用NIO或直接使用Netty替代BIO实现；</li>
<li>使用开源的序列化机制，如Hadoop Avro与Google protobuf等；</li>
<li>服务注册可以使用Zookeeper进行管理，能够让应用更加稳定。</li>
</ol>
<p>[^转载]<a href="http://www.cnblogs.com/codingexperience/p/5930752.html" target="_blank" rel="noopener">http://www.cnblogs.com/codingexperience/p/5930752.html</a></p>
]]></content>
      <categories>
        <category>rpc</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>rpc</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着实例学习ZooKeeper的用法： 临时节点</title>
    <url>/2017/04/22/%E8%B7%9F%E7%9D%80%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0ZooKeeper%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A-%E4%B8%B4%E6%97%B6%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>使用Curator也可以简化Ephemeral Node (临时节点)的操作。<br>临时节点驻存在ZooKeeper中，当连接和session断掉时被删除。</p>
<p>比如通过ZooKeeper发布服务，服务启动时将自己的信息注册为临时节点，当服务断掉时ZooKeeper将此临时节点删除，这样client就不会得到服务的信息了。</p>
<p>PersistentEphemeralNode类代表临时节点。<br>通过下面的构造函数创建：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PersistentEphemeralNode</span><span class="params">(CuratorFramework client,</span></span></span><br><span class="line"><span class="function"><span class="params">                               PersistentEphemeralNode.Mode mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                               String basePath,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">byte</span>[] data)</span></span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">client - client instance</span></span><br><span class="line"><span class="function">mode - creation/protection mode</span></span><br><span class="line"><span class="function">basePath - the base path <span class="keyword">for</span> the node</span></span><br><span class="line"><span class="function">data - data <span class="keyword">for</span> the node</span></span><br></pre></td></tr></table></figure></p>
<p>其它参数还好理解， 不好理解的是PersistentEphemeralNode.Mode。</p>
<pre><code>EPHEMERAL： 以ZooKeeper的 CreateMode.EPHEMERAL方式创建节点。
EPHEMERAL_SEQUENTIAL: 如果path已经存在，以CreateMode.EPHEMERAL创建节点，否则以CreateMode.EPHEMERAL_SEQUENTIAL方式创建节点。
PROTECTED_EPHEMERAL: 以CreateMode.EPHEMERAL创建，提供保护方式。
PROTECTED_EPHEMERAL_SEQUENTIAL: 类似EPHEMERAL_SEQUENTIAL，提供保护方式。
</code></pre><p>保护方式是指一种很边缘的情况： 当服务器将节点创建好，但是节点名还没有返回给client,这时候服务器可能崩溃了，然后此时ZK session仍然合法， 所以此临时节点不会被删除。对于client来说， 它无法知道哪个节点是它们创建的。</p>
<p>即使不是sequential-ephemeral,也可能服务器创建成功但是客户端由于某些原因不知道创建的节点。</p>
<p>Curator对这些可能无人看管的节点提供了保护机制。 这些节点创建时会加上一个GUID。 如果节点创建失败正常的重试机制会发生。 重试时， 首先搜索父path, 根据GUID搜索节点，如果找到这样的节点， 则认为这些节点是第一次尝试创建时创建成功但丢失的节点，然后返回给调用者。</p>
<p>节点必须调用start方法启动。 不用时调用close方法。</p>
<p>PersistentEphemeralNode 内部自己处理错误状态。</p>
<p>我们的例子创建了两个节点，一个是临时节点，一个事持久化的节点。 可以看到， client重连后临时节点不存在了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.node;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.nodes.PersistentEphemeralNode;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.nodes.PersistentEphemeralNode.Mode;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.state.ConnectionState;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.state.ConnectionStateListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.KillSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistentEphemeralNodeExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/ephemeralNode"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH2 = <span class="string">"/example/node"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">		PersistentEphemeralNode node = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.getConnectionStateListenable().addListener(<span class="keyword">new</span> ConnectionStateListener() &#123;</span><br><span class="line">				</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;</span><br><span class="line">					System.out.println(<span class="string">"client state:"</span> + newState.name());</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			client.start();</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//http://zookeeper.apache.org/doc/r3.2.2/api/org/apache/zookeeper/CreateMode.html</span></span><br><span class="line">			node = <span class="keyword">new</span> PersistentEphemeralNode(client, Mode.EPHEMERAL,PATH, <span class="string">"test"</span>.getBytes());</span><br><span class="line">			node.start();</span><br><span class="line">			node.waitForInitialCreate(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">			String actualPath = node.getActualPath();</span><br><span class="line">			System.out.println(<span class="string">"node "</span> + actualPath + <span class="string">" value: "</span> + <span class="keyword">new</span> String(client.getData().forPath(actualPath)));</span><br><span class="line">			</span><br><span class="line">			client.create().forPath(PATH2, <span class="string">"persistent node"</span>.getBytes());</span><br><span class="line">			System.out.println(<span class="string">"node "</span> + PATH2 + <span class="string">" value: "</span> + <span class="keyword">new</span> String(client.getData().forPath(PATH2)));</span><br><span class="line">			KillSession.kill(client.getZookeeperClient().getZooKeeper(), server.getConnectString());</span><br><span class="line">			System.out.println(<span class="string">"node "</span> + actualPath + <span class="string">" doesn't exist: "</span> + (client.checkExists().forPath(actualPath) == <span class="keyword">null</span>));</span><br><span class="line">			System.out.println(<span class="string">"node "</span> + PATH2 + <span class="string">" value: "</span> + <span class="keyword">new</span> String(client.getData().forPath(PATH2)));</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(node);</span><br><span class="line">			CloseableUtils.closeQuietly(client);</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着实例学习ZooKeeper的用法： Curator扩展库</title>
    <url>/2017/04/22/%E8%B7%9F%E7%9D%80%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0ZooKeeper%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A-Curator%E6%89%A9%E5%B1%95%E5%BA%93/</url>
    <content><![CDATA[<p>还记得Curator提供哪几个组件吗？ 我们不妨回顾一下：</p>
<pre><code>Recipes
Framework
Utilities
Client
Errors
Extensions
</code></pre><p>Recipes组件包含了丰富的Curator应用的组件。 但是这些并不是ZooKeeper Recipe的全部。 大量的分布式应用已经抽象出了许许多多的的Recipe，其中有些还是可以通过Curator来实现。<br>如果不断都将这些Recipe都增加到Recipes中， Recipes会变得越来越大。 为了避免这种状况， Curator把一些其它的Recipe放在单独的包中， 命名方式就是curator-x-,比如curator-x-discovery， curator-x-rpc。<br>本文就是介绍curator-x-discovery。<br>这是一个服务发现的Recipe。<br>我们在介绍临时节点Ephemeral Node的时候就讲到， 可以通过临时节点创建一个服务注册机制。 服务启动后创建临时节点， 服务断掉后临时节点就不存在了。 这个扩展抽象了这种功能，听过了一套API,可以实现服务发现机制。</p>
<h1 id="服务类"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：-Curator扩展库/#服务类" class="headerlink" title="服务类"></a>服务类</h1><p>我们先介绍一下例子中的服务类。<br>InstanceDetails定义了服务实例的基本信息,实际中可能会定义更详细的信息。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.discovery;</span><br><span class="line"><span class="keyword">import</span> org.codehaus.jackson.map.annotate.JsonRootName;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * In a real application, the Service payload will most likely be more detailed</span></span><br><span class="line"><span class="comment"> * than this. But, this gives a good example.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@JsonRootName</span>(<span class="string">"details"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceDetails</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String description;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InstanceDetails</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InstanceDetails</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.description = description;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.description = description;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> description;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ExampleServer相当与你在分布式环境中的服务应用。 每个服务应用实例都类似这个类， 应用启动时调用start， 关闭时调用close。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.discovery;</span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.x.discovery.ServiceDiscovery;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.x.discovery.ServiceDiscoveryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.x.discovery.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.x.discovery.UriSpec;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.x.discovery.details.JsonInstanceSerializer;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This shows a very simplified method of registering an instance with the</span></span><br><span class="line"><span class="comment"> * service discovery. Each individual instance in your distributed set of</span></span><br><span class="line"><span class="comment"> * applications would create an instance of something similar to ExampleServer,</span></span><br><span class="line"><span class="comment"> * start it when the application comes up and close it when the application</span></span><br><span class="line"><span class="comment"> * shuts down.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleServer</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery&lt;InstanceDetails&gt; serviceDiscovery;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ServiceInstance&lt;InstanceDetails&gt; thisInstance;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ExampleServer</span><span class="params">(CuratorFramework client, String path, String serviceName, String description)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// in a real application, you'd have a convention of some kind for the</span></span><br><span class="line">		<span class="comment">// URI layout</span></span><br><span class="line">		UriSpec uriSpec = <span class="keyword">new</span> UriSpec(<span class="string">"&#123;scheme&#125;://foo.com:&#123;port&#125;"</span>);</span><br><span class="line">		thisInstance = ServiceInstance.&lt;InstanceDetails&gt; builder().name(serviceName).payload(<span class="keyword">new</span> InstanceDetails(description))</span><br><span class="line">				.port((<span class="keyword">int</span>) (<span class="number">65535</span> * Math.random())) <span class="comment">// in a real application,</span></span><br><span class="line">														<span class="comment">// you'd use a common</span></span><br><span class="line">														<span class="comment">// port</span></span><br><span class="line">				.uriSpec(uriSpec).build();</span><br><span class="line">		<span class="comment">// if you mark your payload class with @JsonRootName the provided</span></span><br><span class="line">		<span class="comment">// JsonInstanceSerializer will work</span></span><br><span class="line">		JsonInstanceSerializer&lt;InstanceDetails&gt; serializer = <span class="keyword">new</span> JsonInstanceSerializer&lt;InstanceDetails&gt;(InstanceDetails.class);</span><br><span class="line">		serviceDiscovery = ServiceDiscoveryBuilder.builder(InstanceDetails.class).client(client).basePath(path).serializer(serializer)</span><br><span class="line">				.thisInstance(thisInstance).build();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ServiceInstance&lt;InstanceDetails&gt; <span class="title">getThisInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> thisInstance;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		serviceDiscovery.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		CloseableUtils.closeQuietly(serviceDiscovery);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="发现中心"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：-Curator扩展库/#发现中心" class="headerlink" title="发现中心"></a>发现中心</h1><p>DiscoveryExample提供了增加，删除，显示，注册已有的服务的功能。<br>注意此处服务注册是由ExampleServer自己完成的， 这比较符合实际的情况。 实际情况是服务自己起来后主动注册服务。 但是此处启动又是由DiscoveryExample来调用， 纯粹为了演示使用。 你可以根据你自己的情况合理安排服务的注册和启动。</p>
<p>random命令提供了一个完全由DiscoveryExample控制的服务。 它负责注册一个服务并启动。</p>
<p>调用close就关闭了服务。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.discovery;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.x.discovery.ServiceDiscovery;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.x.discovery.ServiceDiscoveryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.x.discovery.ServiceInstance;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.x.discovery.ServiceProvider;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.x.discovery.details.JsonInstanceSerializer;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.x.discovery.strategies.RandomStrategy;</span><br><span class="line"><span class="keyword">import</span> com.google.common.base.Predicate;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Iterables;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscoveryExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/discovery/example"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// This method is scaffolding to get the example up and running</span></span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">		ServiceDiscovery&lt;InstanceDetails&gt; serviceDiscovery = <span class="keyword">null</span>;</span><br><span class="line">		Map&lt;String, ServiceProvider&lt;InstanceDetails&gt;&gt; providers = Maps.newHashMap();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			JsonInstanceSerializer&lt;InstanceDetails&gt; serializer = <span class="keyword">new</span> JsonInstanceSerializer&lt;InstanceDetails&gt;(InstanceDetails.class);</span><br><span class="line">			serviceDiscovery = ServiceDiscoveryBuilder.builder(InstanceDetails.class).client(client).basePath(PATH).serializer(serializer).build();</span><br><span class="line">			serviceDiscovery.start();</span><br><span class="line">			processCommands(serviceDiscovery, providers, client);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (ServiceProvider&lt;InstanceDetails&gt; cache : providers.values()) &#123;</span><br><span class="line">				CloseableUtils.closeQuietly(cache);</span><br><span class="line">			&#125;</span><br><span class="line">			CloseableUtils.closeQuietly(serviceDiscovery);</span><br><span class="line">			CloseableUtils.closeQuietly(client);</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processCommands</span><span class="params">(ServiceDiscovery&lt;InstanceDetails&gt; serviceDiscovery, Map&lt;String, ServiceProvider&lt;InstanceDetails&gt;&gt; providers,</span></span></span><br><span class="line"><span class="function"><span class="params">			CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// More scaffolding that does a simple command line processor</span></span><br><span class="line">		printHelp();</span><br><span class="line">		List&lt;ExampleServer&gt; servers = Lists.newArrayList();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			<span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">while</span> (!done) &#123;</span><br><span class="line">				System.out.print(<span class="string">"&gt; "</span>);</span><br><span class="line">				String line = in.readLine();</span><br><span class="line">				<span class="keyword">if</span> (line == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				String command = line.trim();</span><br><span class="line">				String[] parts = command.split(<span class="string">"\\s"</span>);</span><br><span class="line">				<span class="keyword">if</span> (parts.length == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				String operation = parts[<span class="number">0</span>];</span><br><span class="line">				String args[] = Arrays.copyOfRange(parts, <span class="number">1</span>, parts.length);</span><br><span class="line">				<span class="keyword">if</span> (operation.equalsIgnoreCase(<span class="string">"help"</span>) || operation.equalsIgnoreCase(<span class="string">"?"</span>)) &#123;</span><br><span class="line">					printHelp();</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equalsIgnoreCase(<span class="string">"q"</span>) || operation.equalsIgnoreCase(<span class="string">"quit"</span>)) &#123;</span><br><span class="line">					done = <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">"add"</span>)) &#123;</span><br><span class="line">					addInstance(args, client, command, servers);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">"delete"</span>)) &#123;</span><br><span class="line">					deleteInstance(args, command, servers);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">"random"</span>)) &#123;</span><br><span class="line">					listRandomInstance(args, serviceDiscovery, providers, command);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">"list"</span>)) &#123;</span><br><span class="line">					listInstances(serviceDiscovery);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (ExampleServer server : servers) &#123;</span><br><span class="line">				CloseableUtils.closeQuietly(server);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listRandomInstance</span><span class="params">(String[] args, ServiceDiscovery&lt;InstanceDetails&gt; serviceDiscovery,</span></span></span><br><span class="line"><span class="function"><span class="params">			Map&lt;String, ServiceProvider&lt;InstanceDetails&gt;&gt; providers, String command)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// this shows how to use a ServiceProvider</span></span><br><span class="line">		<span class="comment">// in a real application you'd create the ServiceProvider early for the</span></span><br><span class="line">		<span class="comment">// service(s) you're interested in</span></span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"syntax error (expected random &lt;name&gt;): "</span> + command);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		String serviceName = args[<span class="number">0</span>];</span><br><span class="line">		ServiceProvider&lt;InstanceDetails&gt; provider = providers.get(serviceName);</span><br><span class="line">		<span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">			provider = serviceDiscovery.serviceProviderBuilder().serviceName(serviceName).providerStrategy(<span class="keyword">new</span> RandomStrategy&lt;InstanceDetails&gt;()).build();</span><br><span class="line">			providers.put(serviceName, provider);</span><br><span class="line">			provider.start();</span><br><span class="line">			Thread.sleep(<span class="number">2500</span>); <span class="comment">// give the provider time to warm up - in a real</span></span><br><span class="line">								<span class="comment">// application you wouldn't need to do this</span></span><br><span class="line">		&#125;</span><br><span class="line">		ServiceInstance&lt;InstanceDetails&gt; instance = provider.getInstance();</span><br><span class="line">		<span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"No instances named: "</span> + serviceName);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			outputInstance(instance);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listInstances</span><span class="params">(ServiceDiscovery&lt;InstanceDetails&gt; serviceDiscovery)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// This shows how to query all the instances in service discovery</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Collection&lt;String&gt; serviceNames = serviceDiscovery.queryForNames();</span><br><span class="line">			System.out.println(serviceNames.size() + <span class="string">" type(s)"</span>);</span><br><span class="line">			<span class="keyword">for</span> (String serviceName : serviceNames) &#123;</span><br><span class="line">				Collection&lt;ServiceInstance&lt;InstanceDetails&gt;&gt; instances = serviceDiscovery.queryForInstances(serviceName);</span><br><span class="line">				System.out.println(serviceName);</span><br><span class="line">				<span class="keyword">for</span> (ServiceInstance&lt;InstanceDetails&gt; instance : instances) &#123;</span><br><span class="line">					outputInstance(instance);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(serviceDiscovery);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outputInstance</span><span class="params">(ServiceInstance&lt;InstanceDetails&gt; instance)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"\t"</span> + instance.getPayload().getDescription() + <span class="string">": "</span> + instance.buildUriSpec());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteInstance</span><span class="params">(String[] args, String command, List&lt;ExampleServer&gt; servers)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// simulate a random instance going down</span></span><br><span class="line">		<span class="comment">// in a real application, this would occur due to normal operation, a</span></span><br><span class="line">		<span class="comment">// crash, maintenance, etc.</span></span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"syntax error (expected delete &lt;name&gt;): "</span> + command);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">final</span> String serviceName = args[<span class="number">0</span>];</span><br><span class="line">		ExampleServer server = Iterables.find(servers, <span class="keyword">new</span> Predicate&lt;ExampleServer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(ExampleServer server)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> server.getThisInstance().getName().endsWith(serviceName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"No servers found named: "</span> + serviceName);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		servers.remove(server);</span><br><span class="line">		CloseableUtils.closeQuietly(server);</span><br><span class="line">		System.out.println(<span class="string">"Removed a random instance of: "</span> + serviceName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInstance</span><span class="params">(String[] args, CuratorFramework client, String command, List&lt;ExampleServer&gt; servers)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// simulate a new instance coming up</span></span><br><span class="line">		<span class="comment">// in a real application, this would be a separate process</span></span><br><span class="line">		<span class="keyword">if</span> (args.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"syntax error (expected add &lt;name&gt; &lt;description&gt;): "</span> + command);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		StringBuilder description = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; args.length; ++i) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">				description.append(<span class="string">' '</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			description.append(args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		String serviceName = args[<span class="number">0</span>];</span><br><span class="line">		ExampleServer server = <span class="keyword">new</span> ExampleServer(client, PATH, serviceName, description.toString());</span><br><span class="line">		servers.add(server);</span><br><span class="line">		server.start();</span><br><span class="line">		System.out.println(serviceName + <span class="string">" added"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printHelp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"An example of using the ServiceDiscovery APIs. This example is driven by entering commands at the prompt:\n"</span>);</span><br><span class="line">		System.out.println(<span class="string">"add &lt;name&gt; &lt;description&gt;: Adds a mock service with the given name and description"</span>);</span><br><span class="line">		System.out.println(<span class="string">"delete &lt;name&gt;: Deletes one of the mock services with the given name"</span>);</span><br><span class="line">		System.out.println(<span class="string">"list: Lists all the currently registered services"</span>);</span><br><span class="line">		System.out.println(<span class="string">"random &lt;name&gt;: Lists a random instance of the service with the given name"</span>);</span><br><span class="line">		System.out.println(<span class="string">"quit: Quit the example"</span>);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="其它扩展"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：-Curator扩展库/#其它扩展" class="headerlink" title="其它扩展"></a>其它扩展</h1><p>其它两个扩展Curator RPC Proxy（curator-x-rpc）扩展和Service Discovery Server（curator-x-discovery-server）是为了桥接非Java应用的扩展，本系列将不再介绍了。感兴趣的朋友可以看下面的文档。<br><strong>Curator Service Discovery</strong><br><strong>Curator RPC Proxy</strong></p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着实例学习ZooKeeper的用法：Barrier</title>
    <url>/2017/04/22/%E8%B7%9F%E7%9D%80%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0ZooKeeper%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9ABarrier/</url>
    <content><![CDATA[<p>[TOC]</p>
<p>分布式Barrier是这样一个类： 它会阻塞所有节点上的等待进程，知道某一个被满足， 然后所有的节点继续进行。</p>
<p>比如赛马比赛中， 等赛马陆续来到起跑线前。 一声令下，所有的赛马都飞奔而出。</p>
<h1 id="栅栏Barrier"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：Barrier/#栅栏Barrier" class="headerlink" title="栅栏Barrier"></a>栅栏Barrier</h1><p>DistributedBarrier类实现了栅栏的功能。 它的构造函数如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DistributedBarrier</span><span class="params">(CuratorFramework client, String barrierPath)</span></span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">client - client</span></span><br><span class="line"><span class="function">barrierPath - path to use as the barrier</span></span><br></pre></td></tr></table></figure></p>
<p>首先你需要设置栅栏，它将阻塞在它上面等待的线程:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setBarrier();</span><br></pre></td></tr></table></figure></p>
<p>然后需要阻塞的线程调用方法等待放行条件:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitOnBarrier</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>当条件满足时，移除栅栏，所有等待的线程将继续执行：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">removeBarrier();</span><br></pre></td></tr></table></figure></p>
<p><strong>异常处理</strong><br>DistributedBarrier 会监控连接状态，当连接断掉时waitOnBarrier()方法会抛出异常。</p>
<p>看一个例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.barrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.barriers.DistributedBarrier;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedBarrierExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/barrier"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">			DistributedBarrier controlBarrier = <span class="keyword">new</span> DistributedBarrier(client, PATH);</span><br><span class="line">			controlBarrier.setBarrier();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> DistributedBarrier barrier = <span class="keyword">new</span> DistributedBarrier(client, PATH);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">				Callable&lt;Void&gt; task = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">						</span><br><span class="line">						Thread.sleep((<span class="keyword">long</span>) (<span class="number">3</span> * Math.random()));</span><br><span class="line">						System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" waits on Barrier"</span>);</span><br><span class="line">						barrier.waitOnBarrier();</span><br><span class="line">						System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" begins"</span>);</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">			System.out.println(<span class="string">"all Barrier instances should wait the condition"</span>);</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			controlBarrier.removeBarrier();</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子创建了controlBarrier来设置栅栏和移除栅栏。<br>我们创建了5个线程，在此Barrier上等待。<br>最后移除栅栏后所有的线程才继续执行。</p>
<p>如果你开始不设置栅栏，所有的线程就不会阻塞住。</p>
<h1 id="双栅栏Double-Barrier"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：Barrier/#双栅栏Double-Barrier" class="headerlink" title="双栅栏Double Barrier"></a>双栅栏Double Barrier</h1><p>双栅栏允许客户端在计算的开始和结束时同步。当足够的进程加入到双栅栏时，进程开始计算， 当计算完成时，离开栅栏。<br>双栅栏类是DistributedDoubleBarrier。<br>构造函数为:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DistributedDoubleBarrier</span><span class="params">(CuratorFramework client,</span></span></span><br><span class="line"><span class="function"><span class="params">                                String barrierPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">int</span> memberQty)</span></span></span><br><span class="line"><span class="function">Creates the barrier abstraction. memberQty is the number of members in the barrier. When <span class="title">enter</span><span class="params">()</span> is called, it blocks until</span></span><br><span class="line"><span class="function">all members have entered. When <span class="title">leave</span><span class="params">()</span> is called, it blocks until all members have left.</span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">client - the client</span></span><br><span class="line"><span class="function">barrierPath - path to use</span></span><br><span class="line"><span class="function">memberQty - the number of members in the barrier</span></span><br></pre></td></tr></table></figure></p>
<p>memberQty是成员数量，当enter方法被调用时，成员被阻塞，直到所有的成员都调用了enter。 当leave方法被调用时，它也阻塞调用线程， 知道所有的成员都调用了leave。<br>就像百米赛跑比赛， 发令枪响， 所有的运动员开始跑，等所有的运动员跑过终点线，比赛才结束。</p>
<p>DistributedBarrier 会监控连接状态，当连接断掉时enter()和leave方法会抛出异常。</p>
<p>例子代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.barrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.barriers.DistributedBarrier;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.barriers.DistributedDoubleBarrier;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedBarrierExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/barrier"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> DistributedDoubleBarrier barrier = <span class="keyword">new</span> DistributedDoubleBarrier(client, PATH, QTY);</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">				Callable&lt;Void&gt; task = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">						</span><br><span class="line">						Thread.sleep((<span class="keyword">long</span>) (<span class="number">3</span> * Math.random()));</span><br><span class="line">						System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" enters"</span>);</span><br><span class="line">						barrier.enter();</span><br><span class="line">						System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" begins"</span>);</span><br><span class="line">						Thread.sleep((<span class="keyword">long</span>) (<span class="number">3000</span> * Math.random()));</span><br><span class="line">						barrier.leave();</span><br><span class="line">						System.out.println(<span class="string">"Client #"</span> + index + <span class="string">" left"</span>);</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分布式Barrier是这样一个类： 它会阻塞所有节点上的等待进程，知道某一个被满足， 然后所有的节点继续进行。</p>
<p>比如赛马比赛中， 等赛马陆续来到起跑线前。 一声令下，所有的赛马都飞奔而出。</p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着实例学习ZooKeeper的用法： 缓存</title>
    <url>/2017/04/22/%E8%B7%9F%E7%9D%80%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0ZooKeeper%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A-%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>可以利用ZooKeeper在集群的各个节点之间缓存数据。 每个节点都可以得到最新的缓存的数据。 Curator提供了三种类型的缓存方式：Path Cache,Node Cache 和Tree Cache。</p>
<h1 id="Path-Cache"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：-缓存/#Path-Cache" class="headerlink" title="Path Cache"></a>Path Cache</h1><p>Path Cache用来监控一个ZNode的子节点. 当一个子节点增加， 更新，删除时， Path Cache会改变它的状态， 会包含最新的子节点， 子节点的数据和状态。<br>这也正如它的名字表示的那样， 那监控path。</p>
<p>实际使用时会涉及到四个类：</p>
<pre><code>PathChildrenCache
PathChildrenCacheEvent
PathChildrenCacheListener
ChildData
</code></pre><p>通过下面的构造函数创建Path Cache:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathChildrenCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> cacheData)</span></span></span><br></pre></td></tr></table></figure></p>
<p>想使用cache，必须调用它的start方法，不用之后调用close方法。<br>start有两个， 其中一个可以传入StartMode，用来为初始的cache设置暖场方式(warm)：</p>
<pre><code>NORMAL: 初始时为空。
BUILD_INITIAL_CACHE: 在这个方法返回之前调用rebuild()。
POST_INITIALIZED_EVENT: 当Cache初始化数据后发送一个PathChildrenCacheEvent.Type#INITIALIZED事件
</code></pre><p>public void addListener(PathChildrenCacheListener listener)可以增加listener监听缓存的改变。</p>
<p>getCurrentData()方法返回一个List对象，可以遍历所有的子节点。</p>
<p>这个例子摘自官方的例子， 实现了一个控制台的方式操作缓存。 它提供了三个命令， 你可以在控制台中输入。</p>
<pre><code>set 用来新增或者更新一个子节点的值， 也就是更新一个缓存对象
remove 是删除一个缓存对象
list 列出所有的缓存对象
</code></pre><p>另外还提供了一个help命令提供帮助。</p>
<p>设置/更新、移除其实是使用client (CuratorFramework)来操作, 不通过PathChildrenCache操作：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.setData().forPath(path, bytes);</span><br><span class="line">client.create().creatingParentsIfNeeded().forPath(path, bytes);</span><br><span class="line">client.delete().forPath(path);</span><br></pre></td></tr></table></figure></p>
<p>而查询缓存使用下面的方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (ChildData data : cache.getCurrentData()) &#123;</span><br><span class="line">	System.out.println(data.getPath() + <span class="string">" = "</span> + <span class="keyword">new</span> String(data.getData()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Node-Cache"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：-缓存/#Node-Cache" class="headerlink" title="Node Cache"></a>Node Cache</h1><p>Path Cache用来监控一个ZNode. 当节点的数据修改或者删除时，Node Cache能更新它的状态包含最新的改变。</p>
<p>涉及到下面的三个类：</p>
<pre><code>NodeCache
NodeCacheListener
ChildData
</code></pre><p>想使用cache，依然要调用它的start方法，不用之后调用close方法。</p>
<p>getCurrentData()将得到节点当前的状态，通过它的状态可以得到当前的值。<br>可以使用public void addListener(NodeCacheListener listener)监控节点状态的改变。</p>
<p>我们依然使用上面的例子框架来演示Node Cache。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.cache;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCacheListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeCacheExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/nodeCache"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">		NodeCache cache = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			cache = <span class="keyword">new</span> NodeCache(client, PATH);</span><br><span class="line">			cache.start();</span><br><span class="line">			processCommands(client, cache);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(cache);</span><br><span class="line">			CloseableUtils.closeQuietly(client);</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(<span class="keyword">final</span> NodeCache cache)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// a PathChildrenCacheListener is optional. Here, it's used just to log</span></span><br><span class="line">		<span class="comment">// changes</span></span><br><span class="line">		NodeCacheListener listener = <span class="keyword">new</span> NodeCacheListener() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodeChanged</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (cache.getCurrentData() != <span class="keyword">null</span>)</span><br><span class="line">					System.out.println(<span class="string">"Node changed: "</span> + cache.getCurrentData().getPath() + <span class="string">", value: "</span> + <span class="keyword">new</span> String(cache.getCurrentData().getData()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		cache.getListenable().addListener(listener);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processCommands</span><span class="params">(CuratorFramework client, NodeCache cache)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		printHelp();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			addListener(cache);</span><br><span class="line">			BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			<span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">while</span> (!done) &#123;</span><br><span class="line">				System.out.print(<span class="string">"&gt; "</span>);</span><br><span class="line">				String line = in.readLine();</span><br><span class="line">				<span class="keyword">if</span> (line == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				String command = line.trim();</span><br><span class="line">				String[] parts = command.split(<span class="string">"\\s"</span>);</span><br><span class="line">				<span class="keyword">if</span> (parts.length == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				String operation = parts[<span class="number">0</span>];</span><br><span class="line">				String args[] = Arrays.copyOfRange(parts, <span class="number">1</span>, parts.length);</span><br><span class="line">				<span class="keyword">if</span> (operation.equalsIgnoreCase(<span class="string">"help"</span>) || operation.equalsIgnoreCase(<span class="string">"?"</span>)) &#123;</span><br><span class="line">					printHelp();</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equalsIgnoreCase(<span class="string">"q"</span>) || operation.equalsIgnoreCase(<span class="string">"quit"</span>)) &#123;</span><br><span class="line">					done = <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">"set"</span>)) &#123;</span><br><span class="line">					setValue(client, command, args);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">"remove"</span>)) &#123;</span><br><span class="line">					remove(client);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">"show"</span>)) &#123;</span><br><span class="line">					show(cache);</span><br><span class="line">				&#125;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>); <span class="comment">// just to allow the console output to catch</span></span><br><span class="line">									<span class="comment">// up</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(NodeCache cache)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (cache.getCurrentData() != <span class="keyword">null</span>)</span><br><span class="line">			System.out.println(cache.getCurrentData().getPath() + <span class="string">" = "</span> + <span class="keyword">new</span> String(cache.getCurrentData().getData()));</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			System.out.println(<span class="string">"cache don't set a value"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client.delete().forPath(PATH);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">			<span class="comment">// ignore</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(CuratorFramework client, String command, String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"syntax error (expected set &lt;value&gt;): "</span> + command);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = args[<span class="number">0</span>].getBytes();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client.setData().forPath(PATH, bytes);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">			client.create().creatingParentsIfNeeded().forPath(PATH, bytes);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printHelp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"An example of using PathChildrenCache. This example is driven by entering commands at the prompt:\n"</span>);</span><br><span class="line">		System.out.println(<span class="string">"set &lt;value&gt;: Adds or updates a node with the given name"</span>);</span><br><span class="line">		System.out.println(<span class="string">"remove: Deletes the node with the given name"</span>);</span><br><span class="line">		System.out.println(<span class="string">"show: Display the node's value in the cache"</span>);</span><br><span class="line">		System.out.println(<span class="string">"quit: Quit the example"</span>);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Tree-Node"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：-缓存/#Tree-Node" class="headerlink" title="Tree Node"></a>Tree Node</h1><p>这种类型的即可以监控节点的状态，还监控节点的子节点的状态， 类似上面两种cache的组合。 这也就是Tree的概念。 它监控整个树中节点的状态。<br>涉及到下面四个类。</p>
<pre><code>TreeCache
TreeCacheListener
TreeCacheEvent
ChildData
</code></pre><p>而关键的TreeCache的构造函数为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TreeCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> cacheData)</span></span></span><br></pre></td></tr></table></figure>
<p>想使用cache，依然要调用它的start方法，不用之后调用close方法。</p>
<p>getCurrentChildren()返回cache的状态，类型为Map。 而getCurrentData()返回监控的path的数据。</p>
<p>public void addListener(TreeCacheListener listener)可以增加listener来监控状态的改变。</p>
<p>例子依然采用和上面的例子类似， 尤其和Path Cache类似。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.cache;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.ChildData;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.TreeCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.TreeCacheEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.TreeCacheListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.ZKPaths;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.KeeperException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeCacheExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/treeCache"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">		TreeCache cache = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			cache = <span class="keyword">new</span> TreeCache(client, PATH);</span><br><span class="line">			cache.start();</span><br><span class="line">			processCommands(client, cache);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(cache);</span><br><span class="line">			CloseableUtils.closeQuietly(client);</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(<span class="keyword">final</span> TreeCache cache)</span> </span>&#123;</span><br><span class="line">		TreeCacheListener listener = <span class="keyword">new</span> TreeCacheListener() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, TreeCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				<span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">				<span class="keyword">case</span> NODE_ADDED: &#123;</span><br><span class="line">					System.out.println(<span class="string">"TreeNode added: "</span> + ZKPaths.getNodeFromPath(event.getData().getPath()) + <span class="string">", value: "</span></span><br><span class="line">							+ <span class="keyword">new</span> String(event.getData().getData()));</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">case</span> NODE_UPDATED: &#123;</span><br><span class="line">					System.out.println(<span class="string">"TreeNode changed: "</span> + ZKPaths.getNodeFromPath(event.getData().getPath()) + <span class="string">", value: "</span></span><br><span class="line">							+ <span class="keyword">new</span> String(event.getData().getData()));</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">case</span> NODE_REMOVED: &#123;</span><br><span class="line">					System.out.println(<span class="string">"TreeNode removed: "</span> + ZKPaths.getNodeFromPath(event.getData().getPath()));</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					System.out.println(<span class="string">"Other event: "</span> + event.getType().name());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		cache.getListenable().addListener(listener);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processCommands</span><span class="params">(CuratorFramework client, TreeCache cache)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">// More scaffolding that does a simple command line processor</span></span><br><span class="line">		printHelp();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			addListener(cache);</span><br><span class="line">			BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">			<span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">while</span> (!done) &#123;</span><br><span class="line">				System.out.print(<span class="string">"&gt; "</span>);</span><br><span class="line">				String line = in.readLine();</span><br><span class="line">				<span class="keyword">if</span> (line == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				String command = line.trim();</span><br><span class="line">				String[] parts = command.split(<span class="string">"\\s"</span>);</span><br><span class="line">				<span class="keyword">if</span> (parts.length == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				String operation = parts[<span class="number">0</span>];</span><br><span class="line">				String args[] = Arrays.copyOfRange(parts, <span class="number">1</span>, parts.length);</span><br><span class="line">				<span class="keyword">if</span> (operation.equalsIgnoreCase(<span class="string">"help"</span>) || operation.equalsIgnoreCase(<span class="string">"?"</span>)) &#123;</span><br><span class="line">					printHelp();</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equalsIgnoreCase(<span class="string">"q"</span>) || operation.equalsIgnoreCase(<span class="string">"quit"</span>)) &#123;</span><br><span class="line">					done = <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">"set"</span>)) &#123;</span><br><span class="line">					setValue(client, command, args);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">"remove"</span>)) &#123;</span><br><span class="line">					remove(client, command, args);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (operation.equals(<span class="string">"list"</span>)) &#123;</span><br><span class="line">					list(cache);</span><br><span class="line">				&#125;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>); <span class="comment">// just to allow the console output to catch</span></span><br><span class="line">									<span class="comment">// up</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(TreeCache cache)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (cache.getCurrentChildren(PATH).size() == <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"* empty *"</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;			</span><br><span class="line">			<span class="keyword">for</span> (Map.Entry&lt;String, ChildData&gt; entry : cache.getCurrentChildren(PATH).entrySet()) &#123;</span><br><span class="line">				System.out.println(entry.getKey() + <span class="string">" = "</span> + <span class="keyword">new</span> String(entry.getValue().getData()));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(CuratorFramework client, String command, String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"syntax error (expected remove &lt;path&gt;): "</span> + command);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		String name = args[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span> (name.contains(<span class="string">"/"</span>)) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Invalid node name"</span> + name);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		String path = ZKPaths.makePath(PATH, name);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client.delete().forPath(path);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">			<span class="comment">// ignore</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(CuratorFramework client, String command, String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</span><br><span class="line">			System.err.println(<span class="string">"syntax error (expected set &lt;path&gt; &lt;value&gt;): "</span> + command);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		String name = args[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span> (name.contains(<span class="string">"/"</span>)) &#123;</span><br><span class="line">			System.err.println(<span class="string">"Invalid node name"</span> + name);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		String path = ZKPaths.makePath(PATH, name);</span><br><span class="line">		<span class="keyword">byte</span>[] bytes = args[<span class="number">1</span>].getBytes();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client.setData().forPath(path, bytes);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (KeeperException.NoNodeException e) &#123;</span><br><span class="line">			client.create().creatingParentsIfNeeded().forPath(path, bytes);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printHelp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"An example of using PathChildrenCache. This example is driven by entering commands at the prompt:\n"</span>);</span><br><span class="line">		System.out.println(<span class="string">"set &lt;name&gt; &lt;value&gt;: Adds or updates a node with the given name"</span>);</span><br><span class="line">		System.out.println(<span class="string">"remove &lt;name&gt;: Deletes the node with the given name"</span>);</span><br><span class="line">		System.out.println(<span class="string">"list: List the nodes/values in the cache"</span>);</span><br><span class="line">		System.out.println(<span class="string">"quit: Quit the example"</span>);</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着实例学习ZooKeeper的用法： 计数器</title>
    <url>/2017/04/22/%E8%B7%9F%E7%9D%80%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0ZooKeeper%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A-%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<p>使用Curator来实现计数器。 顾名思义，计数器是用来计数的, 利用ZooKeeper可以实现一个集群共享的计数器。 只要使用相同的path就可以得到最新的计数器值， 这是由ZooKeeper的一致性保证的。Curator有两个计数器， 一个是用int来计数，一个用long来计数。</p>
<h1 id="SharedCount"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：-计数器/#SharedCount" class="headerlink" title="SharedCount"></a>SharedCount</h1><p>这个类使用int类型来计数。 主要涉及三个类。</p>
<pre><code>SharedCount
SharedCountReader
SharedCountListener
</code></pre><p>SharedCount代表计数器， 可以为它增加一个SharedCountListener，当计数器改变时此Listener可以监听到改变的事件，而SharedCountReader可以读取到最新的值， 包括字面值和带版本信息的值VersionedValue。</p>
<p>例子代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.counter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.shared.SharedCount;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.shared.SharedCountListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.shared.SharedCountReader;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.state.ConnectionState;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SharedCounterExample</span> <span class="keyword">implements</span> <span class="title">SharedCountListener</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/counter"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">		SharedCounterExample example = <span class="keyword">new</span> SharedCounterExample();</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			</span><br><span class="line">			SharedCount baseCount = <span class="keyword">new</span> SharedCount(client, PATH, <span class="number">0</span>);</span><br><span class="line">			baseCount.addListener(example);</span><br><span class="line">			baseCount.start();</span><br><span class="line">			</span><br><span class="line">			List&lt;SharedCount&gt; examples = Lists.newArrayList();</span><br><span class="line">			ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> SharedCount count = <span class="keyword">new</span> SharedCount(client, PATH, <span class="number">0</span>);</span><br><span class="line">				examples.add(count);</span><br><span class="line">				Callable&lt;Void&gt; task = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">						count.start();</span><br><span class="line">						Thread.sleep(rand.nextInt(<span class="number">10000</span>));</span><br><span class="line">						System.out.println(<span class="string">"Increment:"</span> + count.trySetCount(count.getVersionedValue(), count.getCount() + rand.nextInt(<span class="number">10</span>)));</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				examples.get(i).close();</span><br><span class="line">			&#125;</span><br><span class="line">			baseCount.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework arg0, ConnectionState arg1)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"State changed: "</span> + arg1.toString());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countHasChanged</span><span class="params">(SharedCountReader sharedCount, <span class="keyword">int</span> newCount)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Counter's value is changed to "</span> + newCount);		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个例子中，我们使用baseCount来监听计数值(addListener方法)。 任意的SharedCount， 只要使用相同的path，都可以得到这个计数值。<br>然后我们使用5个线程为计数值增加一个10以内的随机数。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">count.trySetCount(count.getVersionedValue(), count.getCount() + rand.nextInt(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></p>
<p>这里我们使用trySetCount去设置计数器。 第一个参数提供当前的VersionedValue,如果期间其它client更新了此计数值， 你的更新可能不成功，<br>但是这时你的client更新了最新的值，所以失败了你可以尝试再更新一次。<br>而setCount是强制更新计数器的值。</p>
<p>注意计数器必须start,使用完之后必须调用close关闭它。</p>
<p>在这里再重复一遍前面讲到的， 强烈推荐你监控ConnectionStateListener， 尽管我们的有些例子没有监控它。 在本例中SharedCountListener扩展了ConnectionStateListener。 这一条针对所有的Curator recipes都适用，后面的文章中就不专门提示了。</p>
<h1 id="DistributedAtomicLong"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：-计数器/#DistributedAtomicLong" class="headerlink" title="DistributedAtomicLong"></a>DistributedAtomicLong</h1><p>再看一个Long类型的计数器。 除了计数的范围比SharedCount大了之外， 它首先尝试使用乐观锁的方式设置计数器， 如果不成功(比如期间计数器已经被其它client更新了)， 它使用InterProcessMutex方式来更新计数值。 还记得InterProcessMutex是什么吗？ 它是我们前面跟着实例学习ZooKeeper的用法： 分布式锁 讲的分布式可重入锁。 这和上面的计数器的实现有显著的不同。</p>
<p>可以从它的内部实现DistributedAtomicValue.trySet中看出端倪。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicValue&lt;<span class="keyword">byte</span>[]&gt;   trySet(MakeValue makeValue) <span class="keyword">throws</span> Exception</span><br><span class="line">&#123;</span><br><span class="line">    MutableAtomicValue&lt;<span class="keyword">byte</span>[]&gt;  result = <span class="keyword">new</span> MutableAtomicValue&lt;<span class="keyword">byte</span>[]&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    tryOptimistic(result, makeValue);</span><br><span class="line">    <span class="keyword">if</span> ( !result.succeeded() &amp;&amp; (mutex != <span class="keyword">null</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        tryWithMutex(result, makeValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此计数器有一系列的操作：</p>
<pre><code>get(): 获取当前值
increment()： 加一
decrement(): 减一
add()： 增加特定的值
subtract(): 减去特定的值
trySet(): 尝试设置计数值
forceSet(): 强制设置计数值
</code></pre><p>你必须检查返回结果的succeeded()， 它代表此操作是否成功。 如果操作成功， preValue()代表操作前的值， postValue()代表操作后的值。</p>
<p>我们下面的例子中使用5个线程对计数器进行加一操作，如果成功，将操作前后的值打印出来。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.counter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.atomic.AtomicValue;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.atomic.DistributedAtomicLong;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.RetryNTimes;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedAtomicLongExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/counter"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			List&lt;DistributedAtomicLong&gt; examples = Lists.newArrayList();</span><br><span class="line">			ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> DistributedAtomicLong count = <span class="keyword">new</span> DistributedAtomicLong(client, PATH, <span class="keyword">new</span> RetryNTimes(<span class="number">10</span>, <span class="number">10</span>));</span><br><span class="line">				</span><br><span class="line">				examples.add(count);</span><br><span class="line">				Callable&lt;Void&gt; task = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="comment">//Thread.sleep(rand.nextInt(1000));</span></span><br><span class="line">							AtomicValue&lt;Long&gt; value = count.increment();</span><br><span class="line">							<span class="comment">//AtomicValue&lt;Long&gt; value = count.decrement();</span></span><br><span class="line">							<span class="comment">//AtomicValue&lt;Long&gt; value = count.add((long)rand.nextInt(20));</span></span><br><span class="line">							System.out.println(<span class="string">"succeed: "</span> + value.succeeded());</span><br><span class="line">							<span class="keyword">if</span> (value.succeeded())</span><br><span class="line">								System.out.println(<span class="string">"Increment: from "</span> + value.preValue() + <span class="string">" to "</span> + value.postValue());</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着实例学习ZooKeeper的用法： 队列</title>
    <url>/2017/04/22/%E8%B7%9F%E7%9D%80%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0ZooKeeper%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>Curator也提供ZK Recipe的分布式队列实现。 利用ZK的 PERSISTENTSEQUENTIAL节点， 可以保证放入到队列中的项目是按照顺序排队的。 如果单一的消费者从队列中取数据， 那么它是先入先出的，这也是队列的特点。 如果你严格要求顺序，你就的使用单一的消费者，可以使用leader选举只让leader作为唯一的消费者。</p>
<p>但是， 根据Netflix的Curator作者所说， ZooKeeper真心不适合做Queue，或者说ZK没有实现一个好的Queue，详细内容可以看 Tech Note 4， 原因有五：</p>
<pre><code>1.  ZK有1MB 的传输限制。 实践中ZNode必须相对较小，而队列包含成千上万的消息，非常的大。
2. 如果有很多节点，ZK启动时相当的慢。 而使用queue会导致好多ZNode. 你需要显著增大 initLimit 和 syncLimit.
3. ZNode很大的时候很难清理。Netflix不得不创建了一个专门的程序做这事。
4. 当很大量的包含成千上万的子节点的ZNode时， ZK的性能变得不好
5. ZK的数据库完全放在内存中。 大量的Queue意味着会占用很多的内存空间。
</code></pre><p>尽管如此， Curator还是创建了各种Queue的实现。 如果Queue的数据量不太多，数据量不太大的情况下，酌情考虑，还是可以使用的。</p>
<h1 id="DistributedQueue"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：-队列/#DistributedQueue" class="headerlink" title="DistributedQueue"></a>DistributedQueue</h1><p>DistributedQueue是最普通的一种队列。 它设计以下四个类：</p>
<pre><code>QueueBuilder
QueueConsumer
QueueSerializer
DistributedQueue
</code></pre><p>创建队列使用QueueBuilder,它也是其它队列的创建类。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">QueueBuilder&lt;T&gt; <span class="title">builder</span><span class="params">(CuratorFramework client,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          QueueConsumer&lt;T&gt; consumer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          QueueSerializer&lt;T&gt; serializer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          java.lang.String queuePath)</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QueueBuilder&lt;MessageType&gt;    builder = QueueBuilder.builder(client, consumer, serializer, path);</span><br><span class="line">... more builder method calls as needed ...</span><br><span class="line">DistributedQueue&lt;MessageType queue = builder.build();	`</span><br></pre></td></tr></table></figure>
<p>创建好queue就可以往里面放入数据了：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">queue.put(aMessage);</span><br></pre></td></tr></table></figure></p>
<p>QueueSerializer提供了对队列中的对象的序列化和反序列化。</p>
<p>QueueConsumer是消费者， 它可以接收队列的数据。 处理队列中的数据的代码逻辑可以放在QueueConsumer.consumeMessage()中。</p>
<p>正常情况下先将消息从队列中移除，再交给消费者消费。 但这是两个步骤，不是原子的。 可以调用Builder的lockPath()消费者加锁， 当消费者消费数据时持有锁，这样其它消费者不能消费此消息。 如果消费失败或者进程死掉，消息可以交给其它进程。这会带来一点性能的损失。 最好还是单消费者模式使用队列。</p>
<p>例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.queue;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.api.CuratorEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.api.CuratorListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.queue.DistributedQueue;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.queue.QueueBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.queue.QueueConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.queue.QueueSerializer;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.state.ConnectionState;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistributedQueueExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/example/queue"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		CuratorFramework client = <span class="keyword">null</span>;</span><br><span class="line">		DistributedQueue&lt;String&gt; queue = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.getCuratorListenable().addListener(<span class="keyword">new</span> CuratorListener() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eventReceived</span><span class="params">(CuratorFramework client, CuratorEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">					System.out.println(<span class="string">"CuratorEvent: "</span> + event.getType().name());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">			client.start();</span><br><span class="line">			QueueConsumer&lt;String&gt; consumer = createQueueConsumer();</span><br><span class="line">			QueueBuilder&lt;String&gt; builder = QueueBuilder.builder(client, consumer, createQueueSerializer(), PATH);</span><br><span class="line">			queue = builder.buildQueue();</span><br><span class="line">			queue.start();</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">				queue.put(<span class="string">" test-"</span> + i);</span><br><span class="line">				Thread.sleep((<span class="keyword">long</span>)(<span class="number">3</span> * Math.random()));</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(queue);</span><br><span class="line">			CloseableUtils.closeQuietly(client);</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueSerializer&lt;String&gt; <span class="title">createQueueSerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueSerializer&lt;String&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(String item) &#123;</span><br><span class="line">				<span class="keyword">return</span> item.getBytes();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> String(bytes);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> QueueConsumer&lt;String&gt; <span class="title">createQueueConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> QueueConsumer&lt;String&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"connection new state: "</span> + newState.name());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessage</span><span class="params">(String message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"consume one message: "</span> + message);				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="DistributedIdQueue"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：-队列/#DistributedIdQueue" class="headerlink" title="DistributedIdQueue"></a>DistributedIdQueue</h1><h1 id="DistributedPriorityQueue"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：-队列/#DistributedPriorityQueue" class="headerlink" title="DistributedPriorityQueue"></a>DistributedPriorityQueue</h1><h1 id="DistributedDelayQueue"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：-队列/#DistributedDelayQueue" class="headerlink" title="DistributedDelayQueue"></a>DistributedDelayQueue</h1><h1 id="SimpleDistributedQueue"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：-队列/#SimpleDistributedQueue" class="headerlink" title="SimpleDistributedQueue"></a>SimpleDistributedQueue</h1>]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着实例学习zookeeper的用法：Leader选举</title>
    <url>/2017/04/22/%E8%B7%9F%E7%9D%80%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0zookeeper%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9ALeader%E9%80%89%E4%B8%BE/</url>
    <content><![CDATA[<h1 id="leader选举"><a href="/2017/04/22/跟着实例学习zookeeper的用法：Leader选举/#leader选举" class="headerlink" title="leader选举"></a>leader选举</h1><p>在分布式计算中， leader election是很重要的一个功能， 这个选举过程是这样子的： 指派一个进程作为组织者，将任务分发给各节点。 在任务开始前， 哪个节点都不知道谁是leader或者coordinator. 当选举算法开始执行后， 每个节点最终会得到一个唯一的节点作为任务leader.<br>除此之外， 选举还经常会发生在leader意外宕机的情况下，新的leader要被选举出来。</p>
<p>Curator 有两种选举recipe， 你可以根据你的需求选择合适的。</p>
<h2 id="Leader-latch"><a href="/2017/04/22/跟着实例学习zookeeper的用法：Leader选举/#Leader-latch" class="headerlink" title="Leader latch"></a>Leader latch</h2><p>首先我们看一个使用<code>LeaderLatch</code>类来选举的例子。<br>它的构造函数如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderLatch</span><span class="params">(CuratorFramework client, String latchPath)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderLatch</span><span class="params">(CuratorFramework client, String latchPath,  String id)</span></span></span><br></pre></td></tr></table></figure></p>
<p>必须启动<code>LeaderLatch: leaderLatch.start()</code>;<br>一旦启动， <code>LeaderLatch</code>会和其它使用相同latch path的其它LeaderLatch交涉，然后随机的选择其中一个作为leader。 你可以随时查看一个给定的实例是否是leader:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasLeadership</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>类似JDK的CountDownLatch， LeaderLatch在请求成为leadership时有block方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">                 EOFException</span></span><br><span class="line"><span class="function">Causes the current thread to wait until <span class="keyword">this</span> instance acquires leadership</span></span><br><span class="line"><span class="function">unless the thread is interrupted or closed.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">                     TimeUnit unit)</span></span></span><br><span class="line"><span class="function">             <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure></p>
<p>一旦不使用LeaderLatch了，必须调用close方法。 如果它是leader,会释放leadership， 其它的参与者将会选举一个leader。</p>
<p><strong>异常处理</strong><br>LeaderLatch实例可以增加ConnectionStateListener来监听网络连接问题。 当 SUSPENDED 或 LOST 时, leader不再认为自己还是leader.当LOST 连接重连后 RECONNECTED,LeaderLatch会删除先前的ZNode然后重新创建一个.<br>LeaderLatch用户必须考虑导致leadershi丢失的连接问题。 强烈推荐你使用ConnectionStateListener。</p>
<p>下面看例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.leaderelection;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderLatch;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderLatchExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_QTY = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/leader"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;CuratorFramework&gt; clients = Lists.newArrayList();</span><br><span class="line">		List&lt;LeaderLatch&gt; examples = Lists.newArrayList();</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENT_QTY; ++i) &#123;</span><br><span class="line">				CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">				clients.add(client);</span><br><span class="line">				LeaderLatch example = <span class="keyword">new</span> LeaderLatch(client, PATH, <span class="string">"Client #"</span> + i);</span><br><span class="line">				examples.add(example);</span><br><span class="line">				client.start();</span><br><span class="line">				example.start();</span><br><span class="line">			&#125;</span><br><span class="line">			Thread.sleep(<span class="number">20000</span>);</span><br><span class="line">			LeaderLatch currentLeader = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENT_QTY; ++i) &#123;</span><br><span class="line">				LeaderLatch example = examples.get(i);</span><br><span class="line">				<span class="keyword">if</span> (example.hasLeadership())</span><br><span class="line">					currentLeader = example;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"current leader is "</span> + currentLeader.getId());</span><br><span class="line">			System.out.println(<span class="string">"release the leader "</span> + currentLeader.getId());</span><br><span class="line">			currentLeader.close();</span><br><span class="line">			examples.get(<span class="number">0</span>).await(<span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">			System.out.println(<span class="string">"Client #0 maybe is elected as the leader or not although it want to be"</span>);</span><br><span class="line">			System.out.println(<span class="string">"the new leader is "</span> + examples.get(<span class="number">0</span>).getLeader().getId());</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"Press enter/return to quit\n"</span>);</span><br><span class="line">			<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)).readLine();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"Shutting down..."</span>);</span><br><span class="line">			<span class="keyword">for</span> (LeaderLatch exampleClient : examples) &#123;</span><br><span class="line">				CloseableUtils.closeQuietly(exampleClient);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (CuratorFramework client : clients) &#123;</span><br><span class="line">				CloseableUtils.closeQuietly(client);</span><br><span class="line">			&#125;</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们创建了10个LeaderLatch，启动后它们中的一个会被选举为leader。 因为选举会花费一些时间，start后并不能马上就得到leader。<br>通过hasLeadership查看自己是否是leader， 如果是的话返回true。<br>可以通过.getLeader().getId()可以得到当前的leader的ID。<br>只能通过close释放当前的领导权。<br>await是一个阻塞方法， 尝试获取leader地位，但是未必能上位。</p>
<p>##Leader Election<br>Curator还提供了另外一种选举方法。<br>注意涉及以下四个类：</p>
<pre><code>LeaderSelector
LeaderSelectorListener
LeaderSelectorListenerAdapter
CancelLeadershipException
</code></pre><p>重要的是LeaderSelector类，它的构造函数为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderSelector</span><span class="params">(CuratorFramework client, String mutexPath,LeaderSelectorListener listener)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeaderSelector</span><span class="params">(CuratorFramework client, String mutexPath, ThreadFactory threadFactory, Executor executor, LeaderSelectorListener listener)</span></span></span><br></pre></td></tr></table></figure></p>
<p>类似LeaderLatch,必须start: leaderSelector.start();<br>一旦启动，当实例取得领导权时你的listener的takeLeadership()方法被调用. 而takeLeadership()方法只有领导权被释放时才返回。<br>当你不再使用LeaderSelector实例时，应该调用它的close方法。</p>
<p><strong>异常处理</strong><br>LeaderSelectorListener类继承ConnectionStateListener.LeaderSelector必须小心连接状态的改变. 如果实例成为leader, 它应该相应SUSPENDED 或 LOST. 当 SUSPENDED 状态出现时， 实例必须假定在重新连接成功之前它可能不再是leader了。 如果LOST状态出现， 实例不再是leader， takeLeadership方法返回.</p>
<p>重要: 推荐处理方式是当收到SUSPENDED 或 LOST时抛出CancelLeadershipException异常. 这会导致LeaderSelector实例中断并取消执行takeLeadership方法的异常. 这非常重要， 你必须考虑扩展LeaderSelectorListenerAdapter. LeaderSelectorListenerAdapter提供了推荐的处理逻辑。</p>
<p>这个例子摘自官方。<br>首先创建一个ExampleClient类， 它继承LeaderSelectorListenerAdapter， 它实现了takeLeadership方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.leaderelection;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelectorListenerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelector;</span><br><span class="line"><span class="keyword">import</span> java.io.Closeable;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClient</span> <span class="keyword">extends</span> <span class="title">LeaderSelectorListenerAdapter</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> LeaderSelector leaderSelector;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger leaderCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ExampleClient</span><span class="params">(CuratorFramework client, String path, String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		leaderSelector = <span class="keyword">new</span> LeaderSelector(client, path, <span class="keyword">this</span>);</span><br><span class="line">		leaderSelector.autoRequeue();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		leaderSelector.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		leaderSelector.close();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(CuratorFramework client)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="keyword">int</span> waitSeconds = (<span class="keyword">int</span>) (<span class="number">5</span> * Math.random()) + <span class="number">1</span>;</span><br><span class="line">		System.out.println(name + <span class="string">" is now the leader. Waiting "</span> + waitSeconds + <span class="string">" seconds..."</span>);</span><br><span class="line">		System.out.println(name + <span class="string">" has been leader "</span> + leaderCount.getAndIncrement() + <span class="string">" time(s) before."</span>);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(TimeUnit.SECONDS.toMillis(waitSeconds));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			System.err.println(name + <span class="string">" was interrupted."</span>);</span><br><span class="line">			Thread.currentThread().interrupt();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(name + <span class="string">" relinquishing leadership.\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以在takeLeadership进行任务的分配等等，并且不要返回，如果你想要要此实例一直是leader的话可以加一个死循环。<br>leaderSelector.autoRequeue();保证在此实例释放领导权之后还可能获得领导权。<br>在这里我们使用AtomicInteger来记录此client获得领导权的次数， 它是”fair”， 每个client有平等的机会获得领导权。</p>
<p>测试代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.leaderelection;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.leader.LeaderSelector;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</span><br><span class="line"><span class="keyword">import</span> com.google.common.collect.Lists;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderSelectorExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_QTY = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/leader"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List&lt;CuratorFramework&gt; clients = Lists.newArrayList();</span><br><span class="line">		List&lt;ExampleClient&gt; examples = Lists.newArrayList();</span><br><span class="line">		TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENT_QTY; ++i) &#123;</span><br><span class="line">				CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">				clients.add(client);</span><br><span class="line">				ExampleClient example = <span class="keyword">new</span> ExampleClient(client, PATH, <span class="string">"Client #"</span> + i);</span><br><span class="line">				examples.add(example);</span><br><span class="line">				client.start();</span><br><span class="line">				example.start();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"Press enter/return to quit\n"</span>);</span><br><span class="line">			<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)).readLine();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"Shutting down..."</span>);</span><br><span class="line">			<span class="keyword">for</span> (ExampleClient exampleClient : examples) &#123;</span><br><span class="line">				CloseableUtils.closeQuietly(exampleClient);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (CuratorFramework client : clients) &#123;</span><br><span class="line">				CloseableUtils.closeQuietly(client);</span><br><span class="line">			&#125;</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与LeaderLatch， 通过LeaderSelectorListener可以对领导权进行控制， 在适当的时候释放领导权，这样每个节点都有可能获得领导权。 而LeaderLatch一根筋到死， 除非调用close方法，否则它不会释放领导权。</p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>服务发现：Zookeeper vs etcd vs Consul</title>
    <url>/2017/04/09/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%9AZookeeper-vs-etcd-vs-Consul/</url>
    <content><![CDATA[<p>如果使用预定义的端口，服务越多，发生冲突的可能性越大，毕竟，不可能有两个服务监听同一个端口。管理一个拥挤的比方说被几百个服务所使用的所有端口的列表，本身就是一个挑战，添加到该列表后，这些服务需要的数据库和数量会日益增多。因此我们应该部署无需指定端口的服务，并且让Docker为我们分配一个随机的端口。唯一的问题是我们需要发现端口号，并且让别人知道。<br><img src="https://clyhs.github.io/images/ezc/ezc01.png" alt="img"><br>当我们开始在一个分布式系统上部署服务到其中一台服务器上时，事情会变得更加复杂，我们可以选择预先定义哪台服务器运行哪个服务的方式，但这会导致很多问题。我们应该尽我们所能尽量利用服务器资源，但是如果预先定义每个服务的部署位置，那么要实现尽量利用服务器资源是几乎不可能的。另一个问题是服务的自动伸缩将会非常困难，更不用说自动恢复了，比方说服务器故障。另一方面，如果我们将服务部署到某台只有最少数量的容器在运行的服务器上，我们需要添加IP地址到数据列表中，这些数据需要可以被发现并存储在某处。<br><img src="https://clyhs.github.io/images/ezc/ezc02.png" alt="img"><br>当我们需要存储和发现一些与正在工作的服务相关的信息时，还有很多其他的例子。</p>
<p>为了能够定位服务，我们需要至少接下来的两个有用的步骤。</p>
<ul>
<li>服务注册——该步骤存储的信息至少包括正在运行的服务的主机和端口信息</li>
<li>服务发现——该步骤允许其他用户可以发现在服务注册阶段存储的信息。</li>
</ul>
<p>除了上述的步骤，我们还需要考虑其他方面。如果一个服务停止工作并部署/注册了一个新的服务实例，那么该服务是否应该注销呢？当有相同服务的多个副本时咋办？我们该如何做负载均衡呢？如果一个服务器宕机了咋办？所有这些问题都与注册和发现阶段紧密关联。现在，我们限定只在服务发现的范围里（常见的名字，围绕上述步骤）以及用于服务发现任务的工具，它们中的大多数采用了高可用的分布式键/值存储。</p>
<h3 id="服务发现工具"><a href="/2017/04/09/服务发现：Zookeeper-vs-etcd-vs-Consul/#服务发现工具" class="headerlink" title="服务发现工具"></a>服务发现工具</h3><p>服务发现工具的主要目标是用来服务查找和相互对话，为此该工具需要知道每个服务，这不是一个新概念，在Docker之前就已经存在很多类似的工具了，然而，容器带给了这些工具一个全新水平的需求。</p>
<p>服务发现背后的基本思想是对于服务的每一个新实例（或应用程序），能够识别当前环境和存储相关信息。存储的注册表信息本身通常采用键/值对的格式，由于服务发现经常用于分布式系统，所以要求这些信息可伸缩、支持容错和分布式集群中的所有节点。这种存储的主要用途是给所有感兴趣的各方提供最起码诸如服务IP地址和端口这样的信息，用于它们之间的相互通讯，这些数据还经常扩展到其它类型的信息服务发现工具倾向于提供某种形式的API，用于服务自身的注册以及服务信息的查找。</p>
<p>比方说我们有两个服务，一个是提供方，另一个是第一个服务的消费者，一旦部署了服务提供方，就需要在服务发现注册表中存储其信息。接着，当消费者试图访问服务提供者时，它首先查询服务注册表，使用获取到的IP地址和端口来调用服务提供者。为了与注册表中的服务提供方的具体实现解耦，我们常常采用某种代理服务。这样消费者总是向固定IP地址的代理请求信息，代理再依次使用服务发现来查找服务提供方信息并重定向请求，在本文中我们稍后通过反向代理来实现。现在重要的是要理解基于三种角色（服务消费者、提供者和代理）的服务发现流程。</p>
<p>服务发现工具要查找的是数据，至少我们应该能够找出服务在哪里？服务是否健康和可用？配置是什么样的？既然我们正在多台服务器上构建一个分布式系统，那么该工具需要足够健壮，保证其中一个节点的宕机不会危及数据，同时，每个节点应该有完全相同的数据副本，进一步地，我们希望能够以任何顺序启动服务、杀死服务或者替换服务的新版本，我们还应该能够重新配置服务并且查看到数据相应的变化。</p>
<p>让我们看一下一些常用的选项来完成我们上面设定的目标。</p>
<h3 id="手动配置"><a href="/2017/04/09/服务发现：Zookeeper-vs-etcd-vs-Consul/#手动配置" class="headerlink" title="手动配置"></a>手动配置</h3><p>大多数服务仍然是需要手动管理的，我们预先决定在何处部署服务、如何配置和希望不管什么原因，服务都将继续正常工作，直到天荒地老。这样的目标不是可以轻易达到的。部署第二个服务实例意味着我们需要启动全程的手动处理，我们需要引入一台新的服务器，或者找出哪一台服务器资源利用率较低，然后创建一个新的配置集并启动服务。情况或许会变得越来越复杂，比方说，硬件故障导致的手动管理下的反应时间变得很慢。可见性是另外一个痛点，我们知道什么是静态配置，毕竟是我们预先准备好的，然而，大多数的服务有很多动态生成的信息，这些信息不是轻易可见的，也没有一个单独的地方供我们在需要时参考这些数据。</p>
<p>反应时间会不可避免的变慢，鉴于存在许多需要手动处理的移动组件，故障恢复和监控也会变得非常难以管理。</p>
<p>尽管在过去或者当服务/服务器数量很少的时候有借口不做这项工作，随着服务发现工具的出现，这个借口已经不存在了。</p>
<p>###Zookeeper<br>Zookeeper是这种类型的项目中历史最悠久的之一，它起源于Hadoop，帮助在Hadoop集群中维护各种组件。它非常成熟、可靠，被许多大公司（YouTube、eBay、雅虎等）使用。其数据存储的格式类似于文件系统，如果运行在一个服务器集群中，Zookeper将跨所有节点共享配置状态，每个集群选举一个领袖，客户端可以连接到任何一台服务器获取数据。</p>
<p>Zookeeper的主要优势是其成熟、健壮以及丰富的特性，然而，它也有自己的缺点，其中采用Java开发以及复杂性是罪魁祸首。尽管Java在许多方面非常伟大，然后对于这种类型的工作还是太沉重了，Zookeeper使用Java以及相当数量的依赖使其对于资源竞争非常饥渴。因为上述的这些问题，Zookeeper变得非常复杂，维护它需要比我们期望从这种类型的应用程序中获得的收益更多的知识。这部分地是由于丰富的特性反而将其从优势转变为累赘。应用程序的特性功能越多，就会有越大的可能性不需要这些特性，因此，我们最终将会为这些不需要的特性付出复杂度方面的代价。</p>
<p>Zookeeper为其他项目相当大的改进铺平了道路，“大数据玩家“在使用它，因为没有更好的选择。今天，Zookeeper已经老态龙钟了，我们有了更好的选择。</p>
<h3 id="etcd"><a href="/2017/04/09/服务发现：Zookeeper-vs-etcd-vs-Consul/#etcd" class="headerlink" title="etcd"></a>etcd</h3><p>etcd是一个采用HTTP协议的健/值对存储系统，它是一个分布式和功能层次配置系统，可用于构建服务发现系统。其很容易部署、安装和使用，提供了可靠的数据持久化特性。它是安全的并且文档也十分齐全。</p>
<p>etcd比Zookeeper是比更好的选择，因为它很简单，然而，它需要搭配一些第三方工具才可以提供服务发现功能。<br><img src="https://clyhs.github.io/images/ezc/ezc03.png" alt="img"></p>
<p>现在，我们有一个地方来存储服务相关信息，我们还需要一个工具可以自动发送信息给etcd。但在这之后，为什么我们还需要手动把数据发送给etcd呢？即使我们希望手动将信息发送给etcd，我们通常情况下也不会知道是什么信息。记住这一点，服务可能会被部署到一台运行最少数量容器的服务器上，并且随机分配一个端口。理想情况下，这个工具应该监视所有节点上的Docker容器，并且每当有新容器运行或者现有的一个容器停止的时候更新etcd，其中的一个可以帮助我们达成目标的工具就是Registrator。</p>
<h4 id="Registrator"><a href="/2017/04/09/服务发现：Zookeeper-vs-etcd-vs-Consul/#Registrator" class="headerlink" title="Registrator"></a>Registrator</h4><p>Registrator通过检查容器在线或者停止运行状态自动注册和去注册服务，它目前支持etcd、Consul和SkyDNS 2。</p>
<p>Registrator与etcd是一个简单但是功能强大的组合，可以运行很多先进的技术。每当我们打开一个容器，所有数据将被存储在etcd并传播到集群中的所有节点。我们将决定什么信息是我们的。<br><img src="https://clyhs.github.io/images/ezc/ezc04.png" alt="img"><br>上述的拼图游戏还缺少一块，我们需要一种方法来创建配置文件，与数据都存储在etcd，通过运行一些命令来创建这些配置文件。</p>
<h4 id="Confd"><a href="/2017/04/09/服务发现：Zookeeper-vs-etcd-vs-Consul/#Confd" class="headerlink" title="Confd"></a>Confd</h4><p>Confd是一个轻量级的配置管理工具，常见的用法是通过使用存储在etcd、consul和其他一些数据登记处的数据保持配置文件的最新状态，它也可以用来在配置文件改变时重新加载应用程序。换句话说，我们可以用存储在etcd（或者其他注册中心）的信息来重新配置所有服务。<br><img src="https://clyhs.github.io/images/ezc/ezc05.png" alt="img"></p>
<h3 id="对于etcd、Registrator和Confd组合的最后的思考"><a href="/2017/04/09/服务发现：Zookeeper-vs-etcd-vs-Consul/#对于etcd、Registrator和Confd组合的最后的思考" class="headerlink" title="对于etcd、Registrator和Confd组合的最后的思考"></a>对于etcd、Registrator和Confd组合的最后的思考</h3><p>当etcd、Registrator和Confd结合时，可以获得一个简单而强大的方法来自动化操作我们所有的服务发现和需要的配置。这个组合还展示了“小”工具正确组合的有效性，这三个小东西可以如我们所愿正好完成我们需要达到的目标，若范围稍微小一些，我们将无法完成我们面前的目标，而另一方面如果他们设计时考虑到更大的范围，我们将引入不必要的复杂性和服务器资源开销。</p>
<p>在我们做出最后的判决之前，让我们看看另一个有相同目标的工具组合，毕竟，我们不应该满足于一些没有可替代方案的选择。</p>
<h3 id="Consul"><a href="/2017/04/09/服务发现：Zookeeper-vs-etcd-vs-Consul/#Consul" class="headerlink" title="Consul"></a>Consul</h3><p>Consul是强一致性的数据存储，使用gossip形成动态集群。它提供分级键/值存储方式，不仅可以存储数据，而且可以用于注册器件事各种任务，从发送数据改变通知到运行健康检查和自定义命令，具体如何取决于它们的输出。</p>
<p>与Zookeeper和etcd不一样，Consul内嵌实现了服务发现系统，所以这样就不需要构建自己的系统或使用第三方系统。这一发现系统除了上述提到的特性之外，还包括节点健康检查和运行在其上的服务。</p>
<p>Zookeeper和etcd只提供原始的键/值队存储，要求应用程序开发人员构建他们自己的系统提供服务发现功能。而Consul提供了一个内置的服务发现的框架。客户只需要注册服务并通过DNS或HTTP接口执行服务发现。其他两个工具需要一个亲手制作的解决方案或借助于第三方工具。</p>
<p>Consul为多种数据中心提供了开箱即用的原生支持，其中的gossip系统不仅可以工作在同一集群内部的各个节点，而且还可以跨数据中心工作。<br><img src="https://clyhs.github.io/images/ezc/ezc06.png" alt="img"><br>Consul还有另一个不错的区别于其他工具的功能，它不仅可以用来发现已部署的服务以及其驻留的节点信息，还通过HTTP请求、TTLs（time-to-live）和自定义命令提供了易于扩展的健康检查特性。</p>
<h4 id="Registrator-1"><a href="/2017/04/09/服务发现：Zookeeper-vs-etcd-vs-Consul/#Registrator-1" class="headerlink" title="Registrator"></a>Registrator</h4><p>Registrator有两个Consul协议，其中consulkv协议产生类似于etcd协议的结果。</p>
<p>除了通常的IP和端口存储在etcd或consulkv协议中之外，Registrator consul协议存储了更多的信息，我们可以得到服务运行节点的信息，以及服务ID和名称。我们也可以借助于一些额外的环境变量按照一定的标记存储额外的信息。<br><img src="https://clyhs.github.io/images/ezc/ezc07.png" alt="img"></p>
<h4 id="Consul-template"><a href="/2017/04/09/服务发现：Zookeeper-vs-etcd-vs-Consul/#Consul-template" class="headerlink" title="Consul-template"></a>Consul-template</h4><p>confd可以像和etce搭配一样用于Consul，不过Consul有自己的模板服务，其更适配Consul。</p>
<p>通过从Consul获得的信息，Consul-template是一个非常方便的创建文件的途径，还有一个额外的好处就是在文件更新后可以运行任意命令，正如confd，Consul-template也可以使用Go模板格式。<br><img src="https://clyhs.github.io/images/ezc/ezc08.png" alt="img"></p>
<h4 id="Consul健康检查、Web界面和数据中心"><a href="/2017/04/09/服务发现：Zookeeper-vs-etcd-vs-Consul/#Consul健康检查、Web界面和数据中心" class="headerlink" title="Consul健康检查、Web界面和数据中心"></a>Consul健康检查、Web界面和数据中心</h4><p>监控集群节点和服务的健康状态与测试和部署它们一样的重要。虽然我们应该向着拥有从来没有故障的稳定的环境努力，但我们也应该承认，随时会有意想不到的故障发生，时刻准备着采取相应的措施。例如我们可以监控内存使用情况，如果达到一定的阈值，那么迁移一些服务到集群中的另外一个节点，这将是在发生“灾难”前执行的一个预防措施。另一方面，并不是所有潜在的故障都可以被及时检测到并采取措施。单个服务可能会齿白，一个完整的节点也可能由于硬件故障而停止工作。在这种情况下我们应该准备尽快行动，例如一个节点替换为一个新的并迁移失败的服务。Consul有一个简单的、优雅的但功能强大的方式进行健康检查，当健康阀值达到一定数目时，帮助用户定义应该执行的操作。</p>
<p>如果用户Google搜索“etcd ui”或者“etec dashboard”时，用户可能看到只有几个可用的解决方案，可能会问为什么我们还没有介绍给用户，这个原因很简单，etcd只是键/值对存储，仅此而已。通过一个UI呈现数据没有太多的用处，因为我们可以很容易地通过etcdctl获得这些数据。这并不意味着etcd UI是无用的，但鉴于其有限的使用范围，它不会产生多大影响。</p>
<p>Consu不仅仅是一个简单的键/值对存储，正如我们已经看到的，除了存储简单的键/值对，它还有一个服务的概念以及所属的数据。它还可以执行健康检查，因此成为一个好的候选dashboard，在上面可以看到我们的节点的状态和运行的服务。最后，它支持了多数据中心的概念。所有这些特性的结合让我们从不同的角度看到引入dashboard的必要性。</p>
<p>通过Consul Web界面，用户可以查看所有的服务和节点、监控健康检查状态以及通过切换数据中心读取设置键/值对数据。<br><img src="https://clyhs.github.io/images/ezc/ezc09.png" alt="img"></p>
<h3 id="对于Consul、Registrator、Template、健康检查和Web-UI的最终思考"><a href="/2017/04/09/服务发现：Zookeeper-vs-etcd-vs-Consul/#对于Consul、Registrator、Template、健康检查和Web-UI的最终思考" class="headerlink" title="对于Consul、Registrator、Template、健康检查和Web UI的最终思考"></a>对于Consul、Registrator、Template、健康检查和Web UI的最终思考</h3><p>Consul以及上述我们一起探讨的工具在很多情况下提供了比etcd更好的解决方案。这是从内心深处为了服务架构和发现而设计的方案，简单而强大。它提供了一个完整的同时不失简洁的解决方案，在许多情况下，这是最佳的服务发现以及满足健康检查需求的工具。</p>
<h3 id="结论"><a href="/2017/04/09/服务发现：Zookeeper-vs-etcd-vs-Consul/#结论" class="headerlink" title="结论"></a>结论</h3><p>所有这些工具都是基于相似的原则和架构，它们在节点上运行，需要仲裁来运行，并且都是强一致性的，都提供某种形式的键/值对存储。</p>
<p>Zookeeper是其中最老态龙钟的一个，使用年限显示出了其复杂性、资源利用和尽力达成的目标，它是为了与我们评估的其他工具所处的不同时代而设计的（即使它不是老得太多）。</p>
<p>etcd、Registrator和Confd是一个非常简单但非常强大的组合，可以解决大部分问题，如果不是全部满足服务发现需要的话。它还展示了我们可以通过组合非常简单和特定的工具来获得强大的服务发现能力，它们中的每一个都执行一个非常具体的任务，通过精心设计的API进行通讯，具备相对自治工作的能力，从架构和功能途径方面都是微服务方式。</p>
<p>Consul的不同之处在于无需第三方工具就可以原生支持多数据中心和健康检查，这并不意味着使用第三方工具不好。实际上，在这篇博客里我们通过选择那些表现更佳同时不会引入不必要的功能的的工具，尽力组合不同的工具。使用正确的工具可以获得最好的结果。如果工具引入了工作不需要的特性，那么工作效率反而会下降，另一方面，如果工具没有提供工作所需要的特性也是没有用的。Consul很好地权衡了权重，用尽量少的东西很好的达成了目标。</p>
<p>Consul使用gossip来传播集群信息的方式，使其比etcd更易于搭建，特别是对于大的数据中心。将存储数据作为服务的能力使其比etcd仅仅只有健/值对存储的特性更加完整、更有用（即使Consul也有该选项）。虽然我们可以在etcd中通过插入多个键来达成相同的目标，Consul的服务实现了一个更紧凑的结果，通常只需要一次查询就可以获得与服务相关的所有数据。除此之外，Registrator很好地实现了Consul的两个协议，使其合二为一，特别是添加Consul-template到了拼图中。Consul的Web UI更是锦上添花般地提供了服务和健康检查的可视化途径。</p>
<p>我不能说Consul是一个明确的赢家，而是与etcd相比其有一个轻微的优势。服务发现作为一个概念，以及作为工具都很新，我们可以期待在这一领域会有许多的变化。秉承开放的心态，大家可以对本文的建议持保留态度，尝试不同的工具然后做出自己的结论。</p>
<p>原文链接：Service Discovery: Zookeeper vs etcd vs Consul（翻译：胡震）</p>
]]></content>
      <categories>
        <category>服务发现</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>zookeeper</tag>
        <tag>consul</tag>
      </tags>
  </entry>
  <entry>
    <title>跟着实例学习ZooKeeper的用法：分布式锁</title>
    <url>/2017/04/22/%E8%B7%9F%E7%9D%80%E5%AE%9E%E4%BE%8B%E5%AD%A6%E4%B9%A0ZooKeeper%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="锁"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：分布式锁/#锁" class="headerlink" title="锁"></a>锁</h1><p>分布式的锁全局同步， 这意味着任何一个时间点不会有两个客户端都拥有相同的锁。</p>
<h2 id="可重入锁Shared-Reentrant-Lock"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：分布式锁/#可重入锁Shared-Reentrant-Lock" class="headerlink" title="可重入锁Shared Reentrant Lock"></a>可重入锁Shared Reentrant Lock</h2><p>首先我们先看一个全局可重入的锁。 Shared意味着锁是全局可见的， 客户端都可以请求锁。 Reentrant和JDK的ReentrantLock类似， 意味着同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞。<br>它是由类InterProcessMutex来实现。<br>它的构造函数为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMutex</span><span class="params">(CuratorFramework client, String path)</span></span></span><br></pre></td></tr></table></figure></p>
<p>通过acquire获得锁，并提供超时机制：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Acquire the mutex - blocking until it's available. Note: the same thread can call acquire</span></span><br><span class="line"><span class="function">re-entrantly. Each call to acquire must be balanced by a call to <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time,</span></span></span><br><span class="line"><span class="function"><span class="params">                       TimeUnit unit)</span></span></span><br><span class="line"><span class="function">Acquire the mutex - blocks until it's available or the given time expires. Note: the same thread can</span></span><br><span class="line"><span class="function">call acquire re-entrantly. Each call to acquire that returns <span class="keyword">true</span> must be balanced by a call to <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">time - time to wait</span></span><br><span class="line"><span class="function">unit - time unit</span></span><br><span class="line"><span class="function">Returns:</span></span><br><span class="line"><span class="function"><span class="keyword">true</span> <span class="keyword">if</span> the mutex was acquired, <span class="keyword">false</span> <span class="keyword">if</span> not</span></span><br></pre></td></tr></table></figure></p>
<p>通过release()方法释放锁。<br>InterProcessMutex 实例可以重用。</p>
<p><strong>Revoking</strong><br>ZooKeeper recipes wiki定义了可协商的撤销机制。<br>为了撤销mutex, 调用下面的方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeRevocable</span><span class="params">(RevocationListener&lt;T&gt; listener)</span></span></span><br><span class="line"><span class="function">将锁设为可撤销的. 当别的进程或线程想让你释放锁是Listener会被调用。</span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">listener - the listener</span></span><br></pre></td></tr></table></figure></p>
<p>如果你请求撤销当前的锁， 调用Revoker方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attemptRevoke</span><span class="params">(CuratorFramework client,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String path)</span></span></span><br><span class="line"><span class="function">                         <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">Utility to mark a lock <span class="keyword">for</span> revocation. Assuming that the lock has been registered</span></span><br><span class="line"><span class="function">with a RevocationListener, it will get called and the lock should be released. Note,</span></span><br><span class="line"><span class="function">however, that revocation is cooperative.</span></span><br><span class="line"><span class="function">Parameters:</span></span><br><span class="line"><span class="function">client - the client</span></span><br><span class="line"><span class="function">path - the path of the lock - usually from something like InterProcessMutex.<span class="title">getParticipantNodes</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>错误处理</strong><br>还是强烈推荐你使用ConnectionStateListener处理连接状态的改变。 当连接LOST时你不再拥有锁。</p>
<p>首先让我们创建一个模拟的共享资源， 这个资源期望只能单线程的访问，否则会有并发问题。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FakeLimitedResource</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean inUse = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// 真实环境中我们会在这里访问/维护一个共享的资源</span></span><br><span class="line">		<span class="comment">//这个例子在使用锁的情况下不会非法并发异常IllegalStateException</span></span><br><span class="line">		<span class="comment">//但是在无锁的情况由于sleep了一段时间，很容易抛出异常</span></span><br><span class="line">		<span class="keyword">if</span> (!inUse.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123; </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Needs to be used by one client at a time"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep((<span class="keyword">long</span>) (<span class="number">3</span> * Math.random()));</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			inUse.set(<span class="keyword">false</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后创建一个ExampleClientThatLocks类， 它负责请求锁， 使用资源，释放锁这样一个完整的访问过程。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClientThatLocks</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex lock;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> FakeLimitedResource resource;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String clientName;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ExampleClientThatLocks</span><span class="params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resource = resource;</span><br><span class="line">		<span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">		lock = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!lock.acquire(time, unit)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the lock"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(clientName + <span class="string">" has the lock"</span>);</span><br><span class="line">			resource.use(); <span class="comment">//access resource exclusively</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(clientName + <span class="string">" releasing the lock"</span>);</span><br><span class="line">			lock.release(); <span class="comment">// always release the lock in a finally block</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后创建主程序来测试。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessMutexExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REPETITIONS = QTY * <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</span><br><span class="line">		ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">		<span class="keyword">final</span> TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">				<span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">				Callable&lt;Void&gt; task = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">						CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							client.start();</span><br><span class="line">							<span class="keyword">final</span> ExampleClientThatLocks example = <span class="keyword">new</span> ExampleClientThatLocks(client, PATH, resource, <span class="string">"Client "</span> + index);</span><br><span class="line">							<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; REPETITIONS; ++j) &#123;</span><br><span class="line">								example.doWork(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">							CloseableUtils.closeQuietly(client);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;;</span><br><span class="line">				service.submit(task);</span><br><span class="line">			&#125;</span><br><span class="line">			service.shutdown();</span><br><span class="line">			service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			CloseableUtils.closeQuietly(server);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码也很简单，生成10个client， 每个client重复执行10次 请求锁–访问资源–释放锁的过程。每个client都在独立的线程中。<br>结果可以看到，锁是随机的被每个实例排他性的使用。</p>
<p>既然是可重用的，你可以在一个线程中多次调用acquire,在线程拥有锁时它总是返回true。</p>
<p>你不应该在多个线程中用同一个InterProcessMutex， 你可以在每个线程中都生成一个InterProcessMutex实例，它们的path都一样，这样它们可以共享同一个锁。</p>
<h2 id="不可重入锁Shared-Lock"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：分布式锁/#不可重入锁Shared-Lock" class="headerlink" title="不可重入锁Shared Lock"></a>不可重入锁Shared Lock</h2><p>这个锁和上面的相比，就是少了Reentrant的功能，也就意味着它不能在同一个线程中重入。<br>这个类是InterProcessSemaphoreMutex。<br>使用方法和上面的类类似。</p>
<p>首先我们将上面的例子修改一下，测试一下它的重入。<br>修改ExampleClientThatLocks.doWork,连续两次acquire:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!lock.acquire(time, unit)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the lock"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(clientName + <span class="string">" has the lock"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!lock.acquire(time, unit)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the lock"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(clientName + <span class="string">" has the lock again"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span> &#123;			</span><br><span class="line">		resource.use(); <span class="comment">//access resource exclusively</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		System.out.println(clientName + <span class="string">" releasing the lock"</span>);</span><br><span class="line">		lock.release(); <span class="comment">// always release the lock in a finally block</span></span><br><span class="line">		lock.release(); <span class="comment">// always release the lock in a finally block</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意我们也需要调用release两次。这和JDK的ReentrantLock用法一致。如果少调用一次release，则此线程依然拥有锁。<br>上面的代码没有问题，我们可以多次调用acquire，后续的acquire也不会阻塞。<br>将上面的InterProcessMutex换成不可重入锁InterProcessSemaphoreMutex,如果再运行上面的代码，结果就会发现线程被阻塞再第二个acquire上。 也就是此锁不是可重入的。</p>
<h2 id="可重入读写锁Shared-Reentrant-Read-Write-Lock"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：分布式锁/#可重入读写锁Shared-Reentrant-Read-Write-Lock" class="headerlink" title="可重入读写锁Shared Reentrant Read Write Lock"></a>可重入读写锁Shared Reentrant Read Write Lock</h2><p>类似JDK的ReentrantReadWriteLock.<br>一个读写锁管理一对相关的锁。 一个负责读操作，另外一个负责写操作。 读操作在写锁没被使用时可同时由多个进程使用，而写锁使用时不允许读 (阻塞)。<br>此锁是可重入的。一个拥有写锁的线程可重入读锁，但是读锁却不能进入写锁。<br>这也意味着写锁可以降级成读锁， 比如请求写锁 —&gt;读锁 —-&gt;释放写锁。 从读锁升级成写锁是不成的。</p>
<p>主要由两个类实现：</p>
<pre><code>InterProcessReadWriteLock
InterProcessLock
</code></pre><p>使用时首先创建一个InterProcessReadWriteLock实例，然后再根据你的需求得到读锁或者写锁， 读写锁的类型是InterProcessLock。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> InterProcessLock <span class="title">readLock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InterProcessLock <span class="title">writeLock</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>例子和上面的类似。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessReadWriteLock;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessSemaphoreMutex;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleClientReadWriteLocks</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> InterProcessReadWriteLock lock;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex readLock;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> InterProcessMutex writeLock;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> FakeLimitedResource resource;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String clientName;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ExampleClientReadWriteLocks</span><span class="params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.resource = resource;</span><br><span class="line">		<span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">		lock = <span class="keyword">new</span> InterProcessReadWriteLock(client, lockPath);</span><br><span class="line">		readLock = lock.readLock();</span><br><span class="line">		writeLock = lock.writeLock();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!writeLock.acquire(time, unit)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the writeLock"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(clientName + <span class="string">" has the writeLock"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (!readLock.acquire(time, unit)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">" could not acquire the readLock"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(clientName + <span class="string">" has the readLock too"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;			</span><br><span class="line">			resource.use(); <span class="comment">//access resource exclusively</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(clientName + <span class="string">" releasing the lock"</span>);</span><br><span class="line">			readLock.release(); <span class="comment">// always release the lock in a finally block</span></span><br><span class="line">			writeLock.release(); <span class="comment">// always release the lock in a finally block</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个类中我们首先请求了一个写锁， 然后降级成读锁。 执行业务处理，然后释放读写锁。</p>
<h2 id="信号量Shared-Semaphore"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：分布式锁/#信号量Shared-Semaphore" class="headerlink" title="信号量Shared Semaphore"></a>信号量Shared Semaphore</h2><p>一个计数的信号量类似JDK的Semaphore。 JDK中Semaphore维护的一组许可(permits)，而Cubator中称之为租约(Lease)。<br>有两种方式可以决定semaphore的最大租约数。第一种方式是有用户给定的path决定。第二种方式使用SharedCountReader类。<br>如果不使用SharedCountReader, 没有内部代码检查进程是否假定有10个租约而进程B假定有20个租约。 所以所有的实例必须使用相同的numberOfLeases值.</p>
<p>这次调用acquire会返回一个租约对象。 客户端必须在finally中close这些租约对象，否则这些租约会丢失掉。 但是， 但是，如果客户端session由于某种原因比如crash丢掉， 那么这些客户端持有的租约会自动close， 这样其它客户端可以继续使用这些租约。<br>租约还可以通过下面的方式返还：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnAll</span><span class="params">(Collection&lt;Lease&gt; leases)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnLease</span><span class="params">(Lease lease)</span></span></span><br></pre></td></tr></table></figure></p>
<p>注意一次你可以请求多个租约，如果Semaphore当前的租约不够，则请求线程会被阻塞。 同时还提供了超时的重载方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> qty)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lease <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;Lease&gt; <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> qty, <span class="keyword">long</span> time, TimeUnit unit)</span></span></span><br></pre></td></tr></table></figure></p>
<p>主要类有:</p>
<pre><code>InterProcessSemaphoreV2
Lease
SharedCountReader
</code></pre><p>下面是使用的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessSemaphoreV2;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.Lease;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.utils.CloseableUtils;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessSemaphoreExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LEASE = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			InterProcessSemaphoreV2 semaphore = <span class="keyword">new</span> InterProcessSemaphoreV2(client, PATH, MAX_LEASE);</span><br><span class="line">			Collection&lt;Lease&gt; leases = semaphore.acquire(<span class="number">5</span>);</span><br><span class="line">			System.out.println(<span class="string">"get "</span> + leases.size() + <span class="string">" leases"</span>);</span><br><span class="line">			Lease lease = semaphore.acquire();</span><br><span class="line">			System.out.println(<span class="string">"get another lease"</span>);</span><br><span class="line">			resource.use();</span><br><span class="line">			Collection&lt;Lease&gt; leases2 = semaphore.acquire(<span class="number">5</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">			System.out.println(<span class="string">"Should timeout and acquire return "</span> + leases2);</span><br><span class="line">			System.out.println(<span class="string">"return one lease"</span>);</span><br><span class="line">			semaphore.returnLease(lease);</span><br><span class="line">			System.out.println(<span class="string">"return another 5 leases"</span>);</span><br><span class="line">			semaphore.returnAll(leases);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们先获得了5个租约， 最后我们把它还给了semaphore。<br>接着请求了一个租约，因为semaphore还有5个租约，所以请求可以满足，返回一个租约，还剩4个租约。<br>然后再请求一个租约，因为租约不够，阻塞到超时，还是没能满足，返回结果为null。</p>
<p>上面说讲的锁都是公平锁(fair)。 总ZooKeeper的角度看， 每个客户端都按照请求的顺序获得锁。 相当公平。</p>
<h2 id="多锁对象-Multi-Shared-Lock"><a href="/2017/04/22/跟着实例学习ZooKeeper的用法：分布式锁/#多锁对象-Multi-Shared-Lock" class="headerlink" title="多锁对象 Multi Shared Lock"></a>多锁对象 Multi Shared Lock</h2><p>Multi Shared Lock是一个锁的容器。 当调用acquire， 所有的锁都会被acquire，如果请求失败，所有的锁都会被release。 同样调用release时所有的锁都被release(失败被忽略)。<br>基本上，它就是组锁的代表，在它上面的请求释放操作都会传递给它包含的所有的锁。</p>
<p>主要涉及两个类：</p>
<pre><code>InterProcessMultiLock
InterProcessLock
</code></pre><p>它的构造函数需要包含的锁的集合，或者一组ZooKeeper的path。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMultiLock</span><span class="params">(List&lt;InterProcessLock&gt; locks)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InterProcessMultiLock</span><span class="params">(CuratorFramework client, List&lt;String&gt; paths)</span></span></span><br></pre></td></tr></table></figure></p>
<p>用法和Shared Lock相同。</p>
<p>例子如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.colobu.zkrecipe.lock;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessLock;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMultiLock;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessSemaphoreMutex;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.test.TestingServer;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessMultiLockExample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH1 = <span class="string">"/examples/locks1"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH2 = <span class="string">"/examples/locks2"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</span><br><span class="line">		<span class="keyword">try</span> (TestingServer server = <span class="keyword">new</span> TestingServer()) &#123;</span><br><span class="line">			CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">			client.start();</span><br><span class="line">			</span><br><span class="line">			InterProcessLock lock1 = <span class="keyword">new</span> InterProcessMutex(client, PATH1);</span><br><span class="line">			InterProcessLock lock2 = <span class="keyword">new</span> InterProcessSemaphoreMutex(client, PATH2);</span><br><span class="line">			</span><br><span class="line">			InterProcessMultiLock lock = <span class="keyword">new</span> InterProcessMultiLock(Arrays.asList(lock1, lock2));</span><br><span class="line">			<span class="keyword">if</span> (!lock.acquire(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"could not acquire the lock"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"has the lock"</span>);</span><br><span class="line">			</span><br><span class="line">			System.out.println(<span class="string">"has the lock1: "</span> + lock1.isAcquiredInThisProcess());</span><br><span class="line">			System.out.println(<span class="string">"has the lock2: "</span> + lock2.isAcquiredInThisProcess());</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span> &#123;			</span><br><span class="line">				resource.use(); <span class="comment">//access resource exclusively</span></span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"releasing the lock"</span>);</span><br><span class="line">				lock.release(); <span class="comment">// always release the lock in a finally block</span></span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"has the lock1: "</span> + lock1.isAcquiredInThisProcess());</span><br><span class="line">			System.out.println(<span class="string">"has the lock2: "</span> + lock2.isAcquiredInThisProcess());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>新建一个InterProcessMultiLock， 包含一个重入锁和一个非重入锁。<br>调用acquire后可以看到线程同时拥有了这两个锁。<br>调用release看到这两个锁都被释放了。</p>
<p>再重申以便， 强烈推荐使用ConnectionStateListener监控连接的状态。 </p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
</search>
